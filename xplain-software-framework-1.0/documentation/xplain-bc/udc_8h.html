<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xplain-bc: include/usb/udc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/usb/udc.h File Reference</h1>
<p>USB Device Controller interface.  
<a href="#_details">More...</a></p>
<code>#include &lt;<a class="el" href="arch_2avr8_2include_2arch_2bitops_8h_source.html">bitops.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="usb__protocol_8h_source.html">usb/usb_protocol.h</a>&gt;</code><br/>

<p><a href="udc_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudc.html">udc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A USB Device Controller.  <a href="structudc.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#ga20c38cc5aac7cc6b0a3c6ab05428436d">int8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Endpoint identifier.  <a href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga8935b02daf1033b905c9bd51749e57b5">udc_flag</a> { <a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a01d87782d04a61d661fd166ecbbb8f0c">UDC_IS_ENABLED</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a75413d1b8163e224b9a964dab1d50db8">UDC_AUTOATTACH</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a8c076d124c8a99250148584b5a4361b1">UDC_HAS_POWER</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a635fcfa65acc23589f664fbf58ed5ddb">UDC_IS_SUSPENDED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit definitions for <a class="el" href="structudc.html#a0efab065fbe68bae8ea948d19f6eccad" title="Bitmask of flags indicating the state of the device.">udc::flags</a>. </p>
 <a href="group__udc__group.html#ga8935b02daf1033b905c9bd51749e57b5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">UDC Library Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp530537dcf7f15a51059ec25d8a26422e"></a> The following functions make up the interface between the UDC driver and the optional UDC library. The UDC library contains common helper functions for UDC drivers. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaa51143b0198d850a3f0fc86766209a64">udc_set_address</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, unsigned int addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that the UDC is to change its USB address after the status IN phase is complete.  <a href="group__udc__group.html#gaa51143b0198d850a3f0fc86766209a64"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp61bcd96a2c1f8026527cbf2019d6e9a4"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae92092dc5b5aca35223380ca7cfb5e1b">udc_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the USB Device Controller.  <a href="group__udc__group.html#gae92092dc5b5aca35223380ca7cfb5e1b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Device State</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp05eddeb833f186c765df39f24486c1c8"></a> The following functions are used to query and modify the state of the USB device as a whole. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga030b358ddb593a2b3fd049a01c4bf183">udc_is_high_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at high speed.  <a href="group__udc__group.html#ga030b358ddb593a2b3fd049a01c4bf183"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad3ba2425b00092dc46851ad38dd9a946">udc_is_full_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at full speed.  <a href="group__udc__group.html#gad3ba2425b00092dc46851ad38dd9a946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad5d760d233fc5c8a4b53142fd00c5679">udc_is_low_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at low speed.  <a href="group__udc__group.html#gad5d760d233fc5c8a4b53142fd00c5679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f">usb_device_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad2c7c1a23643d609e99785bd209be5ee">udc_state</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Figure out which <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f" title="USB device state.">usb_device_state</a> the device is in.  <a href="group__udc__group.html#gad2c7c1a23643d609e99785bd209be5ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82">udc_attach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach <em>udc</em> to the bus when possible.  <a href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2fb2c7968f76bdf322f434682aa3343f">udc_detach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach <em>udc</em> from the bus.  <a href="group__udc__group.html#ga2fb2c7968f76bdf322f434682aa3343f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2079b64d60bb0a4d375fcfbbc32aa9e1"></a> The following functions allow drivers to create and destroy endpoints, as well as set, clear and query their "halted" and "wedged" states.</p>
<p>Wedging an endpoint is useful when encountering errors that need some sort of error recovery procedure to be performed by the host. A wedged endpoint behaves like one that is halted, except that the host is prevented from clearing the halted state through the standard ClearFeature(HALT) request. This behaviour is required by the USB Mass Storage Bulk-Only Transport specification. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198">udc_ep_create_bulk</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Bulk endpoint.  <a href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2f417ffb9582a4d689847f4962125689">udc_ep_create_interrupt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Interrupt endpoint.  <a href="group__udc__group.html#ga2f417ffb9582a4d689847f4962125689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e">udc_ep_destroy</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a previously created endpoint.  <a href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912">udc_ep_clear_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the halted state of the endpoint <em>ep</em>.  <a href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa">udc_ep_set_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the halted state of the endpoint <em>ep</em>.  <a href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721">udc_ep_is_halted</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the endpoint <em>ep</em> is halted.  <a href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c">udc_ep_clear_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the wedged state of an endpoint.  <a href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68">udc_ep_set_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the wedged state of an endpoint.  <a href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e4e9c43d67cbcc9d3c010d181186543">udc_ep_is_wedged</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a given endpoint is wedged.  <a href="group__udc__group.html#ga2e4e9c43d67cbcc9d3c010d181186543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1">udc_ep_flush</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate all pending requests on an endpoint.  <a href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Control Transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0849e296709b2991e77d00a9cf8c03da"></a> The following functions are used to send and receive packets over the default control endpoint, ep0. Most functions are asynchronous and will call a callback function after the transfer is done. The only exception is <a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb" title="Transmit IN data on the default control endpoint synchronously.">udc_ep0_write_sync()</a>, which will write the data to the FIFO immediately and busy-wait until it has been sent. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga9cdaef38977d71d9f07297c01e3f48ff">udc_ep0_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on the default control endpoint.  <a href="group__udc__group.html#ga9cdaef38977d71d9f07297c01e3f48ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad02048aa3cd26a0d5ffa8e06e312fb72">udc_ep0_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on the default control endpoint.  <a href="group__udc__group.html#gad02048aa3cd26a0d5ffa8e06e312fb72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb">udc_ep0_write_sync</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, const void *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit IN data on the default control endpoint synchronously.  <a href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4">udc_ep0_send_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a status IN packet on the default control endpoint.  <a href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c">udc_ep0_expect_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a status OUT packet is expected on the default control endpoint.  <a href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpff407869fe7ef829535c1645d170c29d"></a> The following functions are used to do non-control transfers, i.e. bulk, interrupt and isochronous transfers. Note that no synchronous functions are available -- the caller must always provide a callback if needed. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8">udc_ep_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on a non-control endpoint.  <a href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88">udc_ep_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on a non-control endpoint.  <a href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>USB Device Controller interface. </p>
<p>This file contains functions and data structures common to all USB Device Controller implementations.</p>
<p>Copyright (C) 2009 Atmel Corporation. All rights reserved. </p>

<p>Definition in file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:34 2010 for xplain-bc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
