<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xplain-bc: USB Device Controller (UDC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USB Device Controller (UDC)<br/>
<small>
[<a class="el" href="group__usb__device__group.html">USB Device Framework</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for USB Device Controller (UDC):</div>
<div class="dynsection">
<center><table><tr><td><img src="group__udc__group.png" border="0" alt="" usemap="#group____udc____group_map"/>
<map name="group____udc____group_map" id="group____udc____group">
<area shape="rect" href="group__usb__device__group.html" title="USB Device Framework" alt="" coords="5,5,165,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudc.html">udc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A USB Device Controller.  <a href="structudc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudc__fifo.html">udc_fifo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal state variables used by the FIFO accessors.  <a href="structudc__fifo.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#ga20c38cc5aac7cc6b0a3c6ab05428436d">int8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Endpoint identifier.  <a href="#gaece2b19e35a4a25398b7e8a9f81f9d28"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga8935b02daf1033b905c9bd51749e57b5">udc_flag</a> { <a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a01d87782d04a61d661fd166ecbbb8f0c">UDC_IS_ENABLED</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a75413d1b8163e224b9a964dab1d50db8">UDC_AUTOATTACH</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a8c076d124c8a99250148584b5a4361b1">UDC_HAS_POWER</a>, 
<a class="el" href="group__udc__group.html#gga8935b02daf1033b905c9bd51749e57b5a635fcfa65acc23589f664fbf58ed5ddb">UDC_IS_SUSPENDED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit definitions for <a class="el" href="structudc.html#a0efab065fbe68bae8ea948d19f6eccad" title="Bitmask of flags indicating the state of the device.">udc::flags</a>. </p>
 <a href="group__udc__group.html#ga8935b02daf1033b905c9bd51749e57b5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga8e122bb7854e62334210320d94dd4b19">udc_lib_standard_request</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__setup__req.html">usb_setup_req</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle a standard USB SETUP request.  <a href="#ga8e122bb7854e62334210320d94dd4b19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga0e274c65a81866c3d2be02acef2dc19b">at90usb_udc_of</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC instance from the UDC instance.  <a href="#ga0e274c65a81866c3d2be02acef2dc19b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae3a97246cb9f6a8c153c959e42bfec8a">at90usb_udc_task_of</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC instance from the work queue task.  <a href="#gae3a97246cb9f6a8c153c959e42bfec8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga9c4eb1b1c9dbf576bdba697d0d0a503c">at90usb_ep_task_of</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC endpoint instance from the work queue task.  <a href="#ga9c4eb1b1c9dbf576bdba697d0d0a503c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga05c55cf772b2bd23ef69d1c7f96a170f">at90usb_udc_req_done</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req, enum <a class="el" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a> status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to complete USB requests.  <a href="#ga05c55cf772b2bd23ef69d1c7f96a170f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga14ae76e5703f4a028eb74a3e27e6386a">at90usb_udc_kill_last_in_bank</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill last bank for an IN endpoint.  <a href="#ga14ae76e5703f4a028eb74a3e27e6386a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaaf024b83041fef2cc4583266208f6f8d">at90usb_udc_kill_first_out_bank</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill first bank for an OUT endpoint.  <a href="#gaaf024b83041fef2cc4583266208f6f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gab5725db2aa292947c86103384b020b20">at90usb_udc_kill_all_banks</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill all banks for an endpoint.  <a href="#gab5725db2aa292947c86103384b020b20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga676404d5ebf88ace9198087b7f3a7d96">at90usb_udc_submit_out_queue</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit queued buffers on a non-control OUT endpoint.  <a href="#ga676404d5ebf88ace9198087b7f3a7d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga8a24f9ab27b20edf91a615a8dc7d6827">at90usb_udc_submit_in_queue</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit queued buffers on a non-control IN endpoint.  <a href="#ga8a24f9ab27b20edf91a615a8dc7d6827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga5e7d0a463fdd3ed9746c9407a415e94f">at90usb_udc_configure_ep</a> (<a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> id, unsigned int size, enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a> type, bool is_in, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> nr_banks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6328c79258bd7e3d0a72d567085bb376">at90usb_udc_ep_flush</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a non-control endpoint.  <a href="#ga6328c79258bd7e3d0a72d567085bb376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga108f50ed23919eb40c99ed65ebd74bf1">at90usb_ep_alloc</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a non-control endpoint.  <a href="#ga108f50ed23919eb40c99ed65ebd74bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gac09a8f7ed37fc643349a130c6bea4493">at90usb_ep_enable</a> (struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size, enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a> type, unsigned int nr_banks)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a non-control endpoint.  <a href="#gac09a8f7ed37fc643349a130c6bea4493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3f15e69c9dc7e634c3b2590794001b23">at90usb_ep0_tx_complete</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to complete control endpoint USB requests.  <a href="#ga3f15e69c9dc7e634c3b2590794001b23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad7cba985928cb085720d9cbe04181d62">at90usb_ep0_tx_flush</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a control endpoint.  <a href="#gad7cba985928cb085720d9cbe04181d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga74a51950da640f02c4f2ea0165d10f77">at90usb_udc_ep0_worker</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AT90USB UDC endpoint 0 work task handler.  <a href="#ga74a51950da640f02c4f2ea0165d10f77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gab3ac20ad17c55adbf11ca7c9a9412e72">at90usb_udc_device_worker</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AT90USB device-mode device work task handler.  <a href="#gab3ac20ad17c55adbf11ca7c9a9412e72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga5b5f2f4dacfb05c9b2845f0e73d35179">at90usb_udc_maybe_attach</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to let the UDC maybe attach to the USB bus.  <a href="#ga5b5f2f4dacfb05c9b2845f0e73d35179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaeb111aec2d97920194a548f697ff346c">at90usb_udc_detach</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to let the UDC detach from the USB bus.  <a href="#gaeb111aec2d97920194a548f697ff346c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gabf8d919c60a8135a89d37e3036cfb459">at90usb_udc_vbus_on</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a high Vbus level has been detected.  <a href="#gabf8d919c60a8135a89d37e3036cfb459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga59d6920f3d1da0b8c3f5eeecac367589">at90usb_udc_vbus_off</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a low Vbus level has been detected.  <a href="#ga59d6920f3d1da0b8c3f5eeecac367589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3cff978366b61d760e6163154af4c8f6">at90usb_udc_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the device part of the AT90USB controller.  <a href="#ga3cff978366b61d760e6163154af4c8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga260d2f316b9a1bbc5e0f528a337f3015">at90usb_udc_shutdown</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the device part of the AT90USB controller.  <a href="#ga260d2f316b9a1bbc5e0f528a337f3015"></a><br/></td></tr>
<tr><td colspan="2"><h2>UDC Library Interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp530537dcf7f15a51059ec25d8a26422e"></a> The following functions make up the interface between the UDC driver and the optional UDC library. The UDC library contains common helper functions for UDC drivers. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga47e1324a894e87760dc7571aca5c5d97">udc_lib_process_setup_request</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__setup__req.html">usb_setup_req</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle a USB SETUP request.  <a href="#ga47e1324a894e87760dc7571aca5c5d97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga945f4e427b8ec40a3b8ef6f119abf2bb">udc_enter_test_mode</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, unsigned int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter Test Mode.  <a href="#ga945f4e427b8ec40a3b8ef6f119abf2bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaa51143b0198d850a3f0fc86766209a64">udc_set_address</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, unsigned int addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that the UDC is to change its USB address after the status IN phase is complete.  <a href="#gaa51143b0198d850a3f0fc86766209a64"></a><br/></td></tr>
<tr><td colspan="2"><h2>Control Transfer</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp0849e296709b2991e77d00a9cf8c03da"></a> The following functions are used to send and receive packets over the default control endpoint, ep0. Most functions are asynchronous and will call a callback function after the transfer is done. The only exception is <a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb" title="Transmit IN data on the default control endpoint synchronously.">udc_ep0_write_sync()</a>, which will write the data to the FIFO immediately and busy-wait until it has been sent. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga9cdaef38977d71d9f07297c01e3f48ff">udc_ep0_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on the default control endpoint.  <a href="#ga9cdaef38977d71d9f07297c01e3f48ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad02048aa3cd26a0d5ffa8e06e312fb72">udc_ep0_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on the default control endpoint.  <a href="#gad02048aa3cd26a0d5ffa8e06e312fb72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb">udc_ep0_write_sync</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, const void *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit IN data on the default control endpoint synchronously.  <a href="#ga2e051f7d27b72d0893fa0eeb7d8fefdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4">udc_ep0_send_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a status IN packet on the default control endpoint.  <a href="#ga6869b8335d3c81e1dc5d9980d7508ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c">udc_ep0_expect_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a status OUT packet is expected on the default control endpoint.  <a href="#gaf10c1032b3770d4168bca3279d99c53c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Data Transfer</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpff407869fe7ef829535c1645d170c29d"></a> The following functions are used to do non-control transfers, i.e. bulk, interrupt and isochronous transfers. Note that no synchronous functions are available -- the caller must always provide a callback if needed. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8">udc_ep_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on a non-control endpoint.  <a href="#ga51324a8221d7c149291c143e3fead2d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88">udc_ep_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on a non-control endpoint.  <a href="#gaa37da30bf7ebcdaed7af050c1e33dc88"></a><br/></td></tr>
<tr><td colspan="2"><h2>Endpoint Management</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp2079b64d60bb0a4d375fcfbbc32aa9e1"></a> The following functions allow drivers to create and destroy endpoints, as well as set, clear and query their "halted" and "wedged" states.</p>
<p>Wedging an endpoint is useful when encountering errors that need some sort of error recovery procedure to be performed by the host. A wedged endpoint behaves like one that is halted, except that the host is prevented from clearing the halted state through the standard ClearFeature(HALT) request. This behaviour is required by the USB Mass Storage Bulk-Only Transport specification. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721">udc_ep_is_halted</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the endpoint <em>ep</em> is halted.  <a href="#ga2ec9be7752ca333042d0ff899b9e5721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa">udc_ep_set_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the halted state of the endpoint <em>ep</em>.  <a href="#ga4510f29bac8db1085da69b5eddeca9fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912">udc_ep_clear_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the halted state of the endpoint <em>ep</em>.  <a href="#ga3f6290667c4af5e9533fb92ccc60f912"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e4e9c43d67cbcc9d3c010d181186543">udc_ep_is_wedged</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a given endpoint is wedged.  <a href="#ga2e4e9c43d67cbcc9d3c010d181186543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68">udc_ep_set_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the wedged state of an endpoint.  <a href="#ga183656813007f2e47da6dadde9933d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c">udc_ep_clear_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the wedged state of an endpoint.  <a href="#gacac13b6cbfe63354c49afec7edd5708c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1">udc_ep_flush</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate all pending requests on an endpoint.  <a href="#ga7540707886e611197bb211eb1054c5e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198">udc_ep_create_bulk</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Bulk endpoint.  <a href="#gae2348c0ec8c1ecac44e4e2df37316198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2f417ffb9582a4d689847f4962125689">udc_ep_create_interrupt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Interrupt endpoint.  <a href="#ga2f417ffb9582a4d689847f4962125689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e">udc_ep_destroy</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a previously created endpoint.  <a href="#ga6460566ec4134dff8b55a98c3055a00e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Device State</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp05eddeb833f186c765df39f24486c1c8"></a> The following functions are used to query and modify the state of the USB device as a whole. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82">udc_attach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach <em>udc</em> to the bus when possible.  <a href="#gaf04e5a797dcee2ea5f0d436d65bffb82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2fb2c7968f76bdf322f434682aa3343f">udc_detach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach <em>udc</em> from the bus.  <a href="#ga2fb2c7968f76bdf322f434682aa3343f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga030b358ddb593a2b3fd049a01c4bf183">udc_is_high_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at high speed.  <a href="#ga030b358ddb593a2b3fd049a01c4bf183"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad3ba2425b00092dc46851ad38dd9a946">udc_is_full_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at full speed.  <a href="#gad3ba2425b00092dc46851ad38dd9a946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad5d760d233fc5c8a4b53142fd00c5679">udc_is_low_speed</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the USB Device Controller is running at low speed.  <a href="#gad5d760d233fc5c8a4b53142fd00c5679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f">usb_device_state</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad2c7c1a23643d609e99785bd209be5ee">udc_state</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Figure out which <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f" title="USB device state.">usb_device_state</a> the device is in.  <a href="#gad2c7c1a23643d609e99785bd209be5ee"></a><br/></td></tr>
<tr><td colspan="2"><h2>Initialization</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp61bcd96a2c1f8026527cbf2019d6e9a4"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae92092dc5b5aca35223380ca7cfb5e1b">udc_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the USB Device Controller.  <a href="#gae92092dc5b5aca35223380ca7cfb5e1b"></a><br/></td></tr>
<tr><td colspan="2"><h2>FIFO Access Helpers</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb7c680cf83cda9f4fdb6b6477e54dfd9"></a> The following functions may be used by the UDC driver to copy data into and out of a FIFO aperture. It is assumed that the FIFO aperture has a fixed size equal to the max packet size of the endpoint, and that the bytes within it must be accessed sequentially from offset 0 up to the number of bytes available, i.e. no random access is possible. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gab91e80428caf302bcfacfbca28d336f4">udc_fifo_init</a> (struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *fifo, size_t aperture_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the internal state of the FIFO.  <a href="#gab91e80428caf302bcfacfbca28d336f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaef744d41d8db003ac56743f20612ebe3">udc_fifo_zlp_is_pending</a> (struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *fifo, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the UDC driver is to send a Zero-Length Packet once the controller is ready to send a new packet.  <a href="#gaef744d41d8db003ac56743f20612ebe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3b4139a11478b3e959096efd0c735947">udc_fifo_zlp_clear_pending</a> (struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *fifo, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the FIFO accessors that a ZLP has been queued, so it is not pending anymore.  <a href="#ga3b4139a11478b3e959096efd0c735947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gac300be830500073ae3cf0ff981de721f">udc_fifo_write_data</a> (void *dest, struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *fifo, struct <a class="el" href="structslist.html">slist</a> *done_list, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from one or more buffers into the FIFO.  <a href="#gac300be830500073ae3cf0ff981de721f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga5c876e3c1048711e448bbe1d4bfa12d6">udc_fifo_read_data</a> (const void *src, struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *fifo, unsigned int fifo_nbytes, struct <a class="el" href="structslist.html">slist</a> *done_bufs, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from the FIFO into one or more buffers.  <a href="#ga5c876e3c1048711e448bbe1d4bfa12d6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The UDC driver provides a low-level abstraction of the device controller hardware. Most events originate from the hardware in the form of interrupts, which may cause the UDC driver to call into the UDC library or the device core. These may in turn call back into the driver in order to send an appropriate response to the host. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaece2b19e35a4a25398b7e8a9f81f9d28"></a><!-- doxytag: member="udc.h::usb_ep_id_t" ref="gaece2b19e35a4a25398b7e8a9f81f9d28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#ga20c38cc5aac7cc6b0a3c6ab05428436d">int8_t</a> <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Endpoint identifier. </p>
<p>Used to identify endpoints on a USB device. </p>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00067">67</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga8935b02daf1033b905c9bd51749e57b5"></a><!-- doxytag: member="udc.h::udc_flag" ref="ga8935b02daf1033b905c9bd51749e57b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__udc__group.html#ga8935b02daf1033b905c9bd51749e57b5">udc_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit definitions for <a class="el" href="structudc.html#a0efab065fbe68bae8ea948d19f6eccad" title="Bitmask of flags indicating the state of the device.">udc::flags</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8935b02daf1033b905c9bd51749e57b5a01d87782d04a61d661fd166ecbbb8f0c"></a><!-- doxytag: member="UDC_IS_ENABLED" ref="gga8935b02daf1033b905c9bd51749e57b5a01d87782d04a61d661fd166ecbbb8f0c" args="" -->UDC_IS_ENABLED</em>&nbsp;</td><td>
<p>Device Controller enabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8935b02daf1033b905c9bd51749e57b5a75413d1b8163e224b9a964dab1d50db8"></a><!-- doxytag: member="UDC_AUTOATTACH" ref="gga8935b02daf1033b905c9bd51749e57b5a75413d1b8163e224b9a964dab1d50db8" args="" -->UDC_AUTOATTACH</em>&nbsp;</td><td>
<p>Attach when possible. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8935b02daf1033b905c9bd51749e57b5a8c076d124c8a99250148584b5a4361b1"></a><!-- doxytag: member="UDC_HAS_POWER" ref="gga8935b02daf1033b905c9bd51749e57b5a8c076d124c8a99250148584b5a4361b1" args="" -->UDC_HAS_POWER</em>&nbsp;</td><td>
<p>Vbus detected. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8935b02daf1033b905c9bd51749e57b5a635fcfa65acc23589f664fbf58ed5ddb"></a><!-- doxytag: member="UDC_IS_SUSPENDED" ref="gga8935b02daf1033b905c9bd51749e57b5a635fcfa65acc23589f664fbf58ed5ddb" args="" -->UDC_IS_SUSPENDED</em>&nbsp;</td><td>
<p>Bus is suspended. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00072">72</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3f15e69c9dc7e634c3b2590794001b23"></a><!-- doxytag: member="at90usb_udc.c::at90usb_ep0_tx_complete" ref="ga3f15e69c9dc7e634c3b2590794001b23" args="(struct udc *udc, struct at90usb_udc_ep *ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_ep0_tx_complete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to complete control endpoint USB requests. </p>
<p><b>For internal use only.</b></p>
<p>This helper function will set the USB request status flag and call the request done callback if needed for requests on the control endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The control endpoint instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01132">1132</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="at90usb__internal_8h_source.html#l00093">at90usb_udc_ep::buf_offset</a>, <a class="el" href="at90usb__internal_8h_source.html#l00099">at90usb_udc_ep::buf_queue</a>, <a class="el" href="at90usb__internal_8h_source.html#l00105">at90usb_udc_ep::bytes_written</a>, <a class="el" href="request_8h_source.html#l00110">usb_request::bytes_xfered</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="slist_8h_source.html#l00185">slist_give_back_head()</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="slist_8h_source.html#l00235">slist_peek_head</a>, and <a class="el" href="slist_8h_source.html#l00278">slist_pop_head_node()</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01182">at90usb_ep0_tx_flush()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="gad7cba985928cb085720d9cbe04181d62"></a><!-- doxytag: member="at90usb_udc.c::at90usb_ep0_tx_flush" ref="gad7cba985928cb085720d9cbe04181d62" args="(struct udc *udc, struct at90usb_udc_ep *ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_ep0_tx_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a control endpoint. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The control endpoint instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01182">1182</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__udc_8c_source.html#l01132">at90usb_ep0_tx_complete()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00093">at90usb_udc_ep::buf_offset</a>, <a class="el" href="at90usb__internal_8h_source.html#l00099">at90usb_udc_ep::buf_queue</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="status__codes_8h_source.html#l00059">ERR_PROTOCOL</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="request_8h_source.html#l00082">usb_request::node</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, and <a class="el" href="slist_8h_source.html#l00300">slist_pop_head</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01457">at90usb_udc_device_worker()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="ga108f50ed23919eb40c99ed65ebd74bf1"></a><!-- doxytag: member="at90usb_udc.c::at90usb_ep_alloc" ref="ga108f50ed23919eb40c99ed65ebd74bf1" args="(struct udc *udc, uint8_t addr, uint16_t max_packet_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a>* at90usb_ep_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_packet_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a non-control endpoint. </p>
<p><b>For internal use only.</b></p>
<p>Allocate and initialize the basics variables for a non-control endpoint instance. Also initialize the work queue handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Endpoint address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_packet_size</em>&nbsp;</td><td>Endpoint maximum packet size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Address of the allocated endpoint instance, NULL on error. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00974">974</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__internal_8h_source.html#l00075">AT90USB_EP_ALLOCATED</a>, <a class="el" href="at90usb__internal_8h_source.html#l00078">AT90USB_EP_IS_IN</a>, <a class="el" href="at90usb__udc_8c_source.html#l00128">at90usb_udc_of()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00366">at90usb_udc_submit_out_queue()</a>, <a class="el" href="arch_2avr8_2include_2arch_2bitops_8h_source.html#l00104">atomic_test_and_set_bit()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00123">at90usb_udc::ep</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00089">at90usb_udc_ep::id</a>, <a class="el" href="at90usb__internal_8h_source.html#l00103">at90usb_udc_ep::maxpacket</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="include_2bitops_8h_source.html#l00098">set_bit</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00095">at90usb_udc_ep::task</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00091">at90usb_udc_ep::udc90</a>, <a class="el" href="at90usb__internal_8h_source.html#l00087">at90usb_udc_ep::ueienx</a>, <a class="el" href="usb__protocol_8h_source.html#l00216">USB_DIR_IN</a>, <a class="el" href="usb__protocol_8h_source.html#l00212">USB_EP_ADDR_MASK</a>, and <a class="el" href="workqueue_8h_source.html#l00144">workqueue_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gac09a8f7ed37fc643349a130c6bea4493"></a><!-- doxytag: member="at90usb_udc.c::at90usb_ep_enable" ref="gac09a8f7ed37fc643349a130c6bea4493" args="(struct at90usb_udc_ep *ep, uint8_t addr, uint16_t max_packet_size, enum usb_ep_xfer_type type, unsigned int nr_banks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> at90usb_ep_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_packet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nr_banks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable a non-control endpoint. </p>
<p><b>For internal use only.</b></p>
<p>Configures and enables a non-control endpoint for transfers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>An AT90USB UDC endpoint instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Endpoint address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_packet_size</em>&nbsp;</td><td>Endpoint maximum packet size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Endpoint transfer type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nr_banks</em>&nbsp;</td><td>Number of endpoint banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An allocated endpoint instance, or NULL on error. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01023">1023</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__internal_8h_source.html#l00077">AT90USB_EP_ENABLED</a>, <a class="el" href="at90usb__udc_8c_source.html#l00821">at90usb_udc_configure_ep()</a>, <a class="el" href="compiler_8h_source.html#l00246">barrier</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="include_2bitops_8h_source.html#l00098">set_bit</a>, <a class="el" href="usb__protocol_8h_source.html#l00216">USB_DIR_IN</a>, and <a class="el" href="usb__protocol_8h_source.html#l00212">USB_EP_ADDR_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c4eb1b1c9dbf576bdba697d0d0a503c"></a><!-- doxytag: member="at90usb_udc.c::at90usb_ep_task_of" ref="ga9c4eb1b1c9dbf576bdba697d0d0a503c" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a>* at90usb_ep_task_of </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function get the AT90USB UDC endpoint instance from the work queue task. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>A work queue task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The AT90USB UDC endpoint instance. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00158">158</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00120">container_of</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l00366">at90usb_udc_submit_out_queue()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e7d0a463fdd3ed9746c9407a415e94f"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_configure_ep" ref="ga5e7d0a463fdd3ed9746c9407a415e94f" args="(uint8_t id, unsigned int size, enum usb_ep_xfer_type type, bool is_in, uint8_t nr_banks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> at90usb_udc_configure_ep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>nr_banks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>For internal use only.</b></p>
<p>Configure an endpoint at the hardware level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>Endpoint number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Maximum packet size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Endpoint transfer type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_in</em>&nbsp;</td><td>true if the endpoint is an IN endpoint. Must be false for control endpoints. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nr_banks</em>&nbsp;</td><td>Number of FIFO banks (1 or 2).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STATUS_OK</em>&nbsp;</td><td>The endpoint was configured successfully </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ERR_INVALID_ARG</em>&nbsp;</td><td>The endpoint configuration is invalid </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Only endpoint 1 can be 256 bytes, max 64 for the rest. </dd></dl>
</p>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00821">821</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__regs_8h_source.html#l00188">AT90USB_UECFG0X_EPTYPE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00197">AT90USB_UECFG1X_ALLOC</a>, <a class="el" href="at90usb__regs_8h_source.html#l00198">AT90USB_UECFG1X_EPBK</a>, <a class="el" href="at90usb__regs_8h_source.html#l00205">AT90USB_UECFG1X_EPSIZE_128</a>, <a class="el" href="at90usb__regs_8h_source.html#l00202">AT90USB_UECFG1X_EPSIZE_16</a>, <a class="el" href="at90usb__regs_8h_source.html#l00206">AT90USB_UECFG1X_EPSIZE_256</a>, <a class="el" href="at90usb__regs_8h_source.html#l00203">AT90USB_UECFG1X_EPSIZE_32</a>, <a class="el" href="at90usb__regs_8h_source.html#l00204">AT90USB_UECFG1X_EPSIZE_64</a>, <a class="el" href="at90usb__regs_8h_source.html#l00201">AT90USB_UECFG1X_EPSIZE_8</a>, <a class="el" href="at90usb__regs_8h_source.html#l00177">AT90USB_UECONX_EPEN</a>, <a class="el" href="at90usb__regs_8h_source.html#l00172">AT90USB_UERST_EPRST</a>, <a class="el" href="at90usb__regs_8h_source.html#l00216">AT90USB_UESTA0X_CFGOK</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00069">cpu_irq_restore()</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00055">cpu_irq_save()</a>, <a class="el" href="debug_8h_source.html#l00226">dbg_error</a>, <a class="el" href="status__codes_8h_source.html#l00062">ERR_INVALID_ARG</a>, and <a class="el" href="status__codes_8h_source.html#l00054">STATUS_OK</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01023">at90usb_ep_enable()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l01457">at90usb_udc_device_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb111aec2d97920194a548f697ff346c"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_detach" ref="gaeb111aec2d97920194a548f697ff346c" args="(struct at90usb_udc *udc90)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_detach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to let the UDC detach from the USB bus. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01536">1536</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00104">udc::address</a>, <a class="el" href="at90usb__regs_8h_source.html#l00114">AT90USB_UDCON_DETACH</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="udc_8h_source.html#l00074">UDC_AUTOATTACH</a>, <a class="el" href="udc_8h_source.html#l00075">UDC_HAS_POWER</a>, <a class="el" href="udc_8h_source.html#l00073">UDC_IS_ENABLED</a>, <a class="el" href="group__usb__dev__core__group.html#gae1d65a263ed4a92e38f325176a0e3820">usb_dev_reset()</a>, and <a class="el" href="usb__protocol_8h_source.html#l00093">USB_SPEED_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01587">at90usb_udc_vbus_off()</a>.</p>

</div>
</div>
<a class="anchor" id="gab3ac20ad17c55adbf11ca7c9a9412e72"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_device_worker" ref="gab3ac20ad17c55adbf11ca7c9a9412e72" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_device_worker </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The AT90USB device-mode device work task handler. </p>
<p><b>For internal use only.</b></p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Called from workqueue, interrupts enabled. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01457">1457</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00104">udc::address</a>, <a class="el" href="at90usb__udc_8c_source.html#l01182">at90usb_ep0_tx_flush()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00821">at90usb_udc_configure_ep()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00143">at90usb_udc_task_of()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00133">AT90USB_UDIEN_EORSTE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00123">AT90USB_UDINT_EORSTI</a>, <a class="el" href="at90usb__regs_8h_source.html#l00243">AT90USB_UEIENX_RXSTPE</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00069">cpu_irq_restore()</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00055">cpu_irq_save()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00115">at90usb_udc::ctrl_state</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="at90usb__internal_8h_source.html#l00123">at90usb_udc::ep</a>, <a class="el" href="at90usb__internal_8h_source.html#l00063">EP0_STATE_SETUP</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="udc_8h_source.html#l00076">UDC_IS_SUSPENDED</a>, <a class="el" href="at90usb__internal_8h_source.html#l00087">at90usb_udc_ep::ueienx</a>, <a class="el" href="group__usb__dev__core__group.html#gae1d65a263ed4a92e38f325176a0e3820">usb_dev_reset()</a>, <a class="el" href="usb__protocol_8h_source.html#l00095">USB_SPEED_FULL</a>, <a class="el" href="usb__protocol_8h_source.html#l00094">USB_SPEED_LOW</a>, and <a class="el" href="usb__protocol_8h_source.html#l00093">USB_SPEED_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01634">at90usb_udc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga74a51950da640f02c4f2ea0165d10f77"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_ep0_worker" ref="ga74a51950da640f02c4f2ea0165d10f77" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_ep0_worker </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The AT90USB UDC endpoint 0 work task handler. </p>
<p><b>For internal use only.</b></p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will disable and enable interrupts while processing the queue, but will return with interrupt flag as when called.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Work queue task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Called from workqueue, interrupts enabled. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01211">1211</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="buffer_8h_source.html#l00065">buffer::addr</a>, <a class="el" href="udc_8h_source.html#l00104">udc::address</a>, <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__udc_8c_source.html#l01132">at90usb_ep0_tx_complete()</a>, <a class="el" href="at90usb__udc_8c_source.html#l01182">at90usb_ep0_tx_flush()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__udc_8c_source.html#l00158">at90usb_ep_task_of()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00143">AT90USB_UDADDR_ADDEN</a>, <a class="el" href="at90usb__regs_8h_source.html#l00142">AT90USB_UDADDR_UADD_MASK</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00242">AT90USB_UEIENX_RXOUTE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00240">AT90USB_UEIENX_TXINE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00229">AT90USB_UEINTX_RXOUTI</a>, <a class="el" href="at90usb__regs_8h_source.html#l00231">AT90USB_UEINTX_RXSTPI</a>, <a class="el" href="at90usb__regs_8h_source.html#l00227">AT90USB_UEINTX_TXINI</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="at90usb__internal_8h_source.html#l00093">at90usb_udc_ep::buf_offset</a>, <a class="el" href="at90usb__internal_8h_source.html#l00099">at90usb_udc_ep::buf_queue</a>, <a class="el" href="at90usb__internal_8h_source.html#l00105">at90usb_udc_ep::bytes_written</a>, <a class="el" href="request_8h_source.html#l00110">usb_request::bytes_xfered</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="at90usb__udc_8c_source.html#l00092">copy_from_fifo()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00107">copy_to_fifo()</a>, <a class="el" href="compiler-gcc_8h_source.html#l00041">cpu_irq_disable</a>, <a class="el" href="compiler-gcc_8h_source.html#l00042">cpu_irq_enable</a>, <a class="el" href="at90usb__internal_8h_source.html#l00115">at90usb_udc::ctrl_state</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="at90usb__internal_8h_source.html#l00064">EP0_STATE_DATA_IN</a>, <a class="el" href="at90usb__internal_8h_source.html#l00065">EP0_STATE_DATA_ZLP</a>, <a class="el" href="at90usb__internal_8h_source.html#l00063">EP0_STATE_SETUP</a>, <a class="el" href="at90usb__internal_8h_source.html#l00067">EP0_STATE_STATUS_IN</a>, <a class="el" href="request_8h_source.html#l00087">usb_request::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="slist_8h_source.html#l00069">slist::last</a>, <a class="el" href="include_2byteorder_8h_source.html#l00231">le16_to_cpu()</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="util_8h_source.html#l00144">min_u</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="dma__nommu_8h_source.html#l00061">dma_addr_t::phys</a>, <a class="el" href="dma__nommu_8h_source.html#l00062">dma_addr_t::ptr</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="at90usb__internal_8h_source.html#l00117">at90usb_udc::setup_req</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="slist_8h_source.html#l00097">slist_node_is_last()</a>, <a class="el" href="slist_8h_source.html#l00235">slist_peek_head</a>, <a class="el" href="slist_8h_source.html#l00271">slist_peek_next</a>, <a class="el" href="slist_8h_source.html#l00278">slist_pop_head_node()</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="at90usb__internal_8h_source.html#l00091">at90usb_udc_ep::udc90</a>, <a class="el" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa">udc_ep_set_halt()</a>, <a class="el" href="group__udc__group.html#ga47e1324a894e87760dc7571aca5c5d97">udc_lib_process_setup_request()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00087">at90usb_udc_ep::ueienx</a>, and <a class="el" href="request_8h_source.html#l00069">USB_REQ_SHORT_PKT</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01634">at90usb_udc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6328c79258bd7e3d0a72d567085bb376"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_ep_flush" ref="ga6328c79258bd7e3d0a72d567085bb376" args="(struct at90usb_udc *udc90, struct at90usb_udc_ep *ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_ep_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a non-control endpoint. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>An UDC endpoint instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00889">889</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__internal_8h_source.html#l00077">AT90USB_EP_ENABLED</a>, <a class="el" href="at90usb__udc_8c_source.html#l00223">at90usb_udc_kill_all_banks()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00069">cpu_irq_restore()</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00055">cpu_irq_save()</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="status__codes_8h_source.html#l00056">ERR_FLUSHED</a>, <a class="el" href="slist_8h_source.html#l00064">slist::first</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00089">at90usb_udc_ep::id</a>, <a class="el" href="slist_8h_source.html#l00069">slist::last</a>, <a class="el" href="slist_8h_source.html#l00053">slist_node::next</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="request_8h_source.html#l00082">usb_request::node</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="slist_8h_source.html#l00110">slist_node_is_valid()</a>, <a class="el" href="slist_8h_source.html#l00235">slist_peek_head</a>, <a class="el" href="slist_8h_source.html#l00271">slist_peek_next</a>, <a class="el" href="slist_8h_source.html#l00300">slist_pop_head</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, and <a class="el" href="at90usb__internal_8h_source.html#l00087">at90usb_udc_ep::ueienx</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cff978366b61d760e6163154af4c8f6"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_init" ref="ga3cff978366b61d760e6163154af4c8f6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a>* at90usb_udc_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the device part of the AT90USB controller. </p>
<p><b>For internal use only.</b></p>
<p>This function does any device-side initialization necessary when the AT90USB controller as a whole is being initialized. It does not enable any device-side functionality.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The AT90USB device controller (UDC) instance. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01634">1634</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__udc_8c_source.html#l01457">at90usb_udc_device_worker()</a>, <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00116">AT90USB_UDCON_LSM</a>, <a class="el" href="at90usb__internal_8h_source.html#l00099">at90usb_udc_ep::buf_queue</a>, <a class="el" href="at90usb__internal_8h_source.html#l00123">at90usb_udc::ep</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00089">at90usb_udc_ep::id</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, <a class="el" href="at90usb__internal_8h_source.html#l00095">at90usb_udc_ep::task</a>, <a class="el" href="at90usb__internal_8h_source.html#l00121">at90usb_udc::task</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="at90usb__internal_8h_source.html#l00091">at90usb_udc_ep::udc90</a>, and <a class="el" href="workqueue_8h_source.html#l00144">workqueue_task_init()</a>.</p>

<p>Referenced by <a class="el" href="at90usb__core_8c_source.html#l00336">at90usb_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5725db2aa292947c86103384b020b20"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_kill_all_banks" ref="gab5725db2aa292947c86103384b020b20" args="(struct udc *udc, usb_ep_id_t ep_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_kill_all_banks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kill all banks for an endpoint. </p>
<p><b>For internal use only.</b></p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>In interrupt handler and/or interrupts disabled and with the appropriate endpoint selected through the AVR_REG_UENUM UENUM register.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep_id</em>&nbsp;</td><td>Endpoint number. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00223">223</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__udc_8c_source.html#l00206">at90usb_udc_kill_first_out_bank()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00191">at90usb_udc_kill_last_in_bank()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00186">AT90USB_UECFG0X_EPDIR_IN</a>, and <a class="el" href="at90usb__regs_8h_source.html#l00212">AT90USB_UESTA0X_GET_NBUSYBK</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00889">at90usb_udc_ep_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf024b83041fef2cc4583266208f6f8d"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_kill_first_out_bank" ref="gaaf024b83041fef2cc4583266208f6f8d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_kill_first_out_bank </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kill first bank for an OUT endpoint. </p>
<p><b>For internal use only.</b></p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>In interrupt handler and/or interrupts disabled and with the appropriate endpoint selected through the AVR_REG_UENUM UENUM register. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00206">206</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__regs_8h_source.html#l00235">AT90USB_UEINTX_FIFOCON</a>, and <a class="el" href="at90usb__regs_8h_source.html#l00229">AT90USB_UEINTX_RXOUTI</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00223">at90usb_udc_kill_all_banks()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14ae76e5703f4a028eb74a3e27e6386a"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_kill_last_in_bank" ref="ga14ae76e5703f4a028eb74a3e27e6386a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_kill_last_in_bank </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kill last bank for an IN endpoint. </p>
<p><b>For internal use only.</b></p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>In interrupt handler and/or interrupts disabled and with the appropriate endpoint selected through the AVR_REG_UENUM UENUM register. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00191">191</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__regs_8h_source.html#l00230">AT90USB_UEINTX_KILLBK</a>, and <a class="el" href="compiler_8h_source.html#l00246">barrier</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00223">at90usb_udc_kill_all_banks()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b5f2f4dacfb05c9b2845f0e73d35179"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_maybe_attach" ref="ga5b5f2f4dacfb05c9b2845f0e73d35179" args="(struct at90usb_udc *udc90)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_maybe_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to let the UDC maybe attach to the USB bus. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01511">1511</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__internal_8h_source.html#l00135">at90usb_udc_is_enabled()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00114">AT90USB_UDCON_DETACH</a>, <a class="el" href="at90usb__regs_8h_source.html#l00133">AT90USB_UDIEN_EORSTE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00047">AT90USB_UHWCON_UVREGE</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="udc_8h_source.html#l00074">UDC_AUTOATTACH</a>, and <a class="el" href="udc_8h_source.html#l00075">UDC_HAS_POWER</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01567">at90usb_udc_vbus_on()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e274c65a81866c3d2be02acef2dc19b"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_of" ref="ga0e274c65a81866c3d2be02acef2dc19b" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a>* at90usb_udc_of </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function get the AT90USB UDC instance from the UDC instance. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>An UDC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The AT90USB UDC instance. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00128">128</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00120">container_of</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00974">at90usb_ep_alloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05c55cf772b2bd23ef69d1c7f96a170f"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_req_done" ref="ga05c55cf772b2bd23ef69d1c7f96a170f" args="(struct udc *udc, struct usb_request *req, enum status_code status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_req_done </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a>&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to complete USB requests. </p>
<p><b>For internal use only.</b></p>
<p>This helper function will set the USB request status flag and call the request done callback if needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The UDC instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>A completed USB request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Status code for the completed USB request. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00174">174</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="request_8h_source.html#l00093">usb_request::req_done</a>, and <a class="el" href="request_8h_source.html#l00103">usb_request::status</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01132">at90usb_ep0_tx_complete()</a>, <a class="el" href="at90usb__udc_8c_source.html#l01182">at90usb_ep0_tx_flush()</a>, <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00889">at90usb_udc_ep_flush()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l00366">at90usb_udc_submit_out_queue()</a>.</p>

</div>
</div>
<a class="anchor" id="ga260d2f316b9a1bbc5e0f528a337f3015"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_shutdown" ref="ga260d2f316b9a1bbc5e0f528a337f3015" args="(struct at90usb_udc *udc90)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at90usb_udc_shutdown </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shut down the device part of the AT90USB controller. </p>
<p><b>For internal use only.</b></p>
<p>This function does any device-side cleanups necessary when the AT90USB controller as a whole is being shut down.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01668">1668</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, and <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>.</p>

<p>Referenced by <a class="el" href="at90usb__core_8c_source.html#l00336">at90usb_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a24f9ab27b20edf91a615a8dc7d6827"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_submit_in_queue" ref="ga8a24f9ab27b20edf91a615a8dc7d6827" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_submit_in_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit queued buffers on a non-control IN endpoint. </p>
<p><b>For internal use only.</b></p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will disable and enable interrupts while processing the queue, but will return with interrupt flag as when called. It will process an entire USB request before calling the callback (if any) and exit, potentially doing a reentry shortly after to process any additional USB requests.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Work queue task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep-&gt;active == NULL </dd>
<dd>
Called from workqueue, interrupts enabled. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00496">496</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="buffer_8h_source.html#l00065">buffer::addr</a>, <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__internal_8h_source.html#l00077">AT90USB_EP_ENABLED</a>, <a class="el" href="at90usb__udc_8c_source.html#l00158">at90usb_ep_task_of()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00235">AT90USB_UEINTX_FIFOCON</a>, <a class="el" href="at90usb__regs_8h_source.html#l00227">AT90USB_UEINTX_TXINI</a>, <a class="el" href="compiler_8h_source.html#l00246">barrier</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="request_8h_source.html#l00110">usb_request::bytes_xfered</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="at90usb__udc_8c_source.html#l00107">copy_to_fifo()</a>, <a class="el" href="compiler-gcc_8h_source.html#l00041">cpu_irq_disable</a>, <a class="el" href="compiler-gcc_8h_source.html#l00042">cpu_irq_enable</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00089">at90usb_udc_ep::id</a>, <a class="el" href="slist_8h_source.html#l00069">slist::last</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="workqueue_8c_source.html#l00047">main_workqueue</a>, <a class="el" href="at90usb__internal_8h_source.html#l00103">at90usb_udc_ep::maxpacket</a>, <a class="el" href="util_8h_source.html#l00144">min_u</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="request_8h_source.html#l00082">usb_request::node</a>, <a class="el" href="dma__nommu_8h_source.html#l00061">dma_addr_t::phys</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="include_2bitops_8h_source.html#l00098">set_bit</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="slist_8h_source.html#l00110">slist_node_is_valid()</a>, <a class="el" href="slist_8h_source.html#l00235">slist_peek_head</a>, <a class="el" href="slist_8h_source.html#l00223">slist_peek_head_node()</a>, <a class="el" href="slist_8h_source.html#l00271">slist_peek_next</a>, <a class="el" href="slist_8h_source.html#l00300">slist_pop_head</a>, <a class="el" href="at90usb__internal_8h_source.html#l00095">at90usb_udc_ep::task</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="at90usb__internal_8h_source.html#l00091">at90usb_udc_ep::udc90</a>, and <a class="el" href="group__workqueue__group.html#gaba0573bf3d1a0201616ec03944ecfd41">workqueue_add_task()</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00974">at90usb_ep_alloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga676404d5ebf88ace9198087b7f3a7d96"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_submit_out_queue" ref="ga676404d5ebf88ace9198087b7f3a7d96" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void at90usb_udc_submit_out_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit queued buffers on a non-control OUT endpoint. </p>
<p><b>For internal use only.</b></p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will disable and enable interrupts while processing the queue, but will return with interrupt flag as when called. It will process an entire USB request before calling the callback (if any) and exit, potentially doing a reentry shortly after to process any additional USB requests.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Work queue task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep-&gt;active == NULL </dd>
<dd>
Called from workqueue, interrupts enabled. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00366">366</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="buffer_8h_source.html#l00065">buffer::addr</a>, <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="at90usb__internal_8h_source.html#l00076">AT90USB_EP_ACTIVE_XFER</a>, <a class="el" href="at90usb__internal_8h_source.html#l00077">AT90USB_EP_ENABLED</a>, <a class="el" href="at90usb__udc_8c_source.html#l00158">at90usb_ep_task_of()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00174">at90usb_udc_req_done()</a>, <a class="el" href="at90usb__regs_8h_source.html#l00242">AT90USB_UEIENX_RXOUTE</a>, <a class="el" href="at90usb__regs_8h_source.html#l00235">AT90USB_UEINTX_FIFOCON</a>, <a class="el" href="at90usb__regs_8h_source.html#l00229">AT90USB_UEINTX_RXOUTI</a>, <a class="el" href="compiler_8h_source.html#l00246">barrier</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="request_8h_source.html#l00110">usb_request::bytes_xfered</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="at90usb__udc_8c_source.html#l00092">copy_from_fifo()</a>, <a class="el" href="compiler-gcc_8h_source.html#l00041">cpu_irq_disable</a>, <a class="el" href="compiler-gcc_8h_source.html#l00042">cpu_irq_enable</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="at90usb__internal_8h_source.html#l00101">at90usb_udc_ep::flags</a>, <a class="el" href="at90usb__internal_8h_source.html#l00089">at90usb_udc_ep::id</a>, <a class="el" href="slist_8h_source.html#l00069">slist::last</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="util_8h_source.html#l00144">min_u</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="request_8h_source.html#l00082">usb_request::node</a>, <a class="el" href="dma__nommu_8h_source.html#l00061">dma_addr_t::phys</a>, <a class="el" href="at90usb__internal_8h_source.html#l00097">at90usb_udc_ep::req_queue</a>, <a class="el" href="include_2bitops_8h_source.html#l00098">set_bit</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="slist_8h_source.html#l00110">slist_node_is_valid()</a>, <a class="el" href="slist_8h_source.html#l00235">slist_peek_head</a>, <a class="el" href="slist_8h_source.html#l00223">slist_peek_head_node()</a>, <a class="el" href="slist_8h_source.html#l00271">slist_peek_next</a>, <a class="el" href="slist_8h_source.html#l00300">slist_pop_head</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, <a class="el" href="at90usb__internal_8h_source.html#l00091">at90usb_udc_ep::udc90</a>, and <a class="el" href="at90usb__internal_8h_source.html#l00087">at90usb_udc_ep::ueienx</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00974">at90usb_ep_alloc()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3a97246cb9f6a8c153c959e42bfec8a"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_task_of" ref="gae3a97246cb9f6a8c153c959e42bfec8a" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a>* at90usb_udc_task_of </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function get the AT90USB UDC instance from the work queue task. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>A work queue task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The AT90USB UDC instance. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00143">143</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00120">container_of</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01457">at90usb_udc_device_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="ga59d6920f3d1da0b8c3f5eeecac367589"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_vbus_off" ref="ga59d6920f3d1da0b8c3f5eeecac367589" args="(struct at90usb_udc *udc90)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at90usb_udc_vbus_off </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that a low Vbus level has been detected. </p>
<p><b>For internal use only.</b></p>
<p>This function is called by the AT90USB bus interface driver when Vbus power is no longer provided by the host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01587">1587</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__udc_8c_source.html#l01536">at90usb_udc_detach()</a>, <a class="el" href="include_2bitops_8h_source.html#l00112">clear_bit</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, and <a class="el" href="udc_8h_source.html#l00075">UDC_HAS_POWER</a>.</p>

<p>Referenced by <a class="el" href="at90usb__core_8c_source.html#l00139">at90usb_check_vbus()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf8d919c60a8135a89d37e3036cfb459"></a><!-- doxytag: member="at90usb_udc.c::at90usb_udc_vbus_on" ref="gabf8d919c60a8135a89d37e3036cfb459" args="(struct at90usb_udc *udc90)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at90usb_udc_vbus_on </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc90</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that a high Vbus level has been detected. </p>
<p><b>For internal use only.</b></p>
<p>This function is called by the AT90USB bus interface driver when Vbus power is provided by the host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc90</em>&nbsp;</td><td>The AT90USB UDC instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l01567">1567</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>References <a class="el" href="at90usb__udc_8c_source.html#l01511">at90usb_udc_maybe_attach()</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="include_2bitops_8h_source.html#l00098">set_bit</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>, and <a class="el" href="udc_8h_source.html#l00075">UDC_HAS_POWER</a>.</p>

<p>Referenced by <a class="el" href="at90usb__core_8c_source.html#l00139">at90usb_check_vbus()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf04e5a797dcee2ea5f0d436d65bffb82"></a><!-- doxytag: member="at90usb_udc.c::udc_attach" ref="gaf04e5a797dcee2ea5f0d436d65bffb82" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach <em>udc</em> to the bus when possible. </p>
<p>Call this function to signal that the application is ready for the UDC to attach to the bus. This will cause the UDC to attach whenever the following conditions are present:</p>
<ul>
<li>The ID pin indicates Device operation. When the driver operates in device-only mode, this condition is assumed to always be true.</li>
<li>An acceptable Vbus level from the host is detected. </li>
</ul>

<p>Referenced by <a class="el" href="main_8c_source.html#l00073">app_usb_mode_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2fb2c7968f76bdf322f434682aa3343f"></a><!-- doxytag: member="at90usb_udc.c::udc_detach" ref="ga2fb2c7968f76bdf322f434682aa3343f" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_detach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach <em>udc</em> from the bus. </p>
<p>Call this function to forcibly detach the UDC from the bus. The UDC will detach immediately and won't reattach until <a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82" title="Attach udc to the bus when possible.">udc_attach()</a> is called, subject to the conditions listed for that function. </p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00073">app_usb_mode_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="ga945f4e427b8ec40a3b8ef6f119abf2bb"></a><!-- doxytag: member="at90usb_udc.c::udc_enter_test_mode" ref="ga945f4e427b8ec40a3b8ef6f119abf2bb" args="(struct udc *udc, unsigned int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_enter_test_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter Test Mode. </p>
<p>This function is implemented by the UDC driver and called by the UDC library to request the device to enter test mode after the status IN stage is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The index of the test mode to be entered</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STATUS_OK</em>&nbsp;</td><td>The specified test mode will be entered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>The device does not support the specified test mode </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf10c1032b3770d4168bca3279d99c53c"></a><!-- doxytag: member="at90usb_udc.c::udc_ep0_expect_status" ref="gaf10c1032b3770d4168bca3279d99c53c" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep0_expect_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that a status OUT packet is expected on the default control endpoint. </p>
<p>This function marks the end of the data IN phase, and signals that a status OUT packet is expected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep0 is ready to transmit data (no other buffers are queued) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ep0 has entered the status OUT phase </dd></dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6869b8335d3c81e1dc5d9980d7508ca4"></a><!-- doxytag: member="at90usb_udc.c::udc_ep0_send_status" ref="ga6869b8335d3c81e1dc5d9980d7508ca4" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep0_send_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a status IN packet on the default control endpoint. </p>
<p>This function will send a zero-length status IN packet on ep0. It does not wait for completion, as a status packet marks the end of a control transaction so no further action by the higher layers is necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep0 is ready to transmit data (no other buffers are queued) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ep0 has entered the status IN phase </dd></dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gad02048aa3cd26a0d5ffa8e06e312fb72"></a><!-- doxytag: member="at90usb_udc.c::udc_ep0_submit_in_req" ref="gad02048aa3cd26a0d5ffa8e06e312fb72" args="(struct udc *udc, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep0_submit_in_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit an IN request on the default control endpoint. </p>
<p>This function queues a USB request for transmitting IN data on the default control endpoint (ep0).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Request containing IN data for transmission</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>No other requests are queued on ep0 </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ep0 has entered the data IN phase </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cdaef38977d71d9f07297c01e3f48ff"></a><!-- doxytag: member="at90usb_udc.c::udc_ep0_submit_out_req" ref="ga9cdaef38977d71d9f07297c01e3f48ff" args="(struct udc *udc, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep0_submit_out_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit an OUT request on the default control endpoint. </p>
<p>This function queues a USB request for receiving OUT data on the default control endpoint (ep0).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Request to use for receiving the OUT data</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>No other requests are queued on ep0 </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ep0 has entered the data OUT phase </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e051f7d27b72d0893fa0eeb7d8fefdb"></a><!-- doxytag: member="at90usb_udc.c::udc_ep0_write_sync" ref="ga2e051f7d27b72d0893fa0eeb7d8fefdb" args="(struct udc *udc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_ep0_write_sync </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmit IN data on the default control endpoint synchronously. </p>
<p>This function will submit IN data on the default control endpoint (ep0) and busy-wait until it has been sent.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function must only be used for small quantities of data when it is impractical to submit a buffer asynchronously.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to be transmitted on ep0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The number of bytes to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually transmitted. This may be less than the requested number of bytes. When sending 8 bytes or less, it is safe to assume that everything will be sent.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep0 is ready to transmit data (no other buffers are queued) </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ep0 is ready to transmit data </dd></dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f6290667c4af5e9533fb92ccc60f912"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_clear_halt" ref="ga3f6290667c4af5e9533fb92ccc60f912" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_ep_clear_halt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the halted state of the endpoint <em>ep</em>. </p>
<p>After this function is called, any transaction on <em>ep</em> will be handled normally, i.e. a STALL hanshake will not be sent, and the data toggle sequence will start at DATA0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to be un-halted</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STATUS_OK</em>&nbsp;</td><td>The endpoint was successfully halted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>The endpoint could not be halted </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gacac13b6cbfe63354c49afec7edd5708c"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_clear_wedge" ref="gacac13b6cbfe63354c49afec7edd5708c" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_clear_wedge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the wedged state of an endpoint. </p>
<p>After this function is called, the endpoint halt condition may be cleared by calling <a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912" title="Clear the halted state of the endpoint ep.">udc_ep_clear_halt()</a>. In particular, the host is allowed to clear the halt condition using the ClearFeature(HALT) control request.</p>
<p>This function may be called even if the endpoint isn't wedged, but if it is wedged, it must be halted too.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to be un-wedged</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep &lt; APP_UDC_NR_ENDPOINTS </dd></dl>

</div>
</div>
<a class="anchor" id="gae2348c0ec8c1ecac44e4e2df37316198"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_create_bulk" ref="gae2348c0ec8c1ecac44e4e2df37316198" args="(struct udc *udc, uint8_t addr, uint16_t max_packet_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> udc_ep_create_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_packet_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Bulk endpoint. </p>
<p>Create a new endpoint with bulk transfer type. If bit 7 of <em>addr</em> is set, the endpoint is configured as a bulk-IN endpoint; otherwise, it's configured as a bulk-OUT endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>USB endpoint address, including direction. Bits 6..4 are reserved and must be set to 0. Same as the bEndpointAddress field of the endpoint descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_packet_size</em>&nbsp;</td><td>The maximum packet size to allow on this endpoint. Same as the wMaxPacket field in the endpoint descriptor converted to native endian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A cookie identifying the new endpoint, or a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f417ffb9582a4d689847f4962125689"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_create_interrupt" ref="ga2f417ffb9582a4d689847f4962125689" args="(struct udc *udc, uint8_t addr, uint16_t max_packet_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> udc_ep_create_interrupt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_packet_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new Interrupt endpoint. </p>
<p>Create a new endpoint with interrupt transfer type. If bit 7 of <em>addr</em> is set, the endpoint is configured as an interrupt-IN endpoint; otherwise, it's configured as an interrupt-OUT endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>USB endpoint address, including direction. Bits 6..4 are reserved and must be set to 0. Same as the bEndpointAddress field of the endpoint descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_packet_size</em>&nbsp;</td><td>The maximum packet size to allow on this endpoint. Same as the wMaxPacket field in the endpoint descriptor converted to native endian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A cookie identifying the new endpoint, or a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga6460566ec4134dff8b55a98c3055a00e"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_destroy" ref="ga6460566ec4134dff8b55a98c3055a00e" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a previously created endpoint. </p>
<p>This function will disable the specified endpoint, terminating all queued buffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>USB Endpoint ID previously returned by udc_ep_create() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7540707886e611197bb211eb1054c5e1"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_flush" ref="ga7540707886e611197bb211eb1054c5e1" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminate all pending requests on an endpoint. </p>
<p>This function will flush an endpoint, terminating all queued requests with an error status. After this function returns, the endpoint request queue will be empty. The data toggle sequence and the halted and wedged states of the endpoints will not be affected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>USB Endpoint ID previously returned by udc_ep_create(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ec9be7752ca333042d0ff899b9e5721"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_is_halted" ref="ga2ec9be7752ca333042d0ff899b9e5721" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_ep_is_halted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the endpoint <em>ep</em> is halted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td><em>ep</em> is halted, i.e. the controller will respond with a STALL handshake to any transaction other than SETUP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td><em>ep</em> is not halted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>The halted state could not be determined (i.e. <em>ep</em> does not identify a valid endpoint.) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e4e9c43d67cbcc9d3c010d181186543"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_is_wedged" ref="ga2e4e9c43d67cbcc9d3c010d181186543" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udc_ep_is_wedged </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a given endpoint is wedged. </p>
<p>A wedged endpoint is a halted endpoint where <a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912" title="Clear the halted state of the endpoint ep.">udc_ep_clear_halt()</a> requests are ignored. To un-halt an wedged endpoint, first call <a class="el" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c" title="Clear the wedged state of an endpoint.">udc_ep_clear_wedge()</a>, then call <a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912" title="Clear the halted state of the endpoint ep.">udc_ep_clear_halt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to check</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td><em>ep</em> is wedged </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td><em>ep</em> is not wedged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep &lt; APP_UDC_NR_ENDPOINTS </dd></dl>

</div>
</div>
<a class="anchor" id="ga4510f29bac8db1085da69b5eddeca9fa"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_set_halt" ref="ga4510f29bac8db1085da69b5eddeca9fa" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_ep_set_halt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the halted state of the endpoint <em>ep</em>. </p>
<p>After this function is called, any transaction on <em>ep</em> will result in a STALL hanshake being sent. Any pending transactions will be performed first, however.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to be halted</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STATUS_OK</em>&nbsp;</td><td>The endpoint was successfully halted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>The endpoint could not be halted </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, and <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="ga183656813007f2e47da6dadde9933d68"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_set_wedge" ref="ga183656813007f2e47da6dadde9933d68" args="(struct udc *udc, usb_ep_id_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_set_wedge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the wedged state of an endpoint. </p>
<p>After this function is called, any transaction on <em>ep</em> will result in a STALL hanshake being sent, and all requests to clear the halt condition will be ignored. Any pending transactions will be performed first, however.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The ID of the endpoint to be wedged</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ep &lt; APP_UDC_NR_ENDPOINTS </dd></dl>

</div>
</div>
<a class="anchor" id="gaa37da30bf7ebcdaed7af050c1e33dc88"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_submit_in_req" ref="gaa37da30bf7ebcdaed7af050c1e33dc88" args="(struct udc *udc, usb_ep_id_t ep, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_submit_in_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit an IN request on a non-control endpoint. </p>
<p>This function queues a USB request for transmitting IN data on a non-control endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The endpoint ID on which to queue the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Request containing IN data for transmission</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Interrupts not masked </dd>
<dd>
ep &gt; 0 &amp;&amp; ep &lt; APP_UDC_NR_ENDPOINTS </dd></dl>

</div>
</div>
<a class="anchor" id="ga51324a8221d7c149291c143e3fead2d8"></a><!-- doxytag: member="at90usb_udc.c::udc_ep_submit_out_req" ref="ga51324a8221d7c149291c143e3fead2d8" args="(struct udc *udc, usb_ep_id_t ep, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_ep_submit_out_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit an OUT request on a non-control endpoint. </p>
<p>This function queues a USB request for receiving OUT data on a non-control endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ep</em>&nbsp;</td><td>The endpoint ID on which to queue the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Request containing OUT data for reception</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Interrupts not masked </dd>
<dd>
ep &gt; 0 &amp;&amp; ep &lt; APP_UDC_NR_ENDPOINTS </dd></dl>

<p>Referenced by <a class="el" href="msc__bulk_8c_source.html#l01366">msc_submit_write_data_req()</a>.</p>

</div>
</div>
<a class="anchor" id="gab91e80428caf302bcfacfbca28d336f4"></a><!-- doxytag: member="udc_lib.h::udc_fifo_init" ref="gab91e80428caf302bcfacfbca28d336f4" args="(struct udc_fifo *fifo, size_t aperture_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void udc_fifo_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *&nbsp;</td>
          <td class="paramname"> <em>fifo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>aperture_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the internal state of the FIFO. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fifo</em>&nbsp;</td><td>The FIFO to be initialized </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aperture_size</em>&nbsp;</td><td>The size of the FIFO aperture in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc__lib_8h_source.html#l00125">125</a> of file <a class="el" href="udc__lib_8h_source.html">udc_lib.h</a>.</p>

<p>References <a class="el" href="udc__lib_8h_source.html#l00108">udc_fifo::buf_offset</a>, <a class="el" href="udc__lib_8h_source.html#l00116">udc_fifo::send_zlp</a>, and <a class="el" href="udc__lib_8h_source.html#l00109">udc_fifo::size</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c876e3c1048711e448bbe1d4bfa12d6"></a><!-- doxytag: member="udc_lib.h::udc_fifo_read_data" ref="ga5c876e3c1048711e448bbe1d4bfa12d6" args="(const void *src, struct udc_fifo *fifo, unsigned int fifo_nbytes, struct slist *done_bufs, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int udc_fifo_read_data </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *&nbsp;</td>
          <td class="paramname"> <em>fifo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>fifo_nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structslist.html">slist</a> *&nbsp;</td>
          <td class="paramname"> <em>done_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy data from the FIFO into one or more buffers. </p>
<p>This function will consume one or more buffers from <em>req</em> and copy data from the FIFO into the memory areas they represent. If the buffer has room for more data than the FIFO can provide, the current offset will be recorded and the next call to this function will resume where it left off.</p>
<p>It is the caller's responsibility to ensure that the FIFO bank at <em>src</em> contains valid data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The virtual address of the FIFO aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fifo</em>&nbsp;</td><td>Internal state for use by the FIFO accessors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fifo_nbytes</em>&nbsp;</td><td>The number of valid bytes in the FIFO, as reported by the UDC hardware </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done_bufs</em>&nbsp;</td><td>Buffers which have been fully consumed are placed on this list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>The USB request from which to consume buffers</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read from the FIFO, or a negative error code on failure. </dd></dl>

<p>Definition at line <a class="el" href="udc__lib_8h_source.html#l00257">257</a> of file <a class="el" href="udc__lib_8h_source.html">udc_lib.h</a>.</p>

<p>References <a class="el" href="buffer_8h_source.html#l00065">buffer::addr</a>, <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="buffer_8h_source.html#l00157">buf_list_pop_head</a>, <a class="el" href="udc__lib_8h_source.html#l00108">udc_fifo::buf_offset</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="arch_2avr8_2include_2arch_2string_8h_source.html#l00043">memcpy()</a>, <a class="el" href="util_8h_source.html#l00144">min_u</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="dma__nommu_8h_source.html#l00062">dma_addr_t::ptr</a>, <a class="el" href="slist_8h_source.html#l00130">slist_insert_head()</a>, <a class="el" href="slist_8h_source.html#l00142">slist_insert_tail()</a>, and <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>.</p>

</div>
</div>
<a class="anchor" id="gac300be830500073ae3cf0ff981de721f"></a><!-- doxytag: member="udc_lib.h::udc_fifo_write_data" ref="gac300be830500073ae3cf0ff981de721f" args="(void *dest, struct udc_fifo *fifo, struct slist *done_list, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int udc_fifo_write_data </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *&nbsp;</td>
          <td class="paramname"> <em>fifo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structslist.html">slist</a> *&nbsp;</td>
          <td class="paramname"> <em>done_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy data from one or more buffers into the FIFO. </p>
<p>This function will consume one or more buffers from <em>req</em> and copy the data contained within them into the FIFO aperture at <em>dest</em>. If the buffer contains more data than can fit into the FIFO, the current offset will be recorded and the next call to this function will resume where it left off.</p>
<p>It is the caller's responsibility to ensure that the FIFO bank at <em>dest</em> is available and has room for a whole USB packet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The virtual address of the FIFO aperture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fifo</em>&nbsp;</td><td>Internal state for use by the FIFO accessors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done_list</em>&nbsp;</td><td>Buffers which have been fully consumed are placed on this list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>The USB request from which to consume buffers</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written to the FIFO, or a negative error code on failure. </dd></dl>

<p>Definition at line <a class="el" href="udc__lib_8h_source.html#l00183">183</a> of file <a class="el" href="udc__lib_8h_source.html">udc_lib.h</a>.</p>

<p>References <a class="el" href="buffer_8h_source.html#l00065">buffer::addr</a>, <a class="el" href="request_8h_source.html#l00080">usb_request::buf_list</a>, <a class="el" href="buffer_8h_source.html#l00157">buf_list_pop_head</a>, <a class="el" href="udc__lib_8h_source.html#l00108">udc_fifo::buf_offset</a>, <a class="el" href="debug_8h_source.html#l00244">dbg_verbose</a>, <a class="el" href="request_8h_source.html#l00087">usb_request::flags</a>, <a class="el" href="buffer_8h_source.html#l00067">buffer::len</a>, <a class="el" href="arch_2avr8_2include_2arch_2string_8h_source.html#l00043">memcpy()</a>, <a class="el" href="util_8h_source.html#l00144">min_u</a>, <a class="el" href="buffer_8h_source.html#l00069">buffer::node</a>, <a class="el" href="dma__nommu_8h_source.html#l00062">dma_addr_t::ptr</a>, <a class="el" href="udc__lib_8h_source.html#l00116">udc_fifo::send_zlp</a>, <a class="el" href="udc__lib_8h_source.html#l00109">udc_fifo::size</a>, <a class="el" href="slist_8h_source.html#l00130">slist_insert_head()</a>, <a class="el" href="slist_8h_source.html#l00142">slist_insert_tail()</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, and <a class="el" href="request_8h_source.html#l00069">USB_REQ_SHORT_PKT</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b4139a11478b3e959096efd0c735947"></a><!-- doxytag: member="udc_lib.h::udc_fifo_zlp_clear_pending" ref="ga3b4139a11478b3e959096efd0c735947" args="(struct udc_fifo *fifo, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void udc_fifo_zlp_clear_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *&nbsp;</td>
          <td class="paramname"> <em>fifo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify the FIFO accessors that a ZLP has been queued, so it is not pending anymore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fifo</em>&nbsp;</td><td>Internal state for use by the FIFO accessors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>The USB request currently at the head of the queue </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc__lib_8h_source.html#l00156">156</a> of file <a class="el" href="udc__lib_8h_source.html">udc_lib.h</a>.</p>

<p>References <a class="el" href="udc__lib_8h_source.html#l00116">udc_fifo::send_zlp</a>.</p>

</div>
</div>
<a class="anchor" id="gaef744d41d8db003ac56743f20612ebe3"></a><!-- doxytag: member="udc_lib.h::udc_fifo_zlp_is_pending" ref="gaef744d41d8db003ac56743f20612ebe3" args="(struct udc_fifo *fifo, struct usb_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool udc_fifo_zlp_is_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc__fifo.html">udc_fifo</a> *&nbsp;</td>
          <td class="paramname"> <em>fifo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__request.html">usb_request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the UDC driver is to send a Zero-Length Packet once the controller is ready to send a new packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fifo</em>&nbsp;</td><td>Internal state for use by the FIFO accessors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>The USB request currently at the head of the queue</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The UDC driver must send a ZLP after the currently pending packets have been sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The UDC driver must not send a ZLP at this point. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc__lib_8h_source.html#l00143">143</a> of file <a class="el" href="udc__lib_8h_source.html">udc_lib.h</a>.</p>

<p>References <a class="el" href="udc__lib_8h_source.html#l00116">udc_fifo::send_zlp</a>.</p>

</div>
</div>
<a class="anchor" id="gae92092dc5b5aca35223380ca7cfb5e1b"></a><!-- doxytag: member="udc.h::udc_init" ref="gae92092dc5b5aca35223380ca7cfb5e1b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structudc.html">udc</a>* udc_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the USB Device Controller. </p>
<p>This will initialize the USB Device Controller, making it ready to attach to the bus. The controller won't attach automatically until <a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82" title="Attach udc to the bus when possible.">udc_attach()</a> has been called as well.</p>
<p>If the UDC is part of a dual-role (OTG) controller, and dual-role configuration is enabled, this function will initialize the whole controller if it hasn't been initialized before.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A USB Device Controller object</dd></dl>
<p>This will initialize the USB Device Controller, making it ready to attach to the bus. The controller won't attach automatically until <a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82" title="Attach udc to the bus when possible.">udc_attach()</a> has been called as well.</p>
<p>If the UDC is part of a dual-role (OTG) controller, and dual-role configuration is enabled, this function will initialize the whole controller if it hasn't been initialized before.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The USB Device Controller object. </dd></dl>

<p>Definition at line <a class="el" href="at90usb__core_8c_source.html#l00426">426</a> of file <a class="el" href="at90usb__core_8c_source.html">at90usb_core.c</a>.</p>

<p>References <a class="el" href="at90usb__core_8c_source.html#l00090">at90usb_get_udc()</a>, <a class="el" href="at90usb__core_8c_source.html#l00336">at90usb_init()</a>, and <a class="el" href="at90usb__internal_8h_source.html#l00113">at90usb_udc::udc</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00148">main()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3ba2425b00092dc46851ad38dd9a946"></a><!-- doxytag: member="udc.h::udc_is_full_speed" ref="gad3ba2425b00092dc46851ad38dd9a946" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool udc_is_full_speed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether the USB Device Controller is running at full speed. </p>
<p>If the UDC doesn't support full-speed operation, this function will always return false. This may be used by the compiler to eliminate full-speed only code when the UDC doesn't support it, e.g. when it is configured to run in low-speed mode only.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The UDC is running at full speed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The UDC is not running at full speed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00176">176</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, and <a class="el" href="usb__protocol_8h_source.html#l00095">USB_SPEED_FULL</a>.</p>

</div>
</div>
<a class="anchor" id="ga030b358ddb593a2b3fd049a01c4bf183"></a><!-- doxytag: member="udc.h::udc_is_high_speed" ref="ga030b358ddb593a2b3fd049a01c4bf183" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool udc_is_high_speed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether the USB Device Controller is running at high speed. </p>
<p>If the UDC doesn't support high-speed operation, this function will always return false. This may be used by the compiler to eliminate high-speed only code when the UDC doesn't support it.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The UDC is running at high speed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The UDC is not running at high speed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00155">155</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, and <a class="el" href="usb__protocol_8h_source.html#l00096">USB_SPEED_HIGH</a>.</p>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5d760d233fc5c8a4b53142fd00c5679"></a><!-- doxytag: member="udc.h::udc_is_low_speed" ref="gad5d760d233fc5c8a4b53142fd00c5679" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool udc_is_low_speed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether the USB Device Controller is running at low speed. </p>
<p>If the UDC doesn't support low-speed operation, this function will always return false. This may be used by the compiler to eliminate low-speed only code when the UDC doesn't support it. Note that low-speed mode is incompatible with all other modes, so this function will always return false for full- and/or high-speed capable devices.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The UDC is running at low speed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The UDC is not running at low speed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00198">198</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, and <a class="el" href="usb__protocol_8h_source.html#l00094">USB_SPEED_LOW</a>.</p>

</div>
</div>
<a class="anchor" id="ga47e1324a894e87760dc7571aca5c5d97"></a><!-- doxytag: member="udc_lib.c::udc_lib_process_setup_request" ref="ga47e1324a894e87760dc7571aca5c5d97" args="(struct udc *udc, struct usb_setup_req *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_lib_process_setup_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__setup__req.html">usb_setup_req</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle a USB SETUP request. </p>
<p>This function parses a USB SETUP request and submits an appropriate response back to the host or, in the case of SETUP OUT requests with data, sets up a buffer for receiving the data payload.</p>
<p>Standard requests defined by the USB 2.0 standard are handled internally, while class- and vendor-specific requests are passed on to a higher-level driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>USB Device Controller instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>The raw USB SETUP request.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151a7e4a42e3b6dd63708c64cf3db6f69566" title="Success.">STATUS_OK</a></em>&nbsp;</td><td>The request was handled successfully </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negative</em>&nbsp;</td><td>The request failed, so ep0 should be STALLed. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e122bb7854e62334210320d94dd4b19"></a><!-- doxytag: member="udc_lib.c::udc_lib_standard_request" ref="ga8e122bb7854e62334210320d94dd4b19" args="(struct udc *udc, struct usb_setup_req *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a> udc_lib_standard_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structusb__setup__req.html">usb_setup_req</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle a standard USB SETUP request. </p>
<p><b>For internal use only.</b></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Need a way for the application and/or drivers to switch between self-powered and bus-powered mode.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Implement remote wakeup support </dd></dl>

<p>Definition at line <a class="el" href="udc__lib_8c_source.html#l00062">62</a> of file <a class="el" href="udc__lib_8c_source.html">udc_lib.c</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00104">udc::address</a>, <a class="el" href="assert_8h_source.html#l00118">build_assert</a>, <a class="el" href="udc_8h_source.html#l00095">udc::config</a>, <a class="el" href="include_2byteorder_8h_source.html#l00239">cpu_to_le16()</a>, <a class="el" href="include_2byteorder_8h_source.html#l00222">LE16</a>, <a class="el" href="include_2byteorder_8h_source.html#l00231">le16_to_cpu()</a>, <a class="el" href="request_8h_source.html#l00103">usb_request::status</a>, <a class="el" href="group__udc__group.html#ga945f4e427b8ec40a3b8ef6f119abf2bb">udc_enter_test_mode()</a>, <a class="el" href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c">udc_ep0_expect_status()</a>, <a class="el" href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4">udc_ep0_send_status()</a>, <a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb">udc_ep0_write_sync()</a>, <a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912">udc_ep_clear_halt()</a>, <a class="el" href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721">udc_ep_is_halted()</a>, <a class="el" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa">udc_ep_set_halt()</a>, <a class="el" href="udc_8h_source.html#l00155">udc_is_high_speed()</a>, <a class="el" href="group__udc__group.html#gaa51143b0198d850a3f0fc86766209a64">udc_set_address()</a>, <a class="el" href="usb__protocol_8h_source.html#l00156">USB_DEV_FEATURE_REMOTE_WAKEUP</a>, <a class="el" href="usb__protocol_8h_source.html#l00157">USB_DEV_FEATURE_TEST_MODE</a>, <a class="el" href="group__usb__dev__core__group.html#ga87e8b45006847b28ba394d1daeb5331b">usb_dev_get_descriptor()</a>, <a class="el" href="group__usb__dev__core__group.html#ga6cbee0c91abaa976b89f3fdb9861fb52">usb_dev_get_interface()</a>, <a class="el" href="group__usb__dev__core__group.html#ga4a51a8d1b52b0c474bd108f53f34986c">usb_dev_set_configuration()</a>, <a class="el" href="group__usb__dev__core__group.html#gac860eb3e674caa8c38bfed5b26a629db">usb_dev_set_interface()</a>, <a class="el" href="usb__protocol_8h_source.html#l00155">USB_DEV_STATUS_SELF_POWERED</a>, <a class="el" href="usb__protocol_8h_source.html#l00212">USB_EP_ADDR_MASK</a>, <a class="el" href="usb__protocol_8h_source.html#l00250">usb_setup_is_in</a>, <a class="el" href="usb__protocol_8h_source.html#l00252">usb_setup_is_out</a>, and <a class="el" href="usb__protocol_8h_source.html#l00256">usb_setup_recipient</a>.</p>

</div>
</div>
<a class="anchor" id="gaa51143b0198d850a3f0fc86766209a64"></a><!-- doxytag: member="udc.h::udc_set_address" ref="gaa51143b0198d850a3f0fc86766209a64" args="(struct udc *udc, unsigned int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_set_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that the UDC is to change its USB address after the status IN phase is complete. </p>
<p>This function is implemented by the UDC driver and called by the UDC library when a Set Address request is received from the host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>udc</em>&nbsp;</td><td>The USB Device Controller instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The new USB address to be used starting from the next control transaction </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="udc__lib_8c_source.html#l00062">udc_lib_standard_request()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2c7c1a23643d609e99785bd209be5ee"></a><!-- doxytag: member="udc.h::udc_state" ref="gad2c7c1a23643d609e99785bd209be5ee" args="(struct udc *udc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f">usb_device_state</a> udc_state </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudc.html">udc</a> *&nbsp;</td>
          <td class="paramname"> <em>udc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Figure out which <a class="el" href="group__usb__protocol__group.html#ga7127ac2a46b577f2aa1bb9a650e62a3f" title="USB device state.">usb_device_state</a> the device is in. </p>
<p>This function is probably overly expensive for most purposes, but might useful for debugging. It's also useful for documentation purposes. </p>

<p>Definition at line <a class="el" href="udc_8h_source.html#l00214">214</a> of file <a class="el" href="udc_8h_source.html">udc.h</a>.</p>

<p>References <a class="el" href="udc_8h_source.html#l00104">udc::address</a>, <a class="el" href="udc_8h_source.html#l00095">udc::config</a>, <a class="el" href="udc_8h_source.html#l00097">udc::flags</a>, <a class="el" href="udc_8h_source.html#l00088">udc::speed</a>, <a class="el" href="include_2bitops_8h_source.html#l00167">test_bit</a>, <a class="el" href="udc_8h_source.html#l00075">UDC_HAS_POWER</a>, <a class="el" href="udc_8h_source.html#l00076">UDC_IS_SUSPENDED</a>, <a class="el" href="usb__protocol_8h_source.html#l00093">USB_SPEED_UNKNOWN</a>, <a class="el" href="usb__protocol_8h_source.html#l00073">USB_STATE_ADDRESS</a>, <a class="el" href="usb__protocol_8h_source.html#l00064">USB_STATE_ATTACHED</a>, <a class="el" href="usb__protocol_8h_source.html#l00075">USB_STATE_CONFIGURED</a>, <a class="el" href="usb__protocol_8h_source.html#l00068">USB_STATE_DEFAULT</a>, <a class="el" href="usb__protocol_8h_source.html#l00066">USB_STATE_POWERED</a>, and <a class="el" href="usb__protocol_8h_source.html#l00077">USB_STATE_SUSPENDED</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:35 2010 for xplain-bc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
