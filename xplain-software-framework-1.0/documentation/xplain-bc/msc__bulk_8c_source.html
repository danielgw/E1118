<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xplain-bc: drivers/usb/udi/msc_bulk.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>drivers/usb/udi/msc_bulk.c</h1><a href="msc__bulk_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="assert_8h.html" title="Run-time and build-time assertion support.">assert.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="arch_2avr8_2include_2arch_2atomic_8h.html" title="Atomic Operations: AVR implementation.">atomic.h</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="arch_2avr8_2include_2arch_2byteorder_8h.html" title="AVR-specific byte order definitions.">byteorder.h</a>&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="cpu_2mega_2include_2cpu_2dmapool_8h.html" title="DMA memory pool allocator: AVR Mega-specifics.">dmapool.h</a>&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;<a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html" title="AVR-specific interrupt masking/unmasking.">interrupt.h</a>&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;<a class="code" href="cpu_2mega_2include_2cpu_2physmem_8h.html" title="AVR Mega-specific physical memory definitions.">physmem.h</a>&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="status__codes_8h.html" title="Status code definitions.">status_codes.h</a>&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;<a class="code" href="arch_2avr8_2include_2arch_2string_8h.html" title="Standard string operations for AVR.">string.h</a>&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;<a class="code" href="types_8h.html" title="Type definitions used throughout the library.">types.h</a>&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;<a class="code" href="util_8h.html" title="Misc utility functions and definitions.">util.h</a>&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;<a class="code" href="device_8h.html" title="Block Device interface.">block/device.h</a>&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;<a class="code" href="cdb_8h.html" title="SCSI Command Descriptor Block (CDB) helper functions.">scsi/cdb.h</a>&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;<a class="code" href="spc__protocol_8h.html" title="SCSI Primary Commands.">scsi/spc_protocol.h</a>&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;<a class="code" href="sbc__protocol_8h.html" title="SCSI Block Commands.">scsi/sbc_protocol.h</a>&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;<a class="code" href="dev__mux_8h.html" title="USB device multiplexing layer.">usb/dev_mux.h</a>&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;<a class="code" href="udi__msc__bulk_8h.html" title="USB Mass Storage Class Bulk-only device interface driver.">usb/udi_msc_bulk.h</a>&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;<a class="code" href="msc__protocol_8h.html" title="USB Mass Storage Class (MSC) protocol definitions.">usb/msc_protocol.h</a>&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;<a class="code" href="request_8h.html" title="USB request structure and associated helper functions.">usb/request.h</a>&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;<a class="code" href="usb__protocol_8h.html" title="USB protocol definitions.">usb/usb_protocol.h</a>&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;<a class="code" href="udc_8h.html" title="USB Device Controller interface.">usb/udc.h</a>&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;<a class="code" href="usb_8h.html" title="Application-specific USB configuration.">app/usb.h</a>&gt;</span>
<a name="l00059"></a>00059 
<a name="l00065"></a>00065 <span class="preprocessor">#ifndef APP_UDI_MSC_FS_BULK_EP_SIZE</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor"># define APP_UDI_MSC_FS_BULK_EP_SIZE    64</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#define MSC_DATA_BUFFER_SIZE    CONFIG_DMAPOOL_LARGE_OBJ_SIZE</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define MSC_MAX_NR_BUFFERS      (CONFIG_DMAPOOL_NR_LARGE_OBJS / 2)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define MSC_MAX_DATA_LEN        (MSC_MAX_NR_BUFFERS * MSC_DATA_BUFFER_SIZE)</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00073"></a>00073 <span class="comment">/* Convert endpoint indexes to endpoint addresses */</span>
<a name="l00074"></a>00074 <span class="preprocessor">#define MSC_BULK_IN_EP_ADDR             (APP_UDI_MSC_BULK_IN_EP | USB_DIR_IN)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define MSC_BULK_OUT_EP_ADDR            (APP_UDI_MSC_BULK_OUT_EP | USB_DIR_OUT)</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00078"></a><a class="code" href="group__udi__msc__bulk__group.html#ga80f661efc2249d2142ef1ef194a4df9d">00078</a> <span class="preprocessor">#define MSC_MAX_NR_SEGS (2)</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="comment">/* The serial number may be at most 28 characters */</span>
<a name="l00081"></a>00081 <span class="preprocessor">#define MSC_VPD_SERIAL_BUF_SIZE (MSC_MAX_SERIAL_LEN + SCSI_VPD_HEADER_SIZE)</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <span class="comment">/*</span>
<a name="l00084"></a>00084 <span class="comment"> * Size of the Device Identification VPD:</span>
<a name="l00085"></a>00085 <span class="comment"> *  - 4 bytes for the header</span>
<a name="l00086"></a>00086 <span class="comment"> *  - 4 bytes for the ID descriptor header</span>
<a name="l00087"></a>00087 <span class="comment"> *  - 8 bytes for the T10 vendor ID</span>
<a name="l00088"></a>00088 <span class="comment"> *  - 16 bytes for the product ID</span>
<a name="l00089"></a>00089 <span class="comment"> *  - MSC_MAX_SERIAL_LEN bytes for the serial number</span>
<a name="l00090"></a>00090 <span class="comment"> */</span>
<a name="l00091"></a>00091 <span class="preprocessor">#define MSC_VPD_ID_BUF_SIZE     (SCSI_VPD_HEADER_SIZE                   \</span>
<a name="l00092"></a>00092 <span class="preprocessor">                                        + SCSI_VPD_ID_HEADER_SIZE       \</span>
<a name="l00093"></a>00093 <span class="preprocessor">                                        + 8 + 16                        \</span>
<a name="l00094"></a>00094 <span class="preprocessor">                                        + MSC_MAX_SERIAL_LEN)</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="structmsc__interface.html">00100</a> <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> {
<a name="l00102"></a><a class="code" href="structmsc__interface.html#a841e5bab694085809bb325be050e0cde">00102</a>         <span class="keyword">struct </span><a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a>    <a class="code" href="structmsc__interface.html#a841e5bab694085809bb325be050e0cde" title="Interface object registered with the UDM layer.">iface</a>;
<a name="l00104"></a><a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d">00104</a>         <span class="keyword">struct </span><a class="code" href="structudc.html" title="A USB Device Controller.">udc</a>              *<a class="code" href="structudc.html" title="A USB Device Controller.">udc</a>;
<a name="l00106"></a><a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4">00106</a>         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l00108"></a><a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2">00108</a>         <a class="code" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28" title="Endpoint identifier.">usb_ep_id_t</a>             <a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>;
<a name="l00110"></a><a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b">00110</a>         <a class="code" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28" title="Endpoint identifier.">usb_ep_id_t</a>             <a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>;
<a name="l00112"></a><a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942">00112</a>         <a class="code" href="uniondma__addr__t.html" title="A physical/virtual address pair used for DMA.">dma_addr_t</a>              <a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942" title="Buffer holding the current sense information.">sense_data</a>;
<a name="l00114"></a><a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854">00114</a>         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                <a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>;
<a name="l00116"></a><a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42">00116</a>         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                <a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>;
<a name="l00118"></a><a class="code" href="structmsc__interface.html#ab3d26a544f418d4e918815a6a5553242">00118</a>         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                <a class="code" href="structmsc__interface.html#ab3d26a544f418d4e918815a6a5553242" title="The first Logical Block Address to be transfered.">first_lba</a>;
<a name="l00120"></a><a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b">00120</a>         <a class="code" href="structatomic__object.html" title="Implementation-specific structure holding an atomic object.">atomic_t</a>                <a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>;
<a name="l00122"></a><a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68">00122</a>         <a class="code" href="structatomic__object.html" title="Implementation-specific structure holding an atomic object.">atomic_t</a>                <a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>;
<a name="l00124"></a><a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273">00124</a>         <a class="code" href="uniondma__addr__t.html" title="A physical/virtual address pair used for DMA.">dma_addr_t</a>              <a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>;
<a name="l00126"></a><a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1">00126</a>         <a class="code" href="uniondma__addr__t.html" title="A physical/virtual address pair used for DMA.">dma_addr_t</a>              <a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>;
<a name="l00128"></a><a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c">00128</a>         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>;
<a name="l00130"></a><a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2">00130</a>         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l00132"></a><a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c">00132</a>         <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a>                <a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a>;
<a name="l00134"></a><a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75">00134</a>         void                    (*<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a>)(<span class="keywordtype">void</span> *);
<a name="l00136"></a><a class="code" href="structmsc__interface.html#acbcf8e493e2eadbf9f1b3f0085df9121">00136</a>         <span class="keywordtype">void</span>                    *<a class="code" href="structmsc__interface.html#acbcf8e493e2eadbf9f1b3f0085df9121" title="Arbitrary data to be passed to busy_cb().">busy_cb_data</a>;
<a name="l00138"></a><a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9">00138</a>         <span class="keywordtype">bool</span>                    <a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a>;
<a name="l00140"></a><a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576">00140</a>         <span class="keywordtype">bool</span>                    <a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>;
<a name="l00142"></a><a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29">00142</a>         <span class="keywordtype">bool</span>                    <a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a>;
<a name="l00143"></a>00143 };
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc_interface_of(
<a name="l00146"></a>00146                 <span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *<a class="code" href="structmsc__interface.html#a841e5bab694085809bb325be050e0cde" title="Interface object registered with the UDM layer.">iface</a>)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148         <span class="keywordflow">return</span> <a class="code" href="group__utility__group.html#gaf8c317a42292b61c93aae91e59118a46" title="Get the containing object.">container_of</a>(iface, <span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>, iface);
<a name="l00149"></a>00149 }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">union </span>msc_mode_param_header {
<a name="l00152"></a>00152         <span class="keyword">struct </span><a class="code" href="structscsi__mode__param__header6.html" title="SCSI Mode Parameter Header used by MODE SELECT(6) and MODE SENSE(6).">scsi_mode_param_header6</a>  h6;
<a name="l00153"></a>00153         <span class="keyword">struct </span><a class="code" href="structscsi__mode__param__header10.html" title="SCSI Mode Parameter Header used by MODE SELECT(10) and MODE SENSE(10).">scsi_mode_param_header10</a> h10;
<a name="l00154"></a>00154 };
<a name="l00155"></a>00155 <span class="preprocessor">#define MSC_MODE_PARAM_HDR_BUF_LEN                      \</span>
<a name="l00156"></a>00156 <span class="preprocessor">        (sizeof(union msc_mode_param_header)            \</span>
<a name="l00157"></a>00157 <span class="preprocessor">                + sizeof(struct sbc_slba_block_desc))</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00159"></a>00159 <a class="code" href="group__compiler__group.html#gae2c02ff865ca6538b4b1bddbf2a6876c" title="Set maximum alignment for subsequent struct and union definitions to alignment.">COMPILER_PACK_SET</a>(1);
<a name="l00160"></a>00160 <span class="keyword">struct </span>msc_iface_desc {
<a name="l00161"></a>00161         <span class="keyword">struct </span><a class="code" href="structusb__interface__descriptor.html" title="Standard USB interface descriptor.">usb_interface_descriptor</a> iface;
<a name="l00162"></a>00162         <span class="keyword">struct </span><a class="code" href="structusb__endpoint__descriptor.html" title="Standard USB endpoint descriptor.">usb_endpoint_descriptor</a>  ep[2];
<a name="l00163"></a>00163 };
<a name="l00164"></a>00164 <a class="code" href="group__compiler__group.html#ga38d28b622a4bc7b0f3fb2be2ef1e0086" title="Set default alignment for subsequent struct and union definitions.">COMPILER_PACK_RESET</a>();
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>msc_iface_desc msc_desc_template = {
<a name="l00167"></a>00167         .iface.bLength          = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structusb__interface__descriptor.html" title="Standard USB interface descriptor.">usb_interface_descriptor</a>),
<a name="l00168"></a>00168         .iface.bDescriptorType          = USB_DT_INTERFACE,
<a name="l00169"></a>00169         .iface.bInterfaceNumber         = APP_UDI_MSC_INTERFACE_ID,
<a name="l00170"></a>00170         .iface.bAlternateSetting        = 0,
<a name="l00171"></a>00171         .iface.bNumEndpoints            = 2,
<a name="l00172"></a>00172         .iface.bInterfaceClass          = <a class="code" href="group__usb__ids__group.html#ga764a005140e7f4fe32ef1b18e48d3ca8" title="USB Mass Storage Class.">USB_CLASS_MSC</a>,
<a name="l00173"></a>00173         <span class="comment">/* Use INQUIRY to determine command set */</span>
<a name="l00174"></a>00174         .iface.bInterfaceSubClass       = <a class="code" href="group__msc__protocol__group.html#gga50738c3feb0d58590e2c519de74fc710a34581eaa12f3a6cd9103494dfc28b414" title="Determined by INQUIRY.">USB_MSC_SUBCLASS_TRANSPARENT</a>,
<a name="l00175"></a>00175         <span class="comment">/* BBB is the only protocol recommended for new designs */</span>
<a name="l00176"></a>00176         .iface.bInterfaceProtocol       = <a class="code" href="group__msc__protocol__group.html#ggab8db1c2202894682acc4d0b060976ecaa01980da64983b318aa8bff0d4eec9b8e" title="Bulk-only.">USB_MSC_PROTOCOL_BULK</a>,
<a name="l00177"></a>00177         .ep[0].bLength          = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structusb__endpoint__descriptor.html" title="Standard USB endpoint descriptor.">usb_endpoint_descriptor</a>),
<a name="l00178"></a>00178         .ep[0].bDescriptorType          = USB_DT_ENDPOINT,
<a name="l00179"></a>00179         .ep[0].bEndpointAddress         = MSC_BULK_IN_EP_ADDR,
<a name="l00180"></a>00180         .ep[0].bmAttributes             = USB_EP_XFER_BULK,
<a name="l00181"></a>00181         .ep[0].wMaxPacketSize           = <a class="code" href="group__byte__order__group.html#ga54d648861a1120a3f8d6255e9cf54125" title="Create a 16-bit little endian constant.">LE16</a>(APP_UDI_MSC_FS_BULK_EP_SIZE),
<a name="l00182"></a>00182         .ep[1].bLength          = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structusb__endpoint__descriptor.html" title="Standard USB endpoint descriptor.">usb_endpoint_descriptor</a>),
<a name="l00183"></a>00183         .ep[1].bDescriptorType          = USB_DT_ENDPOINT,
<a name="l00184"></a>00184         .ep[1].bEndpointAddress         = MSC_BULK_OUT_EP_ADDR,
<a name="l00185"></a>00185         .ep[1].bmAttributes             = USB_EP_XFER_BULK,
<a name="l00186"></a>00186         .ep[1].wMaxPacketSize           = <a class="code" href="group__byte__order__group.html#ga54d648861a1120a3f8d6255e9cf54125" title="Create a 16-bit little endian constant.">LE16</a>(APP_UDI_MSC_FS_BULK_EP_SIZE),
<a name="l00187"></a>00187 };
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structscsi__inquiry__data.html" title="SCSI Standard Inquiry data structure.">scsi_inquiry_data</a> msc_inquiry_data = {
<a name="l00190"></a>00190         .<a class="code" href="structscsi__inquiry__data.html#abfaac9d9205e708cc8cc44712a56eabc" title="Periph Qual / Periph Dev Type.">pq_pdt</a>         = <a class="code" href="spc__protocol_8h.html#a38a553faa28c4d5ec48b887d431a6f4c" title="Peripheral connected.">SCSI_INQ_PQ_CONNECTED</a> | <a class="code" href="spc__protocol_8h.html#aedf94e7cc51e5c8922e9ed2bdd0b36d8" title="Direct Access (SBC).">SCSI_INQ_DT_DIR_ACCESS</a>,
<a name="l00191"></a>00191 <span class="preprocessor">#ifdef CONFIG_UDI_MSC_REMOVABLE</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>        .flags1         = <a class="code" href="spc__protocol_8h.html#adee970a14219c8dad7fb1b1feac59ba2" title="Removable Medium.">SCSI_INQ_RMB</a>,
<a name="l00193"></a>00193 <span class="preprocessor">#else</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>        .flags1         = 0,
<a name="l00195"></a>00195 <span class="preprocessor">#endif</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>        .version        = <a class="code" href="spc__protocol_8h.html#a0dbc1df3b92114f73b0e83d946fac6f8" title="SCSI Primary Commands - 3.">SCSI_INQ_VER_SPC3</a>,
<a name="l00197"></a>00197         .flags3         = <a class="code" href="spc__protocol_8h.html#acf5b24e67abd586436d05208b1f8b1fe" title="Hierarchial LUN addressing.">SCSI_INQ_HISUP</a> | <a class="code" href="spc__protocol_8h.html#a629e751dda74190c663b8ef9238feef2" title="SPC-2 / SPC-3 response format.">SCSI_INQ_RSP_SPC2</a>,
<a name="l00198"></a>00198         .addl_len       = <a class="code" href="spc__protocol_8h.html#a67a84721f0550fbd953a7b5993837245" title="Total length is tot.">SCSI_INQ_ADDL_LEN</a>(<span class="keyword">sizeof</span>(msc_inquiry_data)),
<a name="l00199"></a>00199         .vendor_id      = { APP_UDI_MSC_INQ_VENDOR_ID },
<a name="l00200"></a>00200         .product_id     = { APP_UDI_MSC_INQ_PRODUCT_ID },
<a name="l00201"></a>00201         .product_rev    = { APP_UDI_MSC_INQ_PRODUCT_VERSION },
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *msc_get_cbw(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206         <span class="keywordflow">return</span> msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a> *msc_get_csw(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211         <span class="keywordflow">return</span> msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_free_dma_buf_list(<span class="keyword">struct</span> <a class="code" href="structslist.html" title="A singly linked list.">slist</a> *buf_list)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         <span class="keywordflow">while</span> (!<a class="code" href="slist_8h.html#a48452668d83e04103d667c4ba8eb2899" title="Determine if list is empty.">slist_is_empty</a>(buf_list)) {
<a name="l00219"></a>00219                 buf = <a class="code" href="slist_8h.html#a731714a0d75bc68ff1ecea1e921f9e17" title="Return the first item in list and remove it.">slist_pop_head</a>(buf_list, <span class="keyword">struct</span> <a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>, <a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l00220"></a>00220                 buffer_dma_free(buf, MSC_DATA_BUFFER_SIZE);
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00229"></a><a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e">00229</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e" title="Current transfer is done; run any registered busy callback functions and clear it...">msc_queue_empty</a>(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a59a24f6c541d2c1b20d7c897ed7bdbca" title="Type used for holding the current interrupt state.">irqflags_t</a>      iflags;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         iflags = <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#ad0c5a270013dca8848f9902ec131c51f" title="Save the current interrupt state and disable interrupts.">cpu_irq_save</a>();
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: queue empty, not_ready=%d busy_cb=%p\n&quot;</span>,
<a name="l00236"></a>00236                         msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a>);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a> = <span class="keyword">false</span>;
<a name="l00239"></a>00239         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a> &amp;&amp; msc-&gt;<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a>) {
<a name="l00240"></a>00240                 void (*busy_cb)(<span class="keywordtype">void</span> *) = msc-&gt;<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a>;
<a name="l00241"></a>00241                 <span class="keywordtype">void</span> *busy_data = msc-&gt;<a class="code" href="structmsc__interface.html#acbcf8e493e2eadbf9f1b3f0085df9121" title="Arbitrary data to be passed to busy_cb().">busy_cb_data</a>;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243                 msc-&gt;<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a> = NULL;
<a name="l00244"></a>00244                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l00245"></a>00245                 busy_cb(busy_data);
<a name="l00246"></a>00246         } <span class="keywordflow">else</span> {
<a name="l00247"></a>00247                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l00248"></a>00248         }
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_init_sense(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> sense_key,
<a name="l00252"></a>00252                 <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a> add_sense, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> lba)
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>         *data = msc-&gt;<a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942" title="Buffer holding the current sense information.">sense_data</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <a class="code" href="group__string__group.html#ga313175102214d45434bf045db18dddf0" title="Initialize memory area.">memset</a>(data, 0, 18);
<a name="l00257"></a>00257         data[0] = SCSI_SENSE_VALID | SCSI_SENSE_CURRENT;
<a name="l00258"></a>00258         data[2] = sense_key;
<a name="l00259"></a>00259         data[3] = lba &gt;&gt; 24;
<a name="l00260"></a>00260         data[4] = lba &gt;&gt; 16;
<a name="l00261"></a>00261         data[5] = lba &gt;&gt; 8;
<a name="l00262"></a>00262         data[6] = lba;
<a name="l00263"></a>00263         data[7] = SCSI_SENSE_ADDL_LEN(18);
<a name="l00264"></a>00264         data[12] = add_sense &gt;&gt; 8;
<a name="l00265"></a>00265         data[13] = add_sense;
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> msc_sense_len(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270         <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>   *data = msc-&gt;<a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942" title="Buffer holding the current sense information.">sense_data</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00271"></a>00271         <span class="keywordflow">return</span> data[7] + 8;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_cbw_received(<span class="keyword">struct</span> <a class="code" href="structudc.html" title="A USB Device Controller.">udc</a> *<a class="code" href="structudc.html" title="A USB Device Controller.">udc</a>, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req);
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_csw_sent(<span class="keyword">struct</span> <a class="code" href="structudc.html" title="A USB Device Controller.">udc</a> *<a class="code" href="structudc.html" title="A USB Device Controller.">udc</a>, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_prepare_csw(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> residue,
<a name="l00278"></a>00278                 <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> status)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw;
<a name="l00281"></a>00281         <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw;
<a name="l00282"></a>00282         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l00283"></a>00283         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         csw = msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00286"></a>00286         cbw = msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00287"></a>00287         csw-&gt;<a class="code" href="structusb__msc__csw.html#aade7ffa14a98a710eaa9540e3110da42" title="Same as dCBWTag.">dCSWTag</a> = cbw-&gt;<a class="code" href="structusb__msc__cbw.html#a6b81ebfdbc8a26efa211b48ce1747496" title="Unique command ID.">dCBWTag</a>;
<a name="l00288"></a>00288         csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a> = <a class="code" href="group__byte__order__group.html#gab44bd5db41a2ff675115a29145513ac5" title="Convert a 32-bit word from native to little endian byte order.">cpu_to_le32</a>(residue);
<a name="l00289"></a>00289         csw-&gt;<a class="code" href="structusb__msc__csw.html#aa1c2d8d8b2b16b50e9d57e60fd19ca2f" title="Status code.">bCSWStatus</a> = status;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         req = msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>;
<a name="l00292"></a>00292         req-&gt;<a class="code" href="structusb__request.html#a2d97ed1ba0059d4649e663febbb2c095" title="The number of bytes actually transfered.">bytes_xfered</a> = 0;
<a name="l00293"></a>00293         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_csw_sent;
<a name="l00294"></a>00294         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00295"></a>00295         <a class="code" href="group__buffer__group.html#ga08e06f378926444e51a796c70ab9037b" title="Initialize a buffer for transmitting data.">buffer_init_tx</a>(buf, csw, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>));
<a name="l00296"></a>00296 
<a name="l00297"></a>00297         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: CSW t%08lx r%lu s%u\n&quot;</span>, <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#aade7ffa14a98a710eaa9540e3110da42" title="Same as dCBWTag.">dCSWTag</a>),
<a name="l00298"></a>00298                         residue, status);
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_request_data_done(<span class="keyword">struct</span> <a class="code" href="structudc.html" title="A USB Device Controller.">udc</a> *<a class="code" href="structudc.html" title="A USB Device Controller.">udc</a>, <span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         csw = msc_get_csw(msc);
<a name="l00306"></a>00306         <span class="keywordflow">if</span> (csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a> != <a class="code" href="group__byte__order__group.html#ga4f24e3d1dc0a8bf7ad7a60553d13daa7" title="Create a 32-bit little endian constant.">LE32</a>(0) &amp;&amp; msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>) {
<a name="l00307"></a>00307                 <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw = msc_get_cbw(msc);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309                 <span class="keywordflow">if</span> (cbw-&gt;<a class="code" href="structusb__msc__cbw.html#a8331a5d04e78012779cdf5a568af90b9" title="Direction in bit 7.">bmCBWFlags</a> &amp; <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>)
<a name="l00310"></a>00310                         <a class="code" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa" title="Set the halted state of the endpoint ep.">udc_ep_set_halt</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>);
<a name="l00311"></a>00311                 <span class="keywordflow">else</span>
<a name="l00312"></a>00312                         <a class="code" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa" title="Set the halted state of the endpoint ep.">udc_ep_set_halt</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>);
<a name="l00313"></a>00313                 <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc data done: t%08lx r%lu s%u %s\n&quot;</span>,
<a name="l00317"></a>00317                         <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#aade7ffa14a98a710eaa9540e3110da42" title="Same as dCBWTag.">dCSWTag</a>),
<a name="l00318"></a>00318                         <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a>),
<a name="l00319"></a>00319                         csw-&gt;<a class="code" href="structusb__msc__csw.html#aa1c2d8d8b2b16b50e9d57e60fd19ca2f" title="Status code.">bCSWStatus</a>,
<a name="l00320"></a>00320                         (msc_get_cbw(msc)-&gt;<a class="code" href="structusb__msc__cbw.html#a8331a5d04e78012779cdf5a568af90b9" title="Direction in bit 7.">bmCBWFlags</a> &amp; <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>)
<a name="l00321"></a>00321                         ? <span class="stringliteral">&quot;IN&quot;</span> : <span class="stringliteral">&quot;OUT&quot;</span>);
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_request_done(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00325"></a>00325                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> residue)
<a name="l00326"></a>00326 {
<a name="l00327"></a>00327         <span class="comment">/*</span>
<a name="l00328"></a>00328 <span class="comment">         * If we&#39;re transferring exactly the amount of data that the</span>
<a name="l00329"></a>00329 <span class="comment">         * host requested, queue the CSW immediately. Otherwise, we</span>
<a name="l00330"></a>00330 <span class="comment">         * need to stall after we&#39;ve sent all the data we have, and</span>
<a name="l00331"></a>00331 <span class="comment">         * send the CSW after that.</span>
<a name="l00332"></a>00332 <span class="comment">         */</span>
<a name="l00333"></a>00333         <span class="keywordflow">if</span> (!residue)
<a name="l00334"></a>00334                 <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc req done\n&quot;</span>);
<a name="l00337"></a>00337 }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_request_done_nodata(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00340"></a>00340                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> residue)
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342         <span class="keywordflow">if</span> (residue) {
<a name="l00343"></a>00343                 <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw = msc_get_cbw(msc);
<a name="l00344"></a>00344                 <span class="keywordflow">if</span> (cbw-&gt;<a class="code" href="structusb__msc__cbw.html#a8331a5d04e78012779cdf5a568af90b9" title="Direction in bit 7.">bmCBWFlags</a> &amp; <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>)
<a name="l00345"></a>00345                         <a class="code" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa" title="Set the halted state of the endpoint ep.">udc_ep_set_halt</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>);
<a name="l00346"></a>00346                 <span class="keywordflow">else</span>
<a name="l00347"></a>00347                         <a class="code" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa" title="Set the halted state of the endpoint ep.">udc_ep_set_halt</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>);
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>);
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_request_failed(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> residue,
<a name="l00354"></a>00354                 <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> csw_status, <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> sense_key, <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a> add_sense)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356         <a class="code" href="group__debug__console.html#ga1e39d164d3d05177c7793b1311f6d093" title="Display a warning message.">dbg_warning</a>(<span class="stringliteral">&quot;msc: req %02x failed: SK %02x ASC(Q) %04x\n&quot;</span>,
<a name="l00357"></a>00357                         scsi_cdb_get_opcode(msc_get_cbw(msc)-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l00358"></a>00358                         sense_key, add_sense);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         msc_init_sense(msc, sense_key, add_sense, 0);
<a name="l00361"></a>00361         msc_prepare_csw(msc, residue, csw_status);
<a name="l00362"></a>00362         msc_request_done_nodata(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc, residue);
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_phase_error(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00366"></a>00366 {
<a name="l00367"></a>00367         <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw = msc_get_cbw(msc);
<a name="l00368"></a>00368         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                cbw_xfer_len;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         cbw_xfer_len = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <a class="code" href="group__debug__console.html#ga5332230e4299334865900b442421e35b" title="Display a error message.">dbg_error</a>(<span class="stringliteral">&quot;msc: Phase Error (opcode %02x)\n&quot;</span>,
<a name="l00373"></a>00373                         scsi_cdb_get_opcode(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l00374"></a>00374         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc:   CBW bmCBWFlags = 0x%02x\n&quot;</span>, cbw-&gt;<a class="code" href="structusb__msc__cbw.html#a8331a5d04e78012779cdf5a568af90b9" title="Direction in bit 7.">bmCBWFlags</a>);
<a name="l00375"></a>00375         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc:   CBW dCBWDataTransferLength = 0x%lx\n&quot;</span>, cbw_xfer_len);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377         msc_prepare_csw(msc, cbw_xfer_len, <a class="code" href="group__msc__protocol__group.html#gabf724d46c05e230cc9bdfd8b7d945ec2" title="Phase Error.">USB_CSW_STATUS_PE</a>);
<a name="l00378"></a>00378         msc_request_done_nodata(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc, cbw_xfer_len);
<a name="l00379"></a>00379 }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_out_of_memory(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383         <a class="code" href="group__debug__console.html#ga5332230e4299334865900b442421e35b" title="Display a error message.">dbg_error</a>(<span class="stringliteral">&quot;msc: Out of memory!\n&quot;</span>);
<a name="l00384"></a>00384         msc_phase_error(msc);
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_csw_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l00390"></a>00390         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00393"></a>00393         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a> == msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>);
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: CSW sent, status=%d\n&quot;</span>, req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>);
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         <a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e" title="Current transfer is done; run any registered busy callback functions and clear it...">msc_queue_empty</a>(msc);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         <span class="comment">/* Don&#39;t submit any buffers when the endpoint is unavailable */</span>
<a name="l00400"></a>00400         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>)
<a name="l00401"></a>00401                 <span class="keywordflow">return</span>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="comment">/* Re-use the USB request and buffer for the CBW */</span>
<a name="l00404"></a>00404         <a class="code" href="group__buffer__group.html#ga48a5f5cf02679d5f06e8a709b0e1d987" title="Initialize an already-DMA-mapped buffer for receiving data.">buffer_init_rx_mapped</a>(buf, msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l00405"></a>00405         req-&gt;<a class="code" href="structusb__request.html#a2d97ed1ba0059d4649e663febbb2c095" title="The number of bytes actually transfered.">bytes_xfered</a> = 0;
<a name="l00406"></a>00406         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_cbw_received;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <a class="code" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8" title="Submit an OUT request on a non-control endpoint.">udc_ep_submit_out_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>, req);
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_data_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00412"></a>00412 {
<a name="l00413"></a>00413         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l00414"></a>00414         <span class="keyword">enum</span> <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a>        status = req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (!status)
<a name="l00419"></a>00419                 msc_request_data_done(udc, msc);
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_buf_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00427"></a>00427         <a class="code" href="group__buffer__group.html#ga892382a3cd2784fff8946f734d732de6" title="Free the buffer structure buf.">buffer_free</a>(buf);
<a name="l00428"></a>00428         msc_data_sent(udc, req);
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_capacity_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00436"></a>00436         buffer_dma_free(buf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structsbc__read__capacity10__data.html" title="SBC-2 READ CAPACITY (10) parameter data.">sbc_read_capacity10_data</a>));
<a name="l00437"></a>00437         msc_data_sent(udc, req);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_vpd_serial_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00441"></a>00441 {
<a name="l00442"></a>00442         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00445"></a>00445         buffer_dma_free(buf, MSC_VPD_SERIAL_BUF_SIZE);
<a name="l00446"></a>00446         msc_data_sent(udc, req);
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_vpd_id_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00450"></a>00450 {
<a name="l00451"></a>00451         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00454"></a>00454         buffer_dma_free(buf, MSC_VPD_ID_BUF_SIZE);
<a name="l00455"></a>00455         msc_data_sent(udc, req);
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_sense_data_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00459"></a>00459 {
<a name="l00460"></a>00460         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l00461"></a>00461         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00462"></a>00462         <span class="keyword">enum</span> <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a>        status = req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc sense data sent: %zu bytes, status %d\n&quot;</span>,
<a name="l00465"></a>00465                         req-&gt;<a class="code" href="structusb__request.html#a2d97ed1ba0059d4649e663febbb2c095" title="The number of bytes actually transfered.">bytes_xfered</a>, req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         msc_init_sense(msc, SCSI_SK_NO_SENSE,
<a name="l00468"></a>00468                         SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
<a name="l00469"></a>00469         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00470"></a>00470         <a class="code" href="group__buffer__group.html#ga892382a3cd2784fff8946f734d732de6" title="Free the buffer structure buf.">buffer_free</a>(buf);
<a name="l00471"></a>00471         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (!status)
<a name="l00474"></a>00474                 msc_request_data_done(udc, msc);
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_mode_params_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l00478"></a>00478 {
<a name="l00479"></a>00479         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l00482"></a>00482         buffer_dma_free(buf, MSC_MODE_PARAM_HDR_BUF_LEN);
<a name="l00483"></a>00483         msc_data_sent(udc, req);
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="keyword">static</span> <span class="keywordtype">long</span> msc_validate_req(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw,
<a name="l00487"></a>00487                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> alloc_len, <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> dir_flag)
<a name="l00488"></a>00488 {
<a name="l00489"></a>00489         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>        cbw_len;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         cbw_len = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="comment">/*</span>
<a name="l00494"></a>00494 <span class="comment">         * The following cases should result in a phase error:</span>
<a name="l00495"></a>00495 <span class="comment">         *  - Case  2: Hn &lt; Di</span>
<a name="l00496"></a>00496 <span class="comment">         *  - Case  3: Hn &lt; Do</span>
<a name="l00497"></a>00497 <span class="comment">         *  - Case  7: Hi &lt; Di</span>
<a name="l00498"></a>00498 <span class="comment">         *  - Case  8: Hi &lt;&gt; Do</span>
<a name="l00499"></a>00499 <span class="comment">         *  - Case 10: Ho &lt;&gt; Di</span>
<a name="l00500"></a>00500 <span class="comment">         *  - Case 13: Ho &lt; Do</span>
<a name="l00501"></a>00501 <span class="comment">         */</span>
<a name="l00502"></a>00502         <span class="keywordflow">if</span> ((cbw-&gt;<a class="code" href="structusb__msc__cbw.html#a8331a5d04e78012779cdf5a568af90b9" title="Direction in bit 7.">bmCBWFlags</a> ^ dir_flag) &amp; <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>
<a name="l00503"></a>00503                         || cbw_len &lt; alloc_len) {
<a name="l00504"></a>00504                 msc_phase_error(msc);
<a name="l00505"></a>00505                 <span class="keywordflow">return</span> -1;
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         <span class="comment">/*</span>
<a name="l00509"></a>00509 <span class="comment">         * The following cases should result in a stall and nonzero</span>
<a name="l00510"></a>00510 <span class="comment">         * residue:</span>
<a name="l00511"></a>00511 <span class="comment">         *  - Case  4: Hi &gt; Dn</span>
<a name="l00512"></a>00512 <span class="comment">         *  - Case  5: Hi &gt; Di</span>
<a name="l00513"></a>00513 <span class="comment">         *  - Case  9: Ho &gt; Dn</span>
<a name="l00514"></a>00514 <span class="comment">         *  - Case 11: Ho &gt; Do</span>
<a name="l00515"></a>00515 <span class="comment">         */</span>
<a name="l00516"></a>00516         <span class="keywordflow">return</span> cbw_len - alloc_len;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_test_unit_ready(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l00520"></a>00520                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> cbw_data_len)
<a name="l00521"></a>00521 {
<a name="l00522"></a>00522         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc TEST UNIT READY len %lu\n&quot;</span>, cbw_data_len);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>) {
<a name="l00525"></a>00525                 msc_request_failed(msc, cbw_data_len, <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l00526"></a>00526                                 SCSI_SK_NOT_READY,
<a name="l00527"></a>00527                                 msc-&gt;<a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a>);
<a name="l00528"></a>00528         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__bitops__group.html#gab6f6195f23a2985c9d6d1520e60ec3ad" title="Test bit nr in bitmap.">test_bit</a>(<a class="code" href="group__block__device__group.html#gga0264ef48c2d30f1da19d75e8c760cd22a2c79d421c9d75189ce999d812fc9b9bd" title="Device is present.">BDEV_PRESENT</a>, &amp;msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#ac5a8c54588871e35f74699f925e86fa6">flags</a>)) {
<a name="l00529"></a>00529                 msc_prepare_csw(msc, cbw_data_len, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l00530"></a>00530                 msc_request_done_nodata(udc, msc, cbw_data_len);
<a name="l00531"></a>00531         } <span class="keywordflow">else</span> {
<a name="l00532"></a>00532                 msc_request_failed(msc, cbw_data_len, <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l00533"></a>00533                                 SCSI_SK_NOT_READY,
<a name="l00534"></a>00534                                 SCSI_ASC_MEDIUM_NOT_PRESENT);
<a name="l00535"></a>00535         }
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_request_sense(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l00539"></a>00539                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw)
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l00542"></a>00542         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00543"></a>00543         <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>           *cdb = cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>;
<a name="l00544"></a>00544         <span class="keywordtype">long</span>                    residue;
<a name="l00545"></a>00545         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>                 alloc_len;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         alloc_len = scsi_cdb6_get_alloc_len(cdb);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: REQUEST SENSE len %u (sense len %u)\n&quot;</span>,
<a name="l00550"></a>00550                         alloc_len, msc_sense_len(msc));
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         residue = msc_validate_req(msc, cbw, alloc_len, <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>);
<a name="l00553"></a>00553         <span class="keywordflow">if</span> (residue &lt; 0)
<a name="l00554"></a>00554                 <span class="keywordflow">return</span>;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556         <span class="keywordflow">if</span> (alloc_len &gt; 0) {
<a name="l00557"></a>00557                 <span class="comment">/*</span>
<a name="l00558"></a>00558 <span class="comment">                 * Just send the sense buffer. It should be</span>
<a name="l00559"></a>00559 <span class="comment">                 * initialized by the last command that failed; after</span>
<a name="l00560"></a>00560 <span class="comment">                 * it has been successfully sent, it gets reset to</span>
<a name="l00561"></a>00561 <span class="comment">                 * NO_SENSE.</span>
<a name="l00562"></a>00562 <span class="comment">                 */</span>
<a name="l00563"></a>00563                 req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l00564"></a>00564                 <span class="keywordflow">if</span> (!req)
<a name="l00565"></a>00565                         <span class="keywordflow">goto</span> err_req_alloc;
<a name="l00566"></a>00566                 buf = <a class="code" href="group__buffer__group.html#gaab157b752eee37551d569241b272cfba" title="Allocate a buffer structure.">buffer_alloc</a>();
<a name="l00567"></a>00567                 <span class="keywordflow">if</span> (!buf)
<a name="l00568"></a>00568                         <span class="keywordflow">goto</span> err_buf_alloc;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570                 <a class="code" href="group__buffer__group.html#ga717929837d4f4ba917aee09943a35263" title="Initialize an already-DMA-mapped buffer for transmitting data.">buffer_init_tx_mapped</a>(buf, msc-&gt;<a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942" title="Buffer holding the current sense information.">sense_data</a>,
<a name="l00571"></a>00571                                 <a class="code" href="group__utility__group.html#gac379f8059c0eaa99d04c1f3bf481a67d" title="Get the lowest of two unsigned values.">min_u</a>(alloc_len, msc_sense_len(msc)));
<a name="l00572"></a>00572                 <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00573"></a>00573                 req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l00574"></a>00574                 req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_sense_data_sent;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576                 residue += alloc_len - buf-&gt;<a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a>;
<a name="l00577"></a>00577                 msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l00578"></a>00578                 <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, req);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580                 msc_request_done(udc, msc, residue);
<a name="l00581"></a>00581         } <span class="keywordflow">else</span> {
<a name="l00582"></a>00582                 <span class="comment">/*</span>
<a name="l00583"></a>00583 <span class="comment">                 * REQUEST SENSE always resets the sense data, even if</span>
<a name="l00584"></a>00584 <span class="comment">                 * no data was actually transfered.</span>
<a name="l00585"></a>00585 <span class="comment">                 */</span>
<a name="l00586"></a>00586                 msc_init_sense(msc, SCSI_SK_NO_SENSE,
<a name="l00587"></a>00587                                 SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
<a name="l00588"></a>00588                 msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l00589"></a>00589                 msc_request_done_nodata(udc, msc, residue);
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="keywordflow">return</span>;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 err_buf_alloc:
<a name="l00595"></a>00595         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00596"></a>00596 err_req_alloc:
<a name="l00597"></a>00597         msc_out_of_memory(msc);
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="keyword">static</span> <span class="keywordtype">int</span> msc_vpd_supported_pages(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00601"></a>00601                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req, <span class="keywordtype">size_t</span> alloc_len)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> vpd_page[] = {
<a name="l00604"></a>00604                 <a class="code" href="spc__protocol_8h.html#a38a553faa28c4d5ec48b887d431a6f4c" title="Peripheral connected.">SCSI_INQ_PQ_CONNECTED</a> | <a class="code" href="spc__protocol_8h.html#aedf94e7cc51e5c8922e9ed2bdd0b36d8" title="Direct Access (SBC).">SCSI_INQ_DT_DIR_ACCESS</a>,
<a name="l00605"></a>00605                 SCSI_VPD_SUPPORTED_PAGES,
<a name="l00606"></a>00606                 0x00,
<a name="l00607"></a>00607                 3,
<a name="l00608"></a>00608                 SCSI_VPD_SUPPORTED_PAGES,
<a name="l00609"></a>00609                 SCSI_VPD_UNIT_SERIAL_NUMBER,
<a name="l00610"></a>00610                 SCSI_VPD_DEVICE_IDENTIFICATION,
<a name="l00611"></a>00611         };
<a name="l00612"></a>00612         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l00613"></a>00613         <span class="keywordtype">size_t</span>          total_len = 0;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         <span class="keywordflow">if</span> (alloc_len) {
<a name="l00616"></a>00616                 buf = <a class="code" href="group__buffer__group.html#gaab157b752eee37551d569241b272cfba" title="Allocate a buffer structure.">buffer_alloc</a>();
<a name="l00617"></a>00617                 <span class="keywordflow">if</span> (!buf)
<a name="l00618"></a>00618                         <span class="keywordflow">return</span> -1;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                 total_len = <a class="code" href="group__utility__group.html#gac379f8059c0eaa99d04c1f3bf481a67d" title="Get the lowest of two unsigned values.">min_u</a>(alloc_len, <span class="keyword">sizeof</span>(vpd_page));
<a name="l00621"></a>00621                 <a class="code" href="group__buffer__group.html#ga08e06f378926444e51a796c70ab9037b" title="Initialize a buffer for transmitting data.">buffer_init_tx</a>(buf, &amp;vpd_page, total_len);
<a name="l00622"></a>00622                 <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00623"></a>00623                 req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_buf_sent;
<a name="l00624"></a>00624         }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="keywordflow">return</span> total_len;
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="keyword">static</span> <span class="keywordtype">int</span> msc_vpd_serial_number(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00630"></a>00630                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req, <span class="keywordtype">size_t</span> alloc_len)
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l00633"></a>00633         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>         *vpd_page;
<a name="l00634"></a>00634         <span class="keyword">const</span> <span class="keywordtype">char</span>      *serial;
<a name="l00635"></a>00635         <span class="keywordtype">size_t</span>          serial_len;
<a name="l00636"></a>00636         <span class="keywordtype">size_t</span>          total_len = 0;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         <span class="keywordflow">if</span> (alloc_len) {
<a name="l00639"></a>00639                 serial = app_get_serial_number();
<a name="l00640"></a>00640                 serial_len = <a class="code" href="group__string__group.html#ga008e171a518fe0e0352f31b245e03875" title="Calculate the length of a string.">strlen</a>(serial);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642                 <span class="comment">/*</span>
<a name="l00643"></a>00643 <span class="comment">                 * The application must verify that the serial number</span>
<a name="l00644"></a>00644 <span class="comment">                 * is valid by calling msc_serial_number_is_valid() at</span>
<a name="l00645"></a>00645 <span class="comment">                 * startup. An invalid serial number is considered a</span>
<a name="l00646"></a>00646 <span class="comment">                 * serious configuration error.</span>
<a name="l00647"></a>00647 <span class="comment">                 */</span>
<a name="l00648"></a>00648                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(serial_len &lt;= <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a>);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650                 buf = buffer_dma_alloc(MSC_VPD_SERIAL_BUF_SIZE);
<a name="l00651"></a>00651                 <span class="keywordflow">if</span> (!buf)
<a name="l00652"></a>00652                         <span class="keywordflow">return</span> -1;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654                 vpd_page = buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00655"></a>00655                 vpd_page[0] = <a class="code" href="spc__protocol_8h.html#a38a553faa28c4d5ec48b887d431a6f4c" title="Peripheral connected.">SCSI_INQ_PQ_CONNECTED</a> | <a class="code" href="spc__protocol_8h.html#aedf94e7cc51e5c8922e9ed2bdd0b36d8" title="Direct Access (SBC).">SCSI_INQ_DT_DIR_ACCESS</a>;
<a name="l00656"></a>00656                 vpd_page[1] = SCSI_VPD_UNIT_SERIAL_NUMBER;
<a name="l00657"></a>00657                 vpd_page[2] = 0;
<a name="l00658"></a>00658                 vpd_page[3] = <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a>;
<a name="l00659"></a>00659                 <a class="code" href="group__string__group.html#ga313175102214d45434bf045db18dddf0" title="Initialize memory area.">memset</a>(vpd_page + SCSI_VPD_HEADER_SIZE,
<a name="l00660"></a>00660                                 <span class="charliteral">&#39; &#39;</span>, <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a> - serial_len);
<a name="l00661"></a>00661                 <a class="code" href="group__string__group.html#gaba088e716bccbc96d42da97e96316df1" title="Copy memory area.">memcpy</a>(vpd_page + MSC_VPD_SERIAL_BUF_SIZE - serial_len,
<a name="l00662"></a>00662                                 serial, serial_len);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664                 total_len = MSC_VPD_SERIAL_BUF_SIZE;
<a name="l00665"></a>00665                 <span class="keywordflow">if</span> (alloc_len &lt; total_len) {
<a name="l00666"></a>00666                         total_len = alloc_len;
<a name="l00667"></a>00667                         <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, total_len);
<a name="l00668"></a>00668                 }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670                 <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00671"></a>00671                 req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_vpd_serial_sent;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <span class="keywordflow">return</span> total_len;
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="keyword">static</span> <span class="keywordtype">int</span> msc_vpd_device_id(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00678"></a>00678                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req, <span class="keywordtype">size_t</span> alloc_len)
<a name="l00679"></a>00679 {
<a name="l00680"></a>00680         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l00681"></a>00681         <span class="keyword">const</span> <span class="keywordtype">char</span>      *serial;
<a name="l00682"></a>00682         <span class="keywordtype">size_t</span>          serial_len;
<a name="l00683"></a>00683         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>         *vpd_page;
<a name="l00684"></a>00684         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>         *p;
<a name="l00685"></a>00685         <span class="keywordtype">size_t</span>          total_len = 0;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         <span class="keywordflow">if</span> (alloc_len) {
<a name="l00688"></a>00688                 serial = app_get_serial_number();
<a name="l00689"></a>00689                 serial_len = <a class="code" href="group__string__group.html#ga008e171a518fe0e0352f31b245e03875" title="Calculate the length of a string.">strlen</a>(serial);
<a name="l00690"></a>00690 
<a name="l00691"></a>00691                 <span class="comment">/*</span>
<a name="l00692"></a>00692 <span class="comment">                 * The application must verify that the serial number</span>
<a name="l00693"></a>00693 <span class="comment">                 * is valid by calling msc_serial_number_is_valid() at</span>
<a name="l00694"></a>00694 <span class="comment">                 * startup. An invalid serial number is considered a</span>
<a name="l00695"></a>00695 <span class="comment">                 * serious configuration error.</span>
<a name="l00696"></a>00696 <span class="comment">                 */</span>
<a name="l00697"></a>00697                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(serial_len &lt;= <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a>);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699                 buf = buffer_dma_alloc(MSC_VPD_ID_BUF_SIZE);
<a name="l00700"></a>00700                 <span class="keywordflow">if</span> (!buf)
<a name="l00701"></a>00701                         <span class="keywordflow">return</span> -1;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                 vpd_page = buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00704"></a>00704                 vpd_page[0] = <a class="code" href="spc__protocol_8h.html#a38a553faa28c4d5ec48b887d431a6f4c" title="Peripheral connected.">SCSI_INQ_PQ_CONNECTED</a> | <a class="code" href="spc__protocol_8h.html#aedf94e7cc51e5c8922e9ed2bdd0b36d8" title="Direct Access (SBC).">SCSI_INQ_DT_DIR_ACCESS</a>;
<a name="l00705"></a>00705                 vpd_page[1] = SCSI_VPD_DEVICE_IDENTIFICATION;
<a name="l00706"></a>00706                 vpd_page[2] = 0;
<a name="l00707"></a>00707                 vpd_page[3] = MSC_VPD_ID_BUF_SIZE - SCSI_VPD_HEADER_SIZE;
<a name="l00708"></a>00708                 vpd_page[4] = SCSI_VPD_CODE_SET_ASCII;
<a name="l00709"></a>00709                 vpd_page[5] = SCSI_VPD_ID_TYPE_T10;
<a name="l00710"></a>00710                 vpd_page[6] = 0;
<a name="l00711"></a>00711                 vpd_page[7] = MSC_VPD_ID_BUF_SIZE - SCSI_VPD_HEADER_SIZE
<a name="l00712"></a>00712                                 - SCSI_VPD_ID_HEADER_SIZE;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714                 <span class="comment">/* Copy Vendor ID and Product ID in one go */</span>
<a name="l00715"></a>00715                 p = vpd_page + SCSI_VPD_HEADER_SIZE + SCSI_VPD_ID_HEADER_SIZE;
<a name="l00716"></a>00716                 <a class="code" href="group__string__group.html#gaba088e716bccbc96d42da97e96316df1" title="Copy memory area.">memcpy</a>(p, msc_inquiry_data.<a class="code" href="structscsi__inquiry__data.html#a31bfc33bec4f63c2a1f29db2436532ca" title="T10 Vendor Identification.">vendor_id</a>, 8 + 16);
<a name="l00717"></a>00717 
<a name="l00718"></a>00718                 <span class="comment">/* And finally, the right-aligned serial number */</span>
<a name="l00719"></a>00719                 p += 8 + 16;
<a name="l00720"></a>00720                 <a class="code" href="group__string__group.html#ga313175102214d45434bf045db18dddf0" title="Initialize memory area.">memset</a>(p, <span class="charliteral">&#39; &#39;</span>, <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a> - serial_len);
<a name="l00721"></a>00721                 p += <a class="code" href="group__udi__msc__bulk__group.html#gac19a639163ff0088e3d6cee34960f951" title="Maximum number of characters in the device serial number.">MSC_MAX_SERIAL_LEN</a> - serial_len;
<a name="l00722"></a>00722                 <a class="code" href="group__string__group.html#gaba088e716bccbc96d42da97e96316df1" title="Copy memory area.">memcpy</a>(p, serial, serial_len);
<a name="l00723"></a>00723 
<a name="l00724"></a>00724                 total_len = MSC_VPD_ID_BUF_SIZE;
<a name="l00725"></a>00725                 <span class="keywordflow">if</span> (alloc_len &lt; total_len) {
<a name="l00726"></a>00726                         total_len = alloc_len;
<a name="l00727"></a>00727                         <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, total_len);
<a name="l00728"></a>00728                 }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                 <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00731"></a>00731                 req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_vpd_id_sent;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734         <span class="keywordflow">return</span> total_len;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_inquiry(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l00738"></a>00738                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw)
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l00741"></a>00741         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00742"></a>00742         <span class="keywordtype">long</span>                    residue;
<a name="l00743"></a>00743         <span class="keywordtype">long</span>                    ret;
<a name="l00744"></a>00744         <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a>                alloc_len;
<a name="l00745"></a>00745         <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>           *cdb = cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>;
<a name="l00746"></a>00746         <span class="keywordtype">size_t</span>                  total_len;
<a name="l00747"></a>00747         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>                 page_code;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         alloc_len = scsi_cdb_get_u16(cdb, 3);
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: INQUIRY %u (inq len %zu)\n&quot;</span>,
<a name="l00752"></a>00752                         alloc_len, <span class="keyword">sizeof</span>(msc_inquiry_data));
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         residue = msc_validate_req(msc, cbw, alloc_len, <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>);
<a name="l00755"></a>00755         <span class="keywordflow">if</span> (residue &lt; 0)
<a name="l00756"></a>00756                 <span class="keywordflow">return</span>;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (!req)
<a name="l00760"></a>00760                 <span class="keywordflow">goto</span> err_req_alloc;
<a name="l00761"></a>00761         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         total_len = 0;
<a name="l00764"></a>00764         page_code = cdb[2];
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (cdb[1] &amp; <a class="code" href="spc__protocol_8h.html#a944818b06a40bf70b242a3a91bd236b2" title="Enable Vital Product Data.">SCSI_INQ_REQ_EVPD</a>) {
<a name="l00767"></a>00767                 <span class="comment">/* Vital Product Data page requested */</span>
<a name="l00768"></a>00768                 <span class="keywordflow">switch</span> (page_code) {
<a name="l00769"></a>00769                 <span class="keywordflow">case</span> SCSI_VPD_SUPPORTED_PAGES:
<a name="l00770"></a>00770                         ret = msc_vpd_supported_pages(msc, req, alloc_len);
<a name="l00771"></a>00771                         <span class="keywordflow">break</span>;
<a name="l00772"></a>00772                 <span class="keywordflow">case</span> SCSI_VPD_UNIT_SERIAL_NUMBER:
<a name="l00773"></a>00773                         ret = msc_vpd_serial_number(msc, req, alloc_len);
<a name="l00774"></a>00774                         <span class="keywordflow">break</span>;
<a name="l00775"></a>00775                 <span class="keywordflow">case</span> SCSI_VPD_DEVICE_IDENTIFICATION:
<a name="l00776"></a>00776                         ret = msc_vpd_device_id(msc, req, alloc_len);
<a name="l00777"></a>00777                         <span class="keywordflow">break</span>;
<a name="l00778"></a>00778                 <span class="keywordflow">default</span>:
<a name="l00779"></a>00779                         <a class="code" href="group__debug__console.html#ga7ea40a3701ec24dfbb88fb1a74c9d8f2" title="Display an informational message.">dbg_info</a>(<span class="stringliteral">&quot;msc: unsupported VPD page %02x requested\n&quot;</span>,
<a name="l00780"></a>00780                                         page_code);
<a name="l00781"></a>00781                         <span class="keywordflow">goto</span> illegal_request;
<a name="l00782"></a>00782                 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784                 <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00785"></a>00785                         <span class="keywordflow">goto</span> err_buf_alloc;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787                 total_len = ret;
<a name="l00788"></a>00788         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (page_code != 0) {
<a name="l00789"></a>00789                 <span class="comment">/* Nonzero PC is illegal when EVPD is not set */</span>
<a name="l00790"></a>00790                 <a class="code" href="group__debug__console.html#ga7ea40a3701ec24dfbb88fb1a74c9d8f2" title="Display an informational message.">dbg_info</a>(<span class="stringliteral">&quot;msc: INQUIRY PC=%02x but EVPD not set\n&quot;</span>, page_code);
<a name="l00791"></a>00791                 <span class="keywordflow">goto</span> illegal_request;
<a name="l00792"></a>00792         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alloc_len) {
<a name="l00793"></a>00793                 <span class="comment">/* Send the normal INQUIRY data */</span>
<a name="l00794"></a>00794                 buf = <a class="code" href="group__buffer__group.html#gaab157b752eee37551d569241b272cfba" title="Allocate a buffer structure.">buffer_alloc</a>();
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (!buf)
<a name="l00796"></a>00796                         <span class="keywordflow">goto</span> err_buf_alloc;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798                 total_len = <a class="code" href="group__utility__group.html#gac379f8059c0eaa99d04c1f3bf481a67d" title="Get the lowest of two unsigned values.">min_u</a>(alloc_len, <span class="keyword">sizeof</span>(msc_inquiry_data));
<a name="l00799"></a>00799                 <a class="code" href="group__buffer__group.html#ga08e06f378926444e51a796c70ab9037b" title="Initialize a buffer for transmitting data.">buffer_init_tx</a>(buf, &amp;msc_inquiry_data, total_len);
<a name="l00800"></a>00800                 <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00801"></a>00801                 req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_buf_sent;
<a name="l00802"></a>00802         }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         residue += alloc_len - total_len;
<a name="l00805"></a>00805         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         <span class="keywordflow">if</span> (total_len) {
<a name="l00808"></a>00808                 <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, req);
<a name="l00809"></a>00809                 msc_request_done(udc, msc, residue);
<a name="l00810"></a>00810         } <span class="keywordflow">else</span> {
<a name="l00811"></a>00811                 <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00812"></a>00812                 msc_request_done_nodata(udc, msc, residue);
<a name="l00813"></a>00813         }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         <span class="keywordflow">return</span>;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 illegal_request:
<a name="l00818"></a>00818         msc_request_failed(msc, alloc_len + residue,
<a name="l00819"></a>00819                         <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l00820"></a>00820                         SCSI_SK_ILLEGAL_REQUEST,
<a name="l00821"></a>00821                         SCSI_ASC_INVALID_FIELD_IN_CDB);
<a name="l00822"></a>00822         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00823"></a>00823         <span class="keywordflow">return</span>;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 err_buf_alloc:
<a name="l00826"></a>00826         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00827"></a>00827 err_req_alloc:
<a name="l00828"></a>00828         msc_out_of_memory(msc);
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="keyword">static</span> <span class="keywordtype">long</span> msc_add_mode_pages(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l00832"></a>00832                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> avail_len,
<a name="l00833"></a>00833                 <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> *cdb, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> cbw_data_len)
<a name="l00834"></a>00834 {
<a name="l00835"></a>00835         <span class="comment">/* Changeable values are not supported */</span>
<a name="l00836"></a>00836         <span class="keywordflow">if</span> (scsi_mode_sense_get_pc(cdb) == SCSI_MS_PC_CHANGEABLE) {
<a name="l00837"></a>00837                 <a class="code" href="group__debug__console.html#ga7ea40a3701ec24dfbb88fb1a74c9d8f2" title="Display an informational message.">dbg_info</a>(<span class="stringliteral">&quot;msc: changeable mode pages not supported\n&quot;</span>);
<a name="l00838"></a>00838                 <span class="keywordflow">goto</span> invalid_request;
<a name="l00839"></a>00839         }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         <span class="comment">/* Saved values are not supported either, but we&#39;re allowed to</span>
<a name="l00842"></a>00842 <span class="comment">         * return current values instead. Also, since we don&#39;t support</span>
<a name="l00843"></a>00843 <span class="comment">         * changeable values, current values equal default values */</span>
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="comment">/* Now, send any mode pages that were requested */</span>
<a name="l00846"></a>00846         <span class="keywordflow">switch</span> (scsi_mode_sense_get_page_code(cdb)) {
<a name="l00847"></a>00847         <span class="keywordflow">case</span> 0:
<a name="l00848"></a>00848                 <span class="comment">/* Just return the header and block descriptors */</span>
<a name="l00849"></a>00849                 <span class="keywordflow">break</span>;
<a name="l00850"></a>00850         <span class="keywordflow">case</span> SCSI_MS_PAGE_ALL:
<a name="l00851"></a>00851                 <span class="comment">/* We don&#39;t support any actual mode pages yet */</span>
<a name="l00852"></a>00852                 <span class="keywordflow">break</span>;
<a name="l00853"></a>00853         <span class="keywordflow">default</span>:
<a name="l00854"></a>00854                 <a class="code" href="group__debug__console.html#ga7ea40a3701ec24dfbb88fb1a74c9d8f2" title="Display an informational message.">dbg_info</a>(<span class="stringliteral">&quot;msc: unsupported mode page 0x%x\n&quot;</span>,
<a name="l00855"></a>00855                                 scsi_mode_sense_get_page_code(cdb));
<a name="l00856"></a>00856                 <span class="keywordflow">goto</span> invalid_request;
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859         <span class="keywordflow">return</span> 0;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 invalid_request:
<a name="l00862"></a>00862         msc_request_failed(msc, cbw_data_len, <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l00863"></a>00863                         SCSI_SK_ILLEGAL_REQUEST,
<a name="l00864"></a>00864                         SCSI_ASC_INVALID_FIELD_IN_CDB);
<a name="l00865"></a>00865         <span class="keywordflow">return</span> -1;
<a name="l00866"></a>00866 }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_mode_sense(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l00869"></a>00869                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> alloc_len)
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871         <span class="keyword">union </span>msc_mode_param_header *header;
<a name="l00872"></a>00872         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l00873"></a>00873         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00874"></a>00874         <span class="keyword">const</span> <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>           *cdb = cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>;
<a name="l00875"></a>00875         <span class="keywordtype">long</span>                    residue;
<a name="l00876"></a>00876         <span class="keywordtype">long</span>                    ret;
<a name="l00877"></a>00877         <span class="keywordtype">size_t</span>                  total_size;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc MODE SENSE(N) page %u PC%u len %lu\n&quot;</span>,
<a name="l00880"></a>00880                         scsi_mode_sense_get_page_code(cdb),
<a name="l00881"></a>00881                         scsi_mode_sense_get_pc(cdb),
<a name="l00882"></a>00882                         alloc_len);
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         residue = msc_validate_req(msc, cbw, alloc_len, <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>);
<a name="l00885"></a>00885         <span class="keywordflow">if</span> (residue &lt; 0)
<a name="l00886"></a>00886                 <span class="keywordflow">return</span>;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l00889"></a>00889         <span class="keywordflow">if</span> (!req)
<a name="l00890"></a>00890                 <span class="keywordflow">goto</span> err_req_alloc;
<a name="l00891"></a>00891         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l00892"></a>00892         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_mode_params_sent;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="comment">/*</span>
<a name="l00895"></a>00895 <span class="comment">         * Always send a header. Also allocate room for a block</span>
<a name="l00896"></a>00896 <span class="comment">         * descriptor while we&#39;re at it.</span>
<a name="l00897"></a>00897 <span class="comment">         */</span>
<a name="l00898"></a>00898         buf = buffer_dma_alloc(MSC_MODE_PARAM_HDR_BUF_LEN);
<a name="l00899"></a>00899         <span class="keywordflow">if</span> (!buf)
<a name="l00900"></a>00900                 <span class="keywordflow">goto</span> err_buf_alloc;
<a name="l00901"></a>00901         <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l00902"></a>00902 
<a name="l00903"></a>00903         header = buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l00904"></a>00904         <a class="code" href="group__string__group.html#ga313175102214d45434bf045db18dddf0" title="Initialize memory area.">memset</a>(header, 0, MSC_MODE_PARAM_HDR_BUF_LEN);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906         <span class="comment">/* The block device determines WP status */</span>
<a name="l00907"></a>00907         <span class="keywordflow">if</span> (scsi_cdb_get_opcode(cdb) == SCSI_CMD_MODE_SENSE6) {
<a name="l00908"></a>00908                 <span class="keywordflow">if</span> (!<a class="code" href="group__bitops__group.html#gab6f6195f23a2985c9d6d1520e60ec3ad" title="Test bit nr in bitmap.">test_bit</a>(<a class="code" href="group__block__device__group.html#gga0264ef48c2d30f1da19d75e8c760cd22a0580dbc5de137d0e65ffaaa3956eb679" title="Device can be written to.">BDEV_WRITEABLE</a>, &amp;msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#ac5a8c54588871e35f74699f925e86fa6">flags</a>))
<a name="l00909"></a>00909                         header-&gt;h6.device_specific_parameter = <a class="code" href="sbc__protocol_8h.html#aa36b8156655f59280e2c291d6fec1eca" title="Write Protected.">SCSI_MS_SBC_WP</a>;
<a name="l00910"></a>00910                 total_size = <span class="keyword">sizeof</span>(header-&gt;h6);
<a name="l00911"></a>00911         } <span class="keywordflow">else</span> {
<a name="l00912"></a>00912                 <span class="keywordflow">if</span> (!<a class="code" href="group__bitops__group.html#gab6f6195f23a2985c9d6d1520e60ec3ad" title="Test bit nr in bitmap.">test_bit</a>(<a class="code" href="group__block__device__group.html#gga0264ef48c2d30f1da19d75e8c760cd22a0580dbc5de137d0e65ffaaa3956eb679" title="Device can be written to.">BDEV_WRITEABLE</a>, &amp;msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#ac5a8c54588871e35f74699f925e86fa6">flags</a>))
<a name="l00913"></a>00913                         header-&gt;h10.device_specific_parameter = <a class="code" href="sbc__protocol_8h.html#aa36b8156655f59280e2c291d6fec1eca" title="Write Protected.">SCSI_MS_SBC_WP</a>;
<a name="l00914"></a>00914                 total_size = <span class="keyword">sizeof</span>(header-&gt;h10);
<a name="l00915"></a>00915         }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="comment">/*</span>
<a name="l00918"></a>00918 <span class="comment">         * If the Disable Block Descriptors bit isn&#39;t set, add a</span>
<a name="l00919"></a>00919 <span class="comment">         * block descriptor.</span>
<a name="l00920"></a>00920 <span class="comment">         */</span>
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (!scsi_mode_sense_dbd_is_set(cdb)) {
<a name="l00922"></a>00922                 <span class="keyword">struct </span><a class="code" href="structsbc__slba__block__desc.html" title="SBC-2 Short LBA mode parameter block descriptor.">sbc_slba_block_desc</a>      *desc;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924                 total_size += <span class="keyword">sizeof</span>(*desc);
<a name="l00925"></a>00925                 <span class="keywordflow">if</span> (scsi_cdb_get_opcode(cdb) == SCSI_CMD_MODE_SENSE6) {
<a name="l00926"></a>00926                         header-&gt;h6.block_descriptor_length = <span class="keyword">sizeof</span>(*desc);
<a name="l00927"></a>00927                         desc = (<span class="keyword">struct </span><a class="code" href="structsbc__slba__block__desc.html" title="SBC-2 Short LBA mode parameter block descriptor.">sbc_slba_block_desc</a> *)(&amp;header-&gt;h6 + 1);
<a name="l00928"></a>00928                 } <span class="keywordflow">else</span> {
<a name="l00929"></a>00929                         header-&gt;h10.block_descriptor_length
<a name="l00930"></a>00930                                 = <a class="code" href="group__byte__order__group.html#gac55b6698e3141a541a7a9dde4744537b" title="Convert a 16-bit word from native to big endian byte order.">cpu_to_be16</a>(<span class="keyword">sizeof</span>(*desc));
<a name="l00931"></a>00931                         desc = (<span class="keyword">struct </span><a class="code" href="structsbc__slba__block__desc.html" title="SBC-2 Short LBA mode parameter block descriptor.">sbc_slba_block_desc</a> *)(&amp;header-&gt;h10 + 1);
<a name="l00932"></a>00932                 }
<a name="l00933"></a>00933                 desc-&gt;<a class="code" href="structsbc__slba__block__desc.html#a3585da32a801251c582a61171c0bf1ce" title="Number of Blocks.">nr_blocks</a> = <a class="code" href="group__byte__order__group.html#ga002704089e626f3cdeef1389eace52b8" title="Convert a 32-bit word from native to big endian byte order.">cpu_to_be32</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#a12b9f948ec1e5a15f4029ac6c9b8f2fa">nr_blocks</a>);
<a name="l00934"></a>00934                 desc-&gt;<a class="code" href="structsbc__slba__block__desc.html#afcef68881309299eb9a4bb01540f416c" title="Block Length.">block_len</a> = <a class="code" href="group__byte__order__group.html#ga002704089e626f3cdeef1389eace52b8" title="Convert a 32-bit word from native to big endian byte order.">cpu_to_be32</a>(<a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>));
<a name="l00935"></a>00935                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(!(<a class="code" href="group__byte__order__group.html#ga22012a41b863a1906624ab144964c83d" title="Convert a 32-bit word from big endian to native byte order.">be32_to_cpu</a>(desc-&gt;<a class="code" href="structsbc__slba__block__desc.html#afcef68881309299eb9a4bb01540f416c" title="Block Length.">block_len</a>)
<a name="l00936"></a>00936                                         &amp; ~<a class="code" href="sbc__protocol_8h.html#a063f1b0eba2f70b6662de1a55c5ef544" title="Mask reserved bits.">SBC_SLBA_BLOCK_LEN_MASK</a>));
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, total_size);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         <span class="comment">/* Add the mode pages to the response */</span>
<a name="l00942"></a>00942         ret = msc_add_mode_pages(msc, req, alloc_len - total_size, cdb,
<a name="l00943"></a>00943                         alloc_len + residue);
<a name="l00944"></a>00944         <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l00945"></a>00945                 <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00946"></a>00946                 buffer_dma_free(buf, MSC_MODE_PARAM_HDR_BUF_LEN);
<a name="l00947"></a>00947                 <span class="keywordflow">return</span>;
<a name="l00948"></a>00948         }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950         total_size += ret;
<a name="l00951"></a>00951         <span class="keywordflow">if</span> (scsi_cdb_get_opcode(cdb) == SCSI_CMD_MODE_SENSE6)
<a name="l00952"></a>00952                 header-&gt;h6.mode_data_length = total_size - 1;
<a name="l00953"></a>00953         <span class="keywordflow">else</span>
<a name="l00954"></a>00954                 header-&gt;h10.mode_data_length = <a class="code" href="group__byte__order__group.html#gac55b6698e3141a541a7a9dde4744537b" title="Convert a 16-bit word from native to big endian byte order.">cpu_to_be16</a>(total_size - 2);
<a name="l00955"></a>00955 
<a name="l00956"></a>00956         <span class="comment">/*</span>
<a name="l00957"></a>00957 <span class="comment">         * Finish up the USB request and send it if it ends up</span>
<a name="l00958"></a>00958 <span class="comment">         * containing any data.</span>
<a name="l00959"></a>00959 <span class="comment">         */</span>
<a name="l00960"></a>00960         residue += alloc_len - <a class="code" href="group__utility__group.html#gac379f8059c0eaa99d04c1f3bf481a67d" title="Get the lowest of two unsigned values.">min_u</a>(alloc_len, total_size);
<a name="l00961"></a>00961         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l00962"></a>00962         <span class="keywordflow">if</span> (alloc_len &gt; 0) {
<a name="l00963"></a>00963                 <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, req);
<a name="l00964"></a>00964                 msc_request_done(udc, msc, residue);
<a name="l00965"></a>00965         } <span class="keywordflow">else</span> {
<a name="l00966"></a>00966                 <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00967"></a>00967                 buffer_dma_free(buf, MSC_MODE_PARAM_HDR_BUF_LEN);
<a name="l00968"></a>00968                 msc_request_done_nodata(udc, msc, residue);
<a name="l00969"></a>00969         }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         <span class="keywordflow">return</span>;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 err_buf_alloc:
<a name="l00974"></a>00974         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l00975"></a>00975 err_req_alloc:
<a name="l00976"></a>00976         msc_out_of_memory(msc);
<a name="l00977"></a>00977 }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_read_capacity(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l00980"></a>00980                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982         <span class="keyword">struct </span><a class="code" href="structsbc__read__capacity10__data.html" title="SBC-2 READ CAPACITY (10) parameter data.">sbc_read_capacity10_data</a> *response;
<a name="l00983"></a>00983         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l00984"></a>00984         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l00985"></a>00985         <span class="keywordtype">long</span>                    residue;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <a class="code" href="group__assert__group.html#ga0fae3864357c8f0ddad905cf5c838766" title="Assert that condition is true at build time.">build_assert</a>(<span class="keyword">sizeof</span>(*response) == 8);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc READ CAPACITY LBA %lx blklen %u\n&quot;</span>,
<a name="l00990"></a>00990                         msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#a12b9f948ec1e5a15f4029ac6c9b8f2fa">nr_blocks</a> - 1,
<a name="l00991"></a>00991                         <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>));
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         residue = msc_validate_req(msc, cbw, 8, <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>);
<a name="l00994"></a>00994         <span class="keywordflow">if</span> (residue &lt; 0)
<a name="l00995"></a>00995                 <span class="keywordflow">return</span>;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l00998"></a>00998         <span class="keywordflow">if</span> (!req)
<a name="l00999"></a>00999                 <span class="keywordflow">goto</span> err_req_alloc;
<a name="l01000"></a>01000         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_capacity_sent;
<a name="l01001"></a>01001         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         buf = buffer_dma_alloc(<span class="keyword">sizeof</span>(*response));
<a name="l01004"></a>01004         <span class="keywordflow">if</span> (!buf)
<a name="l01005"></a>01005                 <span class="keywordflow">goto</span> err_buf_alloc;
<a name="l01006"></a>01006         <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         response = buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l01009"></a>01009         response-&gt;<a class="code" href="structsbc__read__capacity10__data.html#ac1ec78662c9ec66a0b635701dd58f512" title="LBA of last logical block.">max_lba</a> = <a class="code" href="group__byte__order__group.html#ga002704089e626f3cdeef1389eace52b8" title="Convert a 32-bit word from native to big endian byte order.">cpu_to_be32</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>-&gt;<a class="code" href="structblock__device.html#a12b9f948ec1e5a15f4029ac6c9b8f2fa">nr_blocks</a> - 1);
<a name="l01010"></a>01010         response-&gt;<a class="code" href="structsbc__read__capacity10__data.html#a5bb45c744958f862c5ad832e7c67273c" title="Number of bytes in the last logical block.">block_len</a> = <a class="code" href="group__byte__order__group.html#ga002704089e626f3cdeef1389eace52b8" title="Convert a 32-bit word from native to big endian byte order.">cpu_to_be32</a>(<a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>));
<a name="l01011"></a>01011 
<a name="l01012"></a>01012         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l01013"></a>01013         <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, req);
<a name="l01014"></a>01014         msc_request_done(udc, msc, residue);
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         <span class="keywordflow">return</span>;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 err_buf_alloc:
<a name="l01019"></a>01019         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l01020"></a>01020 err_req_alloc:
<a name="l01021"></a>01021         msc_out_of_memory(msc);
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">static</span> <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> msc_fill_buffer_list(<span class="keyword">struct</span> <a class="code" href="structslist.html" title="A singly linked list.">slist</a> *buf_list,
<a name="l01025"></a>01025                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> block_size, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_remaining;
<a name="l01028"></a>01028         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_per_buf;
<a name="l01029"></a>01029         <a class="code" href="group__stdint__group.html#ga381e0b283f5c3d9f7e88e6aeb43c29f5" title="Fastest unsigned integer with at least 8-bit width.">uint_fast8_t</a>            i;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         blocks_remaining = nr_blocks;
<a name="l01032"></a>01032         blocks_per_buf = MSC_DATA_BUFFER_SIZE / block_size;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034         <span class="keywordflow">for</span> (i = 0; i &lt; MSC_MAX_NR_BUFFERS; i++) {
<a name="l01035"></a>01035                 <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037                 buf = buffer_dma_alloc(MSC_DATA_BUFFER_SIZE);
<a name="l01038"></a>01038                 <span class="keywordflow">if</span> (!buf)
<a name="l01039"></a>01039                         <span class="keywordflow">break</span>;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041                 <span class="keywordflow">if</span> (blocks_per_buf &gt; blocks_remaining) {
<a name="l01042"></a>01042                         blocks_per_buf = blocks_remaining;
<a name="l01043"></a>01043                         <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, blocks_per_buf * block_size);
<a name="l01044"></a>01044                 }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046                 <a class="code" href="slist_8h.html#acd0f70535b445ece86170eb70bd54365" title="Insert node as the last node in list.">slist_insert_tail</a>(buf_list, &amp;buf-&gt;<a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01047"></a>01047                 blocks_remaining -= blocks_per_buf;
<a name="l01048"></a>01048                 <span class="keywordflow">if</span> (!blocks_remaining)
<a name="l01049"></a>01049                         <span class="keywordflow">break</span>;
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="keywordflow">return</span> nr_blocks - blocks_remaining;
<a name="l01053"></a>01053 }
<a name="l01054"></a>01054 
<a name="l01067"></a><a class="code" href="group__udi__msc__bulk__group.html#ga7c198a4d1dbaafaba1e061f90570efc5">01067</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__udi__msc__bulk__group.html#ga7c198a4d1dbaafaba1e061f90570efc5">msc_submit_read_buffers</a>(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l01068"></a>01068                 <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev, <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq,
<a name="l01069"></a>01069                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01070"></a>01070 {
<a name="l01071"></a>01071         <span class="keyword">struct </span><a class="code" href="structslist.html" title="A singly linked list.">slist</a>            buf_list;
<a name="l01072"></a>01072         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <a class="code" href="slist_8h.html#a430c94443e9ea2bc2dbaf3c3ab0e29db" title="Initialize a singly linked list.">slist_init</a>(&amp;buf_list);
<a name="l01075"></a>01075         blocks_queued = msc_fill_buffer_list(&amp;buf_list,
<a name="l01076"></a>01076                                 <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev), nr_blocks);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: blocks %lu/%lu queued for read\n&quot;</span>, blocks_queued,
<a name="l01079"></a>01079                         nr_blocks);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(!blocks_queued))
<a name="l01082"></a>01082                 <span class="keywordflow">return</span> 0;
<a name="l01083"></a>01083 
<a name="l01084"></a>01084         <span class="comment">/*</span>
<a name="l01085"></a>01085 <span class="comment">         * If the request failed before we got around to submitting the</span>
<a name="l01086"></a>01086 <span class="comment">         * buffer list, abort without submitting anything.</span>
<a name="l01087"></a>01087 <span class="comment">         */</span>
<a name="l01088"></a>01088         <a class="code" href="group__atomic__group.html#ga4ac5fba2434dd964f2036695d1f6853a" title="Atomically add value to the value stored at ptr.">atomic_add</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, blocks_queued);
<a name="l01089"></a>01089         <span class="keywordflow">if</span> (<a class="code" href="group__block__device__group.html#ga997c346fc3bb4fb8b905109daadf1403" title="Submit a list of buffers for an already-queued request.">block_submit_buf_list</a>(bdev, breq, &amp;buf_list)) {
<a name="l01090"></a>01090                 <a class="code" href="group__atomic__group.html#gaf81fd137ba2999c07cd2f924366a8a84" title="Atomically subtract value from the value stored at ptr.">atomic_sub</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, blocks_queued);
<a name="l01091"></a>01091                 msc_free_dma_buf_list(&amp;buf_list);
<a name="l01092"></a>01092                 <span class="keywordflow">return</span> 0;
<a name="l01093"></a>01093         }
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> += blocks_queued;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         <span class="keywordflow">return</span> blocks_queued;
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01111"></a><a class="code" href="group__udi__msc__bulk__group.html#gab018b28a520d5e6f09a84b1d16061eaa">01111</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#gab018b28a520d5e6f09a84b1d16061eaa">msc_read_worker</a>(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l01112"></a>01112 {
<a name="l01113"></a>01113         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01114"></a>01114         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *breq = msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l01115"></a>01115         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_remaining;
<a name="l01116"></a>01116         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                submitted;
<a name="l01117"></a>01117         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_per_seg;
<a name="l01118"></a>01118 
<a name="l01119"></a>01119         <a class="code" href="group__compiler__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
<a name="l01120"></a>01120         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: blk pending %u locked %d\n&quot;</span>,
<a name="l01121"></a>01121                         <a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>),
<a name="l01122"></a>01122                         msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a>);
<a name="l01123"></a>01123         blocks_per_seg = MSC_DATA_BUFFER_SIZE / <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01124"></a>01124         <span class="keywordflow">while</span> ((<a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>) * blocks_per_seg)
<a name="l01125"></a>01125                         &lt; <a class="code" href="group__udi__msc__bulk__group.html#ga80f661efc2249d2142ef1ef194a4df9d" title="Maximum number of pending block buffer segments.">MSC_MAX_NR_SEGS</a>
<a name="l01126"></a>01126                         &amp;&amp; !msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a>) {
<a name="l01127"></a>01127                 <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: read worker: q%lu &lt;= t%lu s %d\n&quot;</span>,
<a name="l01128"></a>01128                                 msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>, msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>,
<a name="l01129"></a>01129                                 breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>);
<a name="l01130"></a>01130                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt;= msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>);
<a name="l01131"></a>01131                 blocks_remaining = msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> - msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>;
<a name="l01132"></a>01132                 <span class="keywordflow">if</span> (!blocks_remaining)
<a name="l01133"></a>01133                         <span class="keywordflow">break</span>;
<a name="l01134"></a>01134 
<a name="l01135"></a>01135                 msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">true</span>;
<a name="l01136"></a>01136                 <a class="code" href="group__compiler__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
<a name="l01137"></a>01137 
<a name="l01138"></a>01138                 submitted = <a class="code" href="group__udi__msc__bulk__group.html#ga7c198a4d1dbaafaba1e061f90570efc5">msc_submit_read_buffers</a>(msc, bdev, breq,
<a name="l01139"></a>01139                                 blocks_remaining);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141                 <a class="code" href="group__compiler__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
<a name="l01142"></a>01142                 msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">false</span>;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144                 <span class="keywordflow">if</span> (!submitted)
<a name="l01145"></a>01145                         <span class="keywordflow">break</span>;
<a name="l01146"></a>01146         }
<a name="l01147"></a>01147         <a class="code" href="group__compiler__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc read worker done\n&quot;</span>);
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_read_data_sent(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l01153"></a>01153 {
<a name="l01154"></a>01154         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l01155"></a>01155         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_remaining;
<a name="l01156"></a>01156         <span class="keyword">enum</span> <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a>        status;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: data sent: first=%p last=%p\n&quot;</span>,
<a name="l01159"></a>01159                         <a class="code" href="slist_8h.html#ae0330ec0cd6401b7e59e2e0ffaf76de3" title="Return the first node in list.">slist_peek_head_node</a>(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>),
<a name="l01160"></a>01160                         <a class="code" href="slist_8h.html#a8f60d0c9b55e554c2a06cb5736e48bed" title="Return the last node in list.">slist_peek_tail_node</a>(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>));
<a name="l01161"></a>01161 
<a name="l01162"></a>01162         msc_free_dma_buf_list(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>);
<a name="l01163"></a>01163         status = req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>;
<a name="l01164"></a>01164         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(<a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>) &gt; 0);
<a name="l01167"></a>01167         <a class="code" href="group__atomic__group.html#gad665d89a05070c7b8d39c3b4feade811" title="Decrement the memory object at ptr atomically.">atomic_dec</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>);
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="comment">/*</span>
<a name="l01170"></a>01170 <span class="comment">         * If the USB transfer failed, we were probably disconnected</span>
<a name="l01171"></a>01171 <span class="comment">         * or reset. Abort the operation.</span>
<a name="l01172"></a>01172 <span class="comment">         */</span>
<a name="l01173"></a>01173         <span class="keywordflow">if</span> (status) {
<a name="l01174"></a>01174                 block_abort_req(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>, msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l01175"></a>01175                 <span class="keywordflow">return</span>;
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         blocks_remaining = msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> - msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>;
<a name="l01179"></a>01179         <span class="keywordflow">if</span> (!blocks_remaining)
<a name="l01180"></a>01180                 msc_request_data_done(udc, msc);
<a name="l01181"></a>01181         <span class="keywordflow">else</span>
<a name="l01182"></a>01182                 <a class="code" href="group__udi__msc__bulk__group.html#gab018b28a520d5e6f09a84b1d16061eaa">msc_read_worker</a>(msc);
<a name="l01183"></a>01183 }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185 <span class="comment">/*</span>
<a name="l01186"></a>01186 <span class="comment"> * This function is called when the block request has moved to the head</span>
<a name="l01187"></a>01187 <span class="comment"> * of the queue and the first batch of buffers have been submitted for</span>
<a name="l01188"></a>01188 <span class="comment"> * DMA. If we start submitting buffers before this, they will be</span>
<a name="l01189"></a>01189 <span class="comment"> * combined with the first batch, and we won&#39;t get a separate completion</span>
<a name="l01190"></a>01190 <span class="comment"> * callback for them.</span>
<a name="l01191"></a>01191 <span class="comment"> */</span>
<a name="l01192"></a>01192 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_read_started(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>,
<a name="l01193"></a>01193                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq)
<a name="l01194"></a>01194 {
<a name="l01195"></a>01195         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt; msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>)
<a name="l01198"></a>01198                 <a class="code" href="group__udi__msc__bulk__group.html#gab018b28a520d5e6f09a84b1d16061eaa">msc_read_worker</a>(msc);
<a name="l01199"></a>01199 }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_read_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01202"></a>01202                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq)
<a name="l01203"></a>01203 {
<a name="l01204"></a>01204         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01205"></a>01205         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw = msc_get_csw(msc);
<a name="l01206"></a>01206         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                residue;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(breq == msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         residue = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a>);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="keywordflow">if</span> (breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>) {
<a name="l01213"></a>01213                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_xfered;
<a name="l01214"></a>01214                 <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw;
<a name="l01215"></a>01215 
<a name="l01216"></a>01216                 blocks_xfered = <a class="code" href="group__block__device__group.html#ga071f10416c339d6f8b1887b7b53c29e8" title="Get the number of blocks actually transfered for a request.">blk_req_get_blocks_xfered</a>(bdev, breq);
<a name="l01217"></a>01217 
<a name="l01218"></a>01218                 <a class="code" href="group__debug__console.html#ga1e39d164d3d05177c7793b1311f6d093" title="Display a warning message.">dbg_warning</a>(<span class="stringliteral">&quot;msc: block read failed: %d (after %lu blocks)\n&quot;</span>,
<a name="l01219"></a>01219                                 breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>, blocks_xfered);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221                 cbw = msc_get_cbw(msc);
<a name="l01222"></a>01222                 residue = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>);
<a name="l01223"></a>01223                 residue -= <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev) * blocks_xfered;
<a name="l01224"></a>01224                 csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a> = <a class="code" href="group__byte__order__group.html#gab44bd5db41a2ff675115a29145513ac5" title="Convert a 32-bit word from native to little endian byte order.">cpu_to_le32</a>(residue);
<a name="l01225"></a>01225                 csw-&gt;<a class="code" href="structusb__msc__csw.html#aa1c2d8d8b2b16b50e9d57e60fd19ca2f" title="Status code.">bCSWStatus</a> = <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227                 msc_init_sense(msc, SCSI_SK_MEDIUM_ERROR,
<a name="l01228"></a>01228                                 SCSI_ASC_UNRECOVERED_READ_ERROR,
<a name="l01229"></a>01229                                 msc-&gt;<a class="code" href="structmsc__interface.html#ab3d26a544f418d4e918815a6a5553242" title="The first Logical Block Address to be transfered.">first_lba</a> + blocks_xfered);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         msc_request_done(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc, residue);
<a name="l01233"></a>01233 }
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_read_buffers_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01236"></a>01236                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq, <span class="keyword">struct</span> <a class="code" href="structslist.html" title="A singly linked list.">slist</a> *buf_list)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01239"></a>01239         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l01240"></a>01240         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l01241"></a>01241         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                nr_blocks;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(!<a class="code" href="slist_8h.html#a48452668d83e04103d667c4ba8eb2899" title="Determine if list is empty.">slist_is_empty</a>(buf_list));
<a name="l01244"></a>01244 
<a name="l01245"></a>01245         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: read bufs done: status %d\n&quot;</span>, breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         <span class="keywordflow">if</span> (breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a> != <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151a9b25aed7ac4ef4fc3c7250543bb113c0" title="Operation in progress.">OPERATION_IN_PROGRESS</a> || !msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>) {
<a name="l01248"></a>01248                 <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;  request terminated, discarding buffers\n&quot;</span>);
<a name="l01249"></a>01249                 msc_free_dma_buf_list(buf_list);
<a name="l01250"></a>01250                 <span class="keywordflow">return</span>;
<a name="l01251"></a>01251         }
<a name="l01252"></a>01252 
<a name="l01253"></a>01253         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l01254"></a>01254         <span class="keywordflow">if</span> (!req) {
<a name="l01255"></a>01255                 block_abort_req(bdev, breq);
<a name="l01256"></a>01256                 msc_free_dma_buf_list(buf_list);
<a name="l01257"></a>01257                 msc_out_of_memory(msc);
<a name="l01258"></a>01258                 <span class="keywordflow">return</span>;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(<a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>) &gt; 0);
<a name="l01262"></a>01262         <a class="code" href="group__atomic__group.html#ga8c61b3ab60d4ce554927e38ee87411d4" title="Increment the memory object at ptr atomically.">atomic_inc</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         <span class="keywordflow">for</span> (nr_blocks = 0, buf = <a class="code" href="group__buffer__group.html#ga0e091c061e88c6c38a6f92c1dd2b5671" title="Return the first buffer in list.">buf_list_peek_head</a>(buf_list);
<a name="l01265"></a>01265                         <a class="code" href="slist_8h.html#a52626766907c9989a26e9658b11c95ac" title="Determine if node represents an item in list (i.e. is not the sentinel node).">slist_node_is_valid</a>(buf_list, &amp;buf-&gt;<a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01266"></a>01266                         buf = <a class="code" href="group__buffer__group.html#ga8439b1a668345115c12517872dbc1012" title="Return the buffer following buf in the list.">buf_list_peek_next</a>(buf)) {
<a name="l01267"></a>01267                 nr_blocks += buf-&gt;<a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a> / <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269         <a class="code" href="group__atomic__group.html#gaf81fd137ba2999c07cd2f924366a8a84" title="Atomically subtract value from the value stored at ptr.">atomic_sub</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, nr_blocks);
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <a class="code" href="slist_8h.html#a3863d98974ba6363a3b906731e162c91" title="Move all the nodes in from to the tail of the list to.">slist_move_to_tail</a>(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>, buf_list);
<a name="l01272"></a>01272         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_read_data_sent;
<a name="l01273"></a>01273         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l01274"></a>01274         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;  submitting IN request...\n&quot;</span>);
<a name="l01275"></a>01275         <a class="code" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88" title="Submit an IN request on a non-control endpoint.">udc_ep_submit_in_req</a>(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>, req);
<a name="l01276"></a>01276 }
<a name="l01277"></a>01277 
<a name="l01286"></a><a class="code" href="group__udi__msc__bulk__group.html#ga1a42320b44d2f0bf1c85b648f5fe963a">01286</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#ga1a42320b44d2f0bf1c85b648f5fe963a">msc_do_read</a>(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l01287"></a>01287                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> lba, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01288"></a>01288 {
<a name="l01289"></a>01289         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01290"></a>01290         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *breq;
<a name="l01291"></a>01291         <span class="keywordtype">long</span>                    residue;
<a name="l01292"></a>01292         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                cdb_data_len;
<a name="l01293"></a>01293         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01294"></a>01294         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a59a24f6c541d2c1b20d7c897ed7bdbca" title="Type used for holding the current interrupt state.">irqflags_t</a>              iflags;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc READ(x) %lu blocks, LBA %lu\n&quot;</span>, nr_blocks, lba);
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(!msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a>);
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         <span class="comment">/*</span>
<a name="l01301"></a>01301 <span class="comment">         * READ(10) allows max 65535 blocks. We allow max 65535 for</span>
<a name="l01302"></a>01302 <span class="comment">         * block_size, so this cannot overflow.</span>
<a name="l01303"></a>01303 <span class="comment">         */</span>
<a name="l01304"></a>01304         cdb_data_len = nr_blocks * <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01305"></a>01305 
<a name="l01306"></a>01306         residue = msc_validate_req(msc, cbw, cdb_data_len,
<a name="l01307"></a>01307                         <a class="code" href="group__msc__protocol__group.html#ga021a9ff4e37fd66964d47e2bc1331f90" title="Data from device to host.">USB_CBW_DIRECTION_IN</a>);
<a name="l01308"></a>01308         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(residue &lt; 0))
<a name="l01309"></a>01309                 <span class="keywordflow">return</span>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         iflags = <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#ad0c5a270013dca8848f9902ec131c51f" title="Save the current interrupt state and disable interrupts.">cpu_irq_save</a>();
<a name="l01312"></a>01312         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>) {
<a name="l01313"></a>01313                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01314"></a>01314                 msc_request_failed(msc,
<a name="l01315"></a>01315                                 <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>),
<a name="l01316"></a>01316                                 <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l01317"></a>01317                                 SCSI_SK_NOT_READY, msc-&gt;<a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a>);
<a name="l01318"></a>01318                 <span class="keywordflow">return</span>;
<a name="l01319"></a>01319         }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321         msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a> = <span class="keyword">true</span>;
<a name="l01322"></a>01322         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01323"></a>01323 
<a name="l01324"></a>01324         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326         <span class="comment">/* If no data was requested, we&#39;re done processing the command */</span>
<a name="l01327"></a>01327         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(nr_blocks == 0)) {
<a name="l01328"></a>01328                 msc_request_done_nodata(udc, msc, residue);
<a name="l01329"></a>01329                 <span class="keywordflow">return</span>;
<a name="l01330"></a>01330         }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332         msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> = nr_blocks;
<a name="l01333"></a>01333         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> = 0;
<a name="l01334"></a>01334         msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">true</span>;
<a name="l01335"></a>01335         <a class="code" href="group__atomic__group.html#ga574277a052be95c2dd2a3eae6475c9cc" title="Write value to the atomic object at ptr.">atomic_write</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, 0);
<a name="l01336"></a>01336         <a class="code" href="group__atomic__group.html#ga574277a052be95c2dd2a3eae6475c9cc" title="Write value to the atomic object at ptr.">atomic_write</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>, 0);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338         breq = msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l01339"></a>01339         breq-&gt;req_started = msc_block_read_started;
<a name="l01340"></a>01340         breq-&gt;<a class="code" href="structblock__request.html#a7b02b7ad2aa6012902678b6a9684e639">req_done</a> = msc_block_read_done;
<a name="l01341"></a>01341         breq-&gt;buf_list_done = msc_block_read_buffers_done;
<a name="l01342"></a>01342         breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a> = msc;
<a name="l01343"></a>01343         block_queue_req(bdev, breq, lba, nr_blocks, <a class="code" href="group__block__device__group.html#gga154d08031ee1f7e8312fc53355eb47e7ad38ff3dc6aa2daa5f52712ca12fe18a7" title="Read data from the device.">BLK_OP_READ</a>);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345         blocks_queued = <a class="code" href="group__udi__msc__bulk__group.html#ga7c198a4d1dbaafaba1e061f90570efc5">msc_submit_read_buffers</a>(msc, bdev, breq, nr_blocks);
<a name="l01346"></a>01346         <span class="keywordflow">if</span> (blocks_queued == 0) {
<a name="l01347"></a>01347                 block_abort_req(bdev, breq);
<a name="l01348"></a>01348                 msc_out_of_memory(msc);
<a name="l01349"></a>01349         }
<a name="l01350"></a>01350         msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">false</span>;
<a name="l01351"></a>01351 }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_write_data_received(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req);
<a name="l01354"></a>01354 
<a name="l01366"></a><a class="code" href="group__udi__msc__bulk__group.html#gadab1b4f8ab0335e497228638233c90ca">01366</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="group__udi__msc__bulk__group.html#gadab1b4f8ab0335e497228638233c90ca">msc_submit_write_data_req</a>(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l01367"></a>01367                 <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01368"></a>01368 {
<a name="l01369"></a>01369         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l01370"></a>01370         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l01373"></a>01373         <span class="keywordflow">if</span> (!req)
<a name="l01374"></a>01374                 <span class="keywordflow">return</span> 0;
<a name="l01375"></a>01375 
<a name="l01376"></a>01376         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l01377"></a>01377         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_write_data_received;
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         blocks_queued = msc_fill_buffer_list(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>,
<a name="l01380"></a>01380                                 <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev), nr_blocks);
<a name="l01381"></a>01381 
<a name="l01382"></a>01382         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: blocks %lu/%lu queued for write\n&quot;</span>, blocks_queued,
<a name="l01383"></a>01383                         nr_blocks);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(!blocks_queued)) {
<a name="l01386"></a>01386                 <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l01387"></a>01387                 <span class="keywordflow">return</span> 0;
<a name="l01388"></a>01388         }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> += blocks_queued;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392         <a class="code" href="group__atomic__group.html#ga8c61b3ab60d4ce554927e38ee87411d4" title="Increment the memory object at ptr atomically.">atomic_inc</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>);
<a name="l01393"></a>01393         <a class="code" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8" title="Submit an OUT request on a non-control endpoint.">udc_ep_submit_out_req</a>(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>, req);
<a name="l01394"></a>01394 
<a name="l01395"></a>01395         <span class="keywordflow">return</span> blocks_queued;
<a name="l01396"></a>01396 }
<a name="l01397"></a>01397 
<a name="l01409"></a><a class="code" href="group__udi__msc__bulk__group.html#gafd22239a2f8c83b64e46b8c132baea0c">01409</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#gafd22239a2f8c83b64e46b8c132baea0c">msc_write_worker</a>(<span class="keywordtype">void</span> *data)
<a name="l01410"></a>01410 {
<a name="l01411"></a>01411         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = data;
<a name="l01412"></a>01412         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01413"></a>01413         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_remaining;
<a name="l01414"></a>01414         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                submitted;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416         <span class="keywordflow">while</span> (<a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>) &lt; <a class="code" href="group__udi__msc__bulk__group.html#ga80f661efc2249d2142ef1ef194a4df9d" title="Maximum number of pending block buffer segments.">MSC_MAX_NR_SEGS</a>
<a name="l01417"></a>01417                         &amp;&amp; !msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a>) {
<a name="l01418"></a>01418                 <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: write worker: q%lu &lt;= 5%lu s %d\n&quot;</span>,
<a name="l01419"></a>01419                                 msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>, msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>,
<a name="l01420"></a>01420                                 msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>);
<a name="l01421"></a>01421                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt;= msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>);
<a name="l01422"></a>01422                 blocks_remaining = msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> - msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>;
<a name="l01423"></a>01423                 <span class="keywordflow">if</span> (!blocks_remaining)
<a name="l01424"></a>01424                         <span class="keywordflow">break</span>;
<a name="l01425"></a>01425 
<a name="l01426"></a>01426                 msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">true</span>;
<a name="l01427"></a>01427                 <a class="code" href="group__compiler__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
<a name="l01428"></a>01428 
<a name="l01429"></a>01429                 submitted = <a class="code" href="group__udi__msc__bulk__group.html#gadab1b4f8ab0335e497228638233c90ca">msc_submit_write_data_req</a>(msc, bdev,
<a name="l01430"></a>01430                                 blocks_remaining);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432                 <a class="code" href="group__compiler__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
<a name="l01433"></a>01433                 msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">false</span>;
<a name="l01434"></a>01434 
<a name="l01435"></a>01435                 <span class="keywordflow">if</span> (!submitted)
<a name="l01436"></a>01436                         <span class="keywordflow">break</span>;
<a name="l01437"></a>01437         }
<a name="l01438"></a>01438 }
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_write_started(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01441"></a>01441                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq)
<a name="l01442"></a>01442 {
<a name="l01443"></a>01443         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt; msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>)
<a name="l01446"></a>01446                 <a class="code" href="group__udi__msc__bulk__group.html#gafd22239a2f8c83b64e46b8c132baea0c">msc_write_worker</a>(msc);
<a name="l01447"></a>01447 }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_write_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01450"></a>01450                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq)
<a name="l01451"></a>01451 {
<a name="l01452"></a>01452         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01453"></a>01453         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw = msc_get_csw(msc);
<a name="l01454"></a>01454         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                residue;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(breq == msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l01457"></a>01457 
<a name="l01458"></a>01458         residue = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a>);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460         <span class="keywordflow">if</span> (breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>) {
<a name="l01461"></a>01461                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_xfered;
<a name="l01462"></a>01462                 <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw;
<a name="l01463"></a>01463 
<a name="l01464"></a>01464                 blocks_xfered = <a class="code" href="group__block__device__group.html#ga071f10416c339d6f8b1887b7b53c29e8" title="Get the number of blocks actually transfered for a request.">blk_req_get_blocks_xfered</a>(bdev, breq);
<a name="l01465"></a>01465 
<a name="l01466"></a>01466                 <a class="code" href="group__debug__console.html#ga1e39d164d3d05177c7793b1311f6d093" title="Display a warning message.">dbg_warning</a>(<span class="stringliteral">&quot;msc: block write failed: %d (after %lu blocks)\n&quot;</span>,
<a name="l01467"></a>01467                                 breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>, blocks_xfered);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469                 cbw = msc_get_cbw(msc);
<a name="l01470"></a>01470                 residue = <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>);
<a name="l01471"></a>01471                 residue -= <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev) * blocks_xfered;
<a name="l01472"></a>01472                 csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a> = <a class="code" href="group__byte__order__group.html#gab44bd5db41a2ff675115a29145513ac5" title="Convert a 32-bit word from native to little endian byte order.">cpu_to_le32</a>(residue);
<a name="l01473"></a>01473                 csw-&gt;<a class="code" href="structusb__msc__csw.html#aa1c2d8d8b2b16b50e9d57e60fd19ca2f" title="Status code.">bCSWStatus</a> = <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475                 msc_init_sense(msc, SCSI_SK_MEDIUM_ERROR,
<a name="l01476"></a>01476                                 SCSI_ASC_WRITE_ERROR,
<a name="l01477"></a>01477                                 msc-&gt;<a class="code" href="structmsc__interface.html#ab3d26a544f418d4e918815a6a5553242" title="The first Logical Block Address to be transfered.">first_lba</a> + blocks_xfered);
<a name="l01478"></a>01478         }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480         msc_request_done(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc, residue);
<a name="l01481"></a>01481         msc_request_data_done(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc);
<a name="l01482"></a>01482 }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_block_write_buffers_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01485"></a>01485                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq, <span class="keyword">struct</span> <a class="code" href="structslist.html" title="A singly linked list.">slist</a> *buf_list)
<a name="l01486"></a>01486 {
<a name="l01487"></a>01487         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01488"></a>01488         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l01489"></a>01489         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                nr_blocks;
<a name="l01490"></a>01490 
<a name="l01491"></a>01491         msc_free_dma_buf_list(buf_list);
<a name="l01492"></a>01492 
<a name="l01493"></a>01493         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(<a class="code" href="group__atomic__group.html#ga6eb3f915c81c7d713f97ecc899142a7a" title="Return the value of the atomic object at ptr.">atomic_read</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>) &gt; 0);
<a name="l01494"></a>01494 
<a name="l01495"></a>01495         <span class="keywordflow">for</span> (nr_blocks = 0, buf = <a class="code" href="group__buffer__group.html#ga0e091c061e88c6c38a6f92c1dd2b5671" title="Return the first buffer in list.">buf_list_peek_head</a>(buf_list);
<a name="l01496"></a>01496                         <a class="code" href="slist_8h.html#a52626766907c9989a26e9658b11c95ac" title="Determine if node represents an item in list (i.e. is not the sentinel node).">slist_node_is_valid</a>(buf_list, &amp;buf-&gt;<a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01497"></a>01497                         buf = <a class="code" href="group__buffer__group.html#ga8439b1a668345115c12517872dbc1012" title="Return the buffer following buf in the list.">buf_list_peek_next</a>(buf)) {
<a name="l01498"></a>01498                 nr_blocks += buf-&gt;<a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a> / <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01499"></a>01499         }
<a name="l01500"></a>01500         <a class="code" href="group__atomic__group.html#gaf81fd137ba2999c07cd2f924366a8a84" title="Atomically subtract value from the value stored at ptr.">atomic_sub</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, nr_blocks);
<a name="l01501"></a>01501 
<a name="l01502"></a>01502         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt;= msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>);
<a name="l01503"></a>01503         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> &lt; msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>)
<a name="l01504"></a>01504                 <a class="code" href="group__udi__msc__bulk__group.html#gafd22239a2f8c83b64e46b8c132baea0c">msc_write_worker</a>(msc);
<a name="l01505"></a>01505 }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_write_data_received(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509         <span class="keyword">struct </span><a class="code" href="structslist.html" title="A singly linked list.">slist</a>            buf_list;
<a name="l01510"></a>01510         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l01511"></a>01511         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev;
<a name="l01512"></a>01512         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *breq;
<a name="l01513"></a>01513         <span class="keyword">enum</span> <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a>        status;
<a name="l01514"></a>01514         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l01515"></a>01515         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                nr_blocks;
<a name="l01516"></a>01516 
<a name="l01517"></a>01517         status = req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>;
<a name="l01518"></a>01518         <a class="code" href="slist_8h.html#a430c94443e9ea2bc2dbaf3c3ab0e29db" title="Initialize a singly linked list.">slist_init</a>(&amp;buf_list);
<a name="l01519"></a>01519         <a class="code" href="slist_8h.html#a3863d98974ba6363a3b906731e162c91" title="Move all the nodes in from to the tail of the list to.">slist_move_to_tail</a>(&amp;buf_list, &amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>);
<a name="l01520"></a>01520         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l01521"></a>01521 
<a name="l01522"></a>01522         bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01523"></a>01523         breq = msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525         <span class="keywordflow">for</span> (nr_blocks = 0, buf = <a class="code" href="group__buffer__group.html#ga0e091c061e88c6c38a6f92c1dd2b5671" title="Return the first buffer in list.">buf_list_peek_head</a>(&amp;buf_list);
<a name="l01526"></a>01526                         <a class="code" href="slist_8h.html#a52626766907c9989a26e9658b11c95ac" title="Determine if node represents an item in list (i.e. is not the sentinel node).">slist_node_is_valid</a>(&amp;buf_list, &amp;buf-&gt;<a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01527"></a>01527                         buf = <a class="code" href="group__buffer__group.html#ga8439b1a668345115c12517872dbc1012" title="Return the buffer following buf in the list.">buf_list_peek_next</a>(buf)) {
<a name="l01528"></a>01528                 nr_blocks += buf-&gt;<a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a> / <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01529"></a>01529         }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531         <span class="keywordflow">if</span> (!status) {
<a name="l01532"></a>01532                 <a class="code" href="group__atomic__group.html#ga4ac5fba2434dd964f2036695d1f6853a" title="Atomically add value to the value stored at ptr.">atomic_add</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, nr_blocks);
<a name="l01533"></a>01533                 <a class="code" href="group__atomic__group.html#gad665d89a05070c7b8d39c3b4feade811" title="Decrement the memory object at ptr atomically.">atomic_dec</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535                 <span class="keywordflow">if</span> (<a class="code" href="group__block__device__group.html#ga997c346fc3bb4fb8b905109daadf1403" title="Submit a list of buffers for an already-queued request.">block_submit_buf_list</a>(bdev, breq, &amp;buf_list)) {
<a name="l01536"></a>01536                         <a class="code" href="group__atomic__group.html#gaf81fd137ba2999c07cd2f924366a8a84" title="Atomically subtract value from the value stored at ptr.">atomic_sub</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, nr_blocks);
<a name="l01537"></a>01537                         msc_free_dma_buf_list(&amp;buf_list);
<a name="l01538"></a>01538                 }
<a name="l01539"></a>01539         } <span class="keywordflow">else</span> {
<a name="l01540"></a>01540                 block_abort_req(bdev, breq);
<a name="l01541"></a>01541         }
<a name="l01542"></a>01542 }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_do_write(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l01545"></a>01545                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> lba, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01548"></a>01548         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *breq;
<a name="l01549"></a>01549         <span class="keywordtype">long</span>                    residue;
<a name="l01550"></a>01550         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                cdb_data_len;
<a name="l01551"></a>01551         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01552"></a>01552         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a59a24f6c541d2c1b20d7c897ed7bdbca" title="Type used for holding the current interrupt state.">irqflags_t</a>              iflags;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc WRITE(x) %lu blocks, LBA %lu\n&quot;</span>, nr_blocks, lba);
<a name="l01555"></a>01555 
<a name="l01556"></a>01556         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(!msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a>);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558         <span class="comment">/*</span>
<a name="l01559"></a>01559 <span class="comment">         * WRITE(10) allows max 65535 blocks. We allow max 65535 for</span>
<a name="l01560"></a>01560 <span class="comment">         * block_size, so this cannot overflow.</span>
<a name="l01561"></a>01561 <span class="comment">         */</span>
<a name="l01562"></a>01562         cdb_data_len = nr_blocks * <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564         residue = msc_validate_req(msc, cbw, cdb_data_len, 0);
<a name="l01565"></a>01565         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(residue &lt; 0))
<a name="l01566"></a>01566                 <span class="keywordflow">return</span>;
<a name="l01567"></a>01567 
<a name="l01568"></a>01568         iflags = <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#ad0c5a270013dca8848f9902ec131c51f" title="Save the current interrupt state and disable interrupts.">cpu_irq_save</a>();
<a name="l01569"></a>01569         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>) {
<a name="l01570"></a>01570                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01571"></a>01571                 msc_request_failed(msc,
<a name="l01572"></a>01572                                 <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>),
<a name="l01573"></a>01573                                 <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l01574"></a>01574                                 SCSI_SK_NOT_READY, msc-&gt;<a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a>);
<a name="l01575"></a>01575                 <span class="keywordflow">return</span>;
<a name="l01576"></a>01576         }
<a name="l01577"></a>01577 
<a name="l01578"></a>01578         msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a> = <span class="keyword">true</span>;
<a name="l01579"></a>01579         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01580"></a>01580 
<a name="l01581"></a>01581         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583         <span class="comment">/* If no data was requested, we&#39;re done processing the command */</span>
<a name="l01584"></a>01584         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(nr_blocks == 0)) {
<a name="l01585"></a>01585                 msc_request_done_nodata(udc, msc, residue);
<a name="l01586"></a>01586                 <span class="keywordflow">return</span>;
<a name="l01587"></a>01587         }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589         msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> = nr_blocks;
<a name="l01590"></a>01590         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> = 0;
<a name="l01591"></a>01591         msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">true</span>;
<a name="l01592"></a>01592         <a class="code" href="group__atomic__group.html#ga574277a052be95c2dd2a3eae6475c9cc" title="Write value to the atomic object at ptr.">atomic_write</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#ae2536f9ececb73379f1b3ac6f15e933b" title="Number of pending block buffer blocks.">blk_blocks_pending</a>, 0);
<a name="l01593"></a>01593         <a class="code" href="group__atomic__group.html#ga574277a052be95c2dd2a3eae6475c9cc" title="Write value to the atomic object at ptr.">atomic_write</a>(&amp;msc-&gt;<a class="code" href="structmsc__interface.html#af42e5dbc4226f8677f32a68708409d68" title="Number of pending USB data requests.">usb_reqs_pending</a>, 0);
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         breq = msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l01596"></a>01596         breq-&gt;req_started = msc_block_write_started;
<a name="l01597"></a>01597         breq-&gt;<a class="code" href="structblock__request.html#a7b02b7ad2aa6012902678b6a9684e639">req_done</a> = msc_block_write_done;
<a name="l01598"></a>01598         breq-&gt;buf_list_done = msc_block_write_buffers_done;
<a name="l01599"></a>01599         breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a> = msc;
<a name="l01600"></a>01600         block_queue_req(bdev, breq, lba, nr_blocks, <a class="code" href="group__block__device__group.html#gga154d08031ee1f7e8312fc53355eb47e7a6df37ee16d86ac821be745ca77cef317" title="Write data to the device.">BLK_OP_WRITE</a>);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602         blocks_queued = <a class="code" href="group__udi__msc__bulk__group.html#gadab1b4f8ab0335e497228638233c90ca">msc_submit_write_data_req</a>(msc, bdev, nr_blocks);
<a name="l01603"></a>01603         <span class="keywordflow">if</span> (blocks_queued == 0) {
<a name="l01604"></a>01604                 block_abort_req(bdev, breq);
<a name="l01605"></a>01605                 msc_out_of_memory(msc);
<a name="l01606"></a>01606         }
<a name="l01607"></a>01607         msc-&gt;<a class="code" href="structmsc__interface.html#a8c64da665903e52e96827265ce4057a9" title="True while queuing new buffers for a request.">queue_locked</a> = <span class="keyword">false</span>;
<a name="l01608"></a>01608 }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_read(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l01611"></a>01611                 <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> first_lba,
<a name="l01612"></a>01612                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks);
<a name="l01613"></a>01613 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_bytchk(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l01614"></a>01614                 <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> first_lba,
<a name="l01615"></a>01615                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks);
<a name="l01616"></a>01616 
<a name="l01617"></a>01617 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_bytchk(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc,
<a name="l01618"></a>01618                 <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01619"></a>01619                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> first_lba, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01620"></a>01620 {
<a name="l01621"></a>01621         msc_request_failed(msc, <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(msc_get_csw(msc)-&gt;dCSWDataResidue),
<a name="l01622"></a>01622                         <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>, SCSI_SK_ILLEGAL_REQUEST,
<a name="l01623"></a>01623                         SCSI_ASC_INVALID_FIELD_IN_CDB);
<a name="l01624"></a>01624 }
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_read_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01627"></a>01627                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq)
<a name="l01628"></a>01628 {
<a name="l01629"></a>01629         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01630"></a>01630         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw = msc_get_csw(msc);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(breq == msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l01633"></a>01633 
<a name="l01634"></a>01634         <span class="keywordflow">if</span> (breq-&gt;<a class="code" href="structblock__request.html#a2635bd33014193b5e077eec42dae60cb">status</a>) {
<a name="l01635"></a>01635                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>        blocks_xfered;
<a name="l01636"></a>01636 
<a name="l01637"></a>01637                 blocks_xfered = <a class="code" href="group__block__device__group.html#ga071f10416c339d6f8b1887b7b53c29e8" title="Get the number of blocks actually transfered for a request.">blk_req_get_blocks_xfered</a>(bdev, breq);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639                 csw-&gt;<a class="code" href="structusb__msc__csw.html#aa1c2d8d8b2b16b50e9d57e60fd19ca2f" title="Status code.">bCSWStatus</a> = <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>;
<a name="l01640"></a>01640                 msc_init_sense(msc, SCSI_SK_MEDIUM_ERROR,
<a name="l01641"></a>01641                                 SCSI_ASC_UNRECOVERED_READ_ERROR,
<a name="l01642"></a>01642                                 msc-&gt;<a class="code" href="structmsc__interface.html#ab3d26a544f418d4e918815a6a5553242" title="The first Logical Block Address to be transfered.">first_lba</a> + blocks_xfered);
<a name="l01643"></a>01643         }
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         msc_request_done_nodata(msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a>, msc,
<a name="l01646"></a>01646                         <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(csw-&gt;<a class="code" href="structusb__msc__csw.html#a896d392f5036caced3067d282d5b5807" title="Number of bytes not transfered.">dCSWDataResidue</a>));
<a name="l01647"></a>01647 }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_read_buffers_done(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01650"></a>01650                 <span class="keyword">struct</span> <a class="code" href="structblock__request.html" title="A block device request.">block_request</a> *breq, <span class="keyword">struct</span> <a class="code" href="structslist.html" title="A singly linked list.">slist</a> *buf_list)
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652         <span class="keyword">struct </span><a class="code" href="structslist.html" title="A singly linked list.">slist</a>            new_buf_list;
<a name="l01653"></a>01653         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a>;
<a name="l01654"></a>01654         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            block_size;
<a name="l01655"></a>01655         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01656"></a>01656         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                <a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>;
<a name="l01657"></a>01657         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            blocks_per_buf;
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         blocks_total = msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a>;
<a name="l01660"></a>01660         blocks_queued = msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a>;
<a name="l01661"></a>01661         block_size = <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01662"></a>01662         blocks_per_buf = MSC_DATA_BUFFER_SIZE / block_size;
<a name="l01663"></a>01663         <a class="code" href="slist_8h.html#a430c94443e9ea2bc2dbaf3c3ab0e29db" title="Initialize a singly linked list.">slist_init</a>(&amp;new_buf_list);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="keywordflow">while</span> (!<a class="code" href="slist_8h.html#a48452668d83e04103d667c4ba8eb2899" title="Determine if list is empty.">slist_is_empty</a>(buf_list)) {
<a name="l01666"></a>01666                 <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l01667"></a>01667 
<a name="l01668"></a>01668                 <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(blocks_queued &lt;= blocks_total);
<a name="l01669"></a>01669                 <span class="keywordflow">if</span> (blocks_queued == blocks_total)
<a name="l01670"></a>01670                         <span class="keywordflow">break</span>;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672                 buf = <a class="code" href="slist_8h.html#a731714a0d75bc68ff1ecea1e921f9e17" title="Return the first item in list and remove it.">slist_pop_head</a>(buf_list, <span class="keyword">struct</span> <a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>, <a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01673"></a>01673                 blocks_queued += blocks_per_buf;
<a name="l01674"></a>01674 
<a name="l01675"></a>01675                 <span class="keywordflow">if</span> (blocks_queued &gt; blocks_total) {
<a name="l01676"></a>01676                         blocks_per_buf -= blocks_queued - blocks_total;
<a name="l01677"></a>01677                         <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, block_size * blocks_per_buf);
<a name="l01678"></a>01678                         blocks_queued = blocks_total;
<a name="l01679"></a>01679                 }
<a name="l01680"></a>01680                 <a class="code" href="slist_8h.html#acd0f70535b445ece86170eb70bd54365" title="Insert node as the last node in list.">slist_insert_tail</a>(&amp;new_buf_list, &amp;buf-&gt;<a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l01681"></a>01681         }
<a name="l01682"></a>01682 
<a name="l01683"></a>01683         <span class="keywordflow">if</span> (!<a class="code" href="slist_8h.html#a48452668d83e04103d667c4ba8eb2899" title="Determine if list is empty.">slist_is_empty</a>(&amp;new_buf_list)) {
<a name="l01684"></a>01684                 <span class="keywordflow">if</span> (<a class="code" href="group__block__device__group.html#ga997c346fc3bb4fb8b905109daadf1403" title="Submit a list of buffers for an already-queued request.">block_submit_buf_list</a>(bdev, breq, &amp;new_buf_list))
<a name="l01685"></a>01685                         msc_free_dma_buf_list(&amp;new_buf_list);
<a name="l01686"></a>01686                 <span class="keywordflow">else</span>
<a name="l01687"></a>01687                         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> = blocks_queued;
<a name="l01688"></a>01688         }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690         <span class="comment">/* Free whatever is left over from the loop above */</span>
<a name="l01691"></a>01691         msc_free_dma_buf_list(buf_list);
<a name="l01692"></a>01692 }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_verify_read(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev,
<a name="l01695"></a>01695                 <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> first_lba, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks)
<a name="l01696"></a>01696 {
<a name="l01697"></a>01697         <span class="keyword">struct </span><a class="code" href="structslist.html" title="A singly linked list.">slist</a>            buf_list;
<a name="l01698"></a>01698         <span class="keyword">struct </span><a class="code" href="structblock__request.html" title="A block device request.">block_request</a>    *breq;
<a name="l01699"></a>01699         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                blocks_queued;
<a name="l01700"></a>01700 
<a name="l01701"></a>01701         <span class="comment">/*</span>
<a name="l01702"></a>01702 <span class="comment">         * VERIFY isn&#39;t as performance critical as READ and WRITE, so</span>
<a name="l01703"></a>01703 <span class="comment">         * we&#39;re not doing double-buffering here.</span>
<a name="l01704"></a>01704 <span class="comment">         */</span>
<a name="l01705"></a>01705         msc-&gt;<a class="code" href="structmsc__interface.html#af63257de3883d8e9cd6f2ab2f2fd5a42" title="The total number of blocks to be transfered.">blocks_total</a> = nr_blocks;
<a name="l01706"></a>01706         breq = msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>;
<a name="l01707"></a>01707         breq-&gt;req_started = NULL;
<a name="l01708"></a>01708         breq-&gt;<a class="code" href="structblock__request.html#a7b02b7ad2aa6012902678b6a9684e639">req_done</a> = msc_verify_read_done;
<a name="l01709"></a>01709         breq-&gt;buf_list_done = msc_verify_read_buffers_done;
<a name="l01710"></a>01710         breq-&gt;<a class="code" href="structblock__request.html#a19884bf2e31d8d7602c33d4eeb2cefa5">context</a> = msc;
<a name="l01711"></a>01711         block_queue_req(bdev, breq, first_lba, nr_blocks, <a class="code" href="group__block__device__group.html#gga154d08031ee1f7e8312fc53355eb47e7ad38ff3dc6aa2daa5f52712ca12fe18a7" title="Read data from the device.">BLK_OP_READ</a>);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713         <a class="code" href="slist_8h.html#a430c94443e9ea2bc2dbaf3c3ab0e29db" title="Initialize a singly linked list.">slist_init</a>(&amp;buf_list);
<a name="l01714"></a>01714 
<a name="l01715"></a>01715         blocks_queued = msc_fill_buffer_list(&amp;buf_list,
<a name="l01716"></a>01716                                 <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev), nr_blocks);
<a name="l01717"></a>01717 
<a name="l01718"></a>01718         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(blocks_queued == 0)) {
<a name="l01719"></a>01719                 block_abort_req(bdev, breq);
<a name="l01720"></a>01720                 msc_out_of_memory(msc);
<a name="l01721"></a>01721                 <span class="keywordflow">return</span>;
<a name="l01722"></a>01722         }
<a name="l01723"></a>01723 
<a name="l01724"></a>01724         msc-&gt;<a class="code" href="structmsc__interface.html#ae169bb0f73f9b50c656fb9fed92f8854" title="Number of blocks queued for transfer via bdev.">blocks_queued</a> = blocks_queued;
<a name="l01725"></a>01725         <span class="keywordflow">if</span> (<a class="code" href="group__block__device__group.html#ga997c346fc3bb4fb8b905109daadf1403" title="Submit a list of buffers for an already-queued request.">block_submit_buf_list</a>(bdev, breq, &amp;buf_list)) {
<a name="l01726"></a>01726                 block_abort_req(bdev, breq);
<a name="l01727"></a>01727                 msc_free_dma_buf_list(&amp;buf_list);
<a name="l01728"></a>01728                 msc_out_of_memory(msc);
<a name="l01729"></a>01729         }
<a name="l01730"></a>01730 }
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_do_verify(<span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc, <span class="keyword">struct</span> udc *udc,
<a name="l01733"></a>01733                 <span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a> *cbw, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> lba, <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> nr_blocks,
<a name="l01734"></a>01734                 <span class="keywordtype">bool</span> bytchk)
<a name="l01735"></a>01735 {
<a name="l01736"></a>01736         <span class="keyword">struct </span><a class="code" href="structblock__device.html" title="A block device.">block_device</a>     *bdev = msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>;
<a name="l01737"></a>01737         <span class="keywordtype">long</span>                    residue;
<a name="l01738"></a>01738         <a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a>                cdb_data_len = 0;
<a name="l01739"></a>01739         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a59a24f6c541d2c1b20d7c897ed7bdbca" title="Type used for holding the current interrupt state.">irqflags_t</a>              iflags;
<a name="l01740"></a>01740 
<a name="l01741"></a>01741         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc VERIFY(x) %lu blocks, LBA %lu\n&quot;</span>, nr_blocks, lba);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743         <span class="comment">/* Only expect to transfer data when doing byte checking */</span>
<a name="l01744"></a>01744         <span class="keywordflow">if</span> (bytchk)
<a name="l01745"></a>01745                 cdb_data_len = nr_blocks * <a class="code" href="group__block__device__group.html#ga83cb59abcac38fd17b4d17b6b58833a7" title="Return the block size of bdev.">blkdev_get_block_size</a>(bdev);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         residue = msc_validate_req(msc, cbw, cdb_data_len, 0);
<a name="l01748"></a>01748         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(residue &lt; 0))
<a name="l01749"></a>01749                 <span class="keywordflow">return</span>;
<a name="l01750"></a>01750 
<a name="l01751"></a>01751         iflags = <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#ad0c5a270013dca8848f9902ec131c51f" title="Save the current interrupt state and disable interrupts.">cpu_irq_save</a>();
<a name="l01752"></a>01752         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a>) {
<a name="l01753"></a>01753                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01754"></a>01754                 msc_request_failed(msc,
<a name="l01755"></a>01755                                 <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>),
<a name="l01756"></a>01756                                 <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l01757"></a>01757                                 SCSI_SK_NOT_READY, msc-&gt;<a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a>);
<a name="l01758"></a>01758                 <span class="keywordflow">return</span>;
<a name="l01759"></a>01759         }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761         msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a> = <span class="keyword">true</span>;
<a name="l01762"></a>01762         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         msc_prepare_csw(msc, residue, <a class="code" href="group__msc__protocol__group.html#gadc7279a1a9f0597eb2466d1ef10dea72" title="Command Passed.">USB_CSW_STATUS_PASS</a>);
<a name="l01765"></a>01765 
<a name="l01766"></a>01766         <span class="keywordflow">if</span> (<a class="code" href="group__compiler__group.html#ga1c0c89beb84d05c5ba0bc7ce527a3925" title="The expression exp is unlikely to be true.">unlikely</a>(nr_blocks == 0)) {
<a name="l01767"></a>01767                 <span class="comment">/* Nothing to verify; not an error */</span>
<a name="l01768"></a>01768                 msc_request_done_nodata(udc, msc, residue);
<a name="l01769"></a>01769                 <span class="keywordflow">return</span>;
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         <span class="keywordflow">if</span> (bytchk)
<a name="l01773"></a>01773                 msc_verify_bytchk(msc, bdev, lba, nr_blocks);
<a name="l01774"></a>01774         <span class="keywordflow">else</span>
<a name="l01775"></a>01775                 msc_verify_read(msc, bdev, lba, nr_blocks);
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="keyword">static</span> <span class="keywordtype">void</span> msc_cbw_received(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l01779"></a>01779 {
<a name="l01780"></a>01780         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a>;
<a name="l01781"></a>01781         <span class="keyword">struct </span><a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>      *cbw;
<a name="l01782"></a>01782         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>                 opcode;
<a name="l01783"></a>01783 
<a name="l01784"></a>01784         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;cbw received: status %d len %zu\n&quot;</span>,
<a name="l01785"></a>01785                         req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>, req-&gt;<a class="code" href="structusb__request.html#a2d97ed1ba0059d4649e663febbb2c095" title="The number of bytes actually transfered.">bytes_xfered</a>);
<a name="l01786"></a>01786 
<a name="l01787"></a>01787         cbw = msc_get_cbw(msc);
<a name="l01788"></a>01788         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(req == msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>);
<a name="l01789"></a>01789         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(cbw == <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req)-&gt;addr.ptr);
<a name="l01790"></a>01790 
<a name="l01791"></a>01791         <span class="comment">/* Don&#39;t submit any buffers when the USB transfer failed */</span>
<a name="l01792"></a>01792         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="structusb__request.html#a28909c73430658c82cc4f05cee0e87db" title="Status code set by the UDC driver upon completion of this request.">status</a>)
<a name="l01793"></a>01793                 <span class="keywordflow">return</span>;
<a name="l01794"></a>01794 
<a name="l01795"></a>01795         <span class="comment">/* Is this a valid CBW? */</span>
<a name="l01796"></a>01796         <span class="keywordflow">if</span> (cbw-&gt;<a class="code" href="structusb__msc__cbw.html#ae1158550a28650c597a03c7d8e0faf85" title="Must contain &amp;#39;USBC&amp;#39;.">dCBWSignature</a> != <a class="code" href="group__byte__order__group.html#ga4f24e3d1dc0a8bf7ad7a60553d13daa7" title="Create a 32-bit little endian constant.">LE32</a>(<a class="code" href="group__msc__protocol__group.html#gacb727c8d124837bf354ff001e41f8ca5" title="dCBWSignature value">USB_CBW_SIGNATURE</a>)
<a name="l01797"></a>01797                         || req-&gt;<a class="code" href="structusb__request.html#a2d97ed1ba0059d4649e663febbb2c095" title="The number of bytes actually transfered.">bytes_xfered</a> != 31) {
<a name="l01798"></a>01798                 <span class="comment">/*</span>
<a name="l01799"></a>01799 <span class="comment">                 * No. Wedge both endpoints -- the host must do a</span>
<a name="l01800"></a>01800 <span class="comment">                 * Bulk-Only Mass Storage Reset to recover.</span>
<a name="l01801"></a>01801 <span class="comment">                 */</span>
<a name="l01802"></a>01802                 <a class="code" href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68" title="Set the wedged state of an endpoint.">udc_ep_set_wedge</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>);
<a name="l01803"></a>01803                 <a class="code" href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68" title="Set the wedged state of an endpoint.">udc_ep_set_wedge</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>);
<a name="l01804"></a>01804                 <span class="keywordflow">return</span>;
<a name="l01805"></a>01805         }
<a name="l01806"></a>01806 
<a name="l01807"></a>01807         opcode = scsi_cdb_get_opcode(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>);
<a name="l01808"></a>01808 
<a name="l01809"></a>01809         <span class="comment">/* Try to handle the request */</span>
<a name="l01810"></a>01810         <span class="keywordflow">switch</span> (opcode) {
<a name="l01811"></a>01811         <span class="keywordflow">case</span> SCSI_CMD_TEST_UNIT_READY:
<a name="l01812"></a>01812                 msc_test_unit_ready(msc, udc,
<a name="l01813"></a>01813                                 <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>));
<a name="l01814"></a>01814                 <span class="keywordflow">break</span>;
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         <span class="keywordflow">case</span> SCSI_CMD_REQUEST_SENSE:
<a name="l01817"></a>01817                 msc_request_sense(msc, udc, cbw);
<a name="l01818"></a>01818                 <span class="keywordflow">break</span>;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         <span class="keywordflow">case</span> SCSI_CMD_READ6:
<a name="l01821"></a>01821                 <a class="code" href="group__udi__msc__bulk__group.html#ga1a42320b44d2f0bf1c85b648f5fe963a">msc_do_read</a>(msc, udc, cbw, scsi_cdb6_get_lba(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01822"></a>01822                                 scsi_cdb6_get_xfer_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01823"></a>01823                 <span class="keywordflow">break</span>;
<a name="l01824"></a>01824 
<a name="l01825"></a>01825         <span class="keywordflow">case</span> SCSI_CMD_WRITE6:
<a name="l01826"></a>01826                 msc_do_write(msc, udc, cbw, scsi_cdb6_get_lba(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01827"></a>01827                                 scsi_cdb6_get_xfer_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01828"></a>01828                 <span class="keywordflow">break</span>;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         <span class="keywordflow">case</span> SCSI_CMD_INQUIRY:
<a name="l01831"></a>01831                 msc_inquiry(msc, udc, cbw);
<a name="l01832"></a>01832                 <span class="keywordflow">break</span>;
<a name="l01833"></a>01833 
<a name="l01834"></a>01834         <span class="keywordflow">case</span> SCSI_CMD_MODE_SENSE6:
<a name="l01835"></a>01835                 msc_mode_sense(msc, udc, cbw,
<a name="l01836"></a>01836                         scsi_cdb6_get_alloc_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01837"></a>01837                 <span class="keywordflow">break</span>;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839         <span class="keywordflow">case</span> SCSI_CMD_READ_CAPACITY10:
<a name="l01840"></a>01840                 msc_read_capacity(msc, udc, cbw);
<a name="l01841"></a>01841                 <span class="keywordflow">break</span>;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843         <span class="keywordflow">case</span> SCSI_CMD_READ10:
<a name="l01844"></a>01844                 <a class="code" href="group__udi__msc__bulk__group.html#ga1a42320b44d2f0bf1c85b648f5fe963a">msc_do_read</a>(msc, udc, cbw, scsi_cdb10_get_lba(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01845"></a>01845                                 scsi_cdb10_get_xfer_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01846"></a>01846                 <span class="keywordflow">break</span>;
<a name="l01847"></a>01847 
<a name="l01848"></a>01848         <span class="keywordflow">case</span> SCSI_CMD_WRITE10:
<a name="l01849"></a>01849                 msc_do_write(msc, udc, cbw, scsi_cdb10_get_lba(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01850"></a>01850                                 scsi_cdb10_get_xfer_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01851"></a>01851                 <span class="keywordflow">break</span>;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853         <span class="keywordflow">case</span> SCSI_CMD_VERIFY10:
<a name="l01854"></a>01854                 msc_do_verify(msc, udc, cbw, scsi_cdb10_get_lba(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01855"></a>01855                                 scsi_cdb10_get_xfer_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>),
<a name="l01856"></a>01856                                 scsi_cdb10_bytchk_is_set(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01857"></a>01857                 <span class="keywordflow">break</span>;
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="keywordflow">case</span> SCSI_CMD_MODE_SENSE10:
<a name="l01860"></a>01860                 msc_mode_sense(msc, udc, cbw,
<a name="l01861"></a>01861                                 scsi_cdb10_get_alloc_len(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#aff0975cd0a29fa70062b952f95c98ece" title="SCSI Command Descriptor Block.">CDB</a>));
<a name="l01862"></a>01862                 <span class="keywordflow">break</span>;
<a name="l01863"></a>01863 
<a name="l01864"></a>01864         <span class="keywordflow">default</span>:
<a name="l01865"></a>01865                 <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;MSC: Unhandled opcode %02x\n&quot;</span>, opcode);
<a name="l01866"></a>01866 
<a name="l01867"></a>01867                 msc_request_failed(msc,
<a name="l01868"></a>01868                                 <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(cbw-&gt;<a class="code" href="structusb__msc__cbw.html#abd7ed9f59cdb211476a9c64a07f88097" title="Number of bytes to transfer.">dCBWDataTransferLength</a>),
<a name="l01869"></a>01869                                 <a class="code" href="group__msc__protocol__group.html#ga097cce1766022ae1c866a96d289de063" title="Command Failed.">USB_CSW_STATUS_FAIL</a>,
<a name="l01870"></a>01870                                 SCSI_SK_ILLEGAL_REQUEST,
<a name="l01871"></a>01871                                 SCSI_ASC_INVALID_COMMAND_OPERATION_CODE);
<a name="l01872"></a>01872                 <span class="keywordflow">break</span>;
<a name="l01873"></a>01873         }
<a name="l01874"></a>01874 }
<a name="l01875"></a>01875 
<a name="l01893"></a>01893 <a class="code" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e" title="Status return value.">status_t</a> <a class="code" href="group__udi__msc__bulk__group.html#ga4553198d0be4a11de619faf776985e5b" title="Enable the MSC interface.">udi_msc_enable</a>(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface,
<a name="l01894"></a>01894                 <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a> setting)
<a name="l01895"></a>01895 {
<a name="l01896"></a>01896         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = msc_interface_of(iface);
<a name="l01897"></a>01897         <span class="keyword">struct </span><a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>      *csw;
<a name="l01898"></a>01898         <a class="code" href="uniondma__addr__t.html" title="A physical/virtual address pair used for DMA.">dma_addr_t</a>              addr;
<a name="l01899"></a>01899         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l01900"></a>01900         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l01901"></a>01901         <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a>                ep_size;
<a name="l01902"></a>01902         <a class="code" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28" title="Endpoint identifier.">usb_ep_id_t</a>             ep_id;
<a name="l01903"></a>01903 
<a name="l01904"></a>01904         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc: enabling interface setting %u...\n&quot;</span>, setting);
<a name="l01905"></a>01905 
<a name="l01906"></a>01906         <span class="keywordflow">if</span> (setting != 0)
<a name="l01907"></a>01907                 <span class="keywordflow">return</span> <a class="code" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151a70aa759d292a0e4be7123d01959357da" title="Invalid argument.">ERR_INVALID_ARG</a>;
<a name="l01908"></a>01908 
<a name="l01909"></a>01909         msc-&gt;<a class="code" href="structmsc__interface.html#ab54feef3f26442152f43b8c4e4aaa19d" title="The low-level USB Device Controller.">udc</a> = udc;
<a name="l01910"></a>01910         <a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e" title="Current transfer is done; run any registered busy callback functions and clear it...">msc_queue_empty</a>(msc);
<a name="l01911"></a>01911 
<a name="l01912"></a>01912         ep_size = APP_UDI_MSC_FS_BULK_EP_SIZE;
<a name="l01913"></a>01913         <span class="keywordflow">if</span> (<a class="code" href="group__udc__group.html#ga030b358ddb593a2b3fd049a01c4bf183" title="Test whether the USB Device Controller is running at high speed.">udc_is_high_speed</a>(udc))
<a name="l01914"></a>01914                 ep_size = 512;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    creating bulk-in ep%02x: %u bytes\n&quot;</span>,
<a name="l01917"></a>01917                         MSC_BULK_IN_EP_ADDR, ep_size);
<a name="l01918"></a>01918         ep_id = <a class="code" href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198" title="Create a new Bulk endpoint.">udc_ep_create_bulk</a>(udc, MSC_BULK_IN_EP_ADDR, ep_size);
<a name="l01919"></a>01919         <span class="keywordflow">if</span> (ep_id &lt; 0)
<a name="l01920"></a>01920                 <span class="keywordflow">goto</span> err_create_in_ep;
<a name="l01921"></a>01921         msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a> = ep_id;
<a name="l01922"></a>01922         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    creating bulk-out ep%02x: %u bytes\n&quot;</span>,
<a name="l01923"></a>01923                         MSC_BULK_OUT_EP_ADDR, ep_size);
<a name="l01924"></a>01924         ep_id = <a class="code" href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198" title="Create a new Bulk endpoint.">udc_ep_create_bulk</a>(udc, MSC_BULK_OUT_EP_ADDR, ep_size);
<a name="l01925"></a>01925         <span class="keywordflow">if</span> (ep_id &lt; 0)
<a name="l01926"></a>01926                 <span class="keywordflow">goto</span> err_create_out_ep;
<a name="l01927"></a>01927         msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a> = ep_id;
<a name="l01928"></a>01928 
<a name="l01929"></a>01929         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    allocating block device request\n&quot;</span>);
<a name="l01930"></a>01930         msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a> = <a class="code" href="group__block__device__group.html#gaad4676f6193416f348e2778510080b7a" title="Allocate a block request.">block_alloc_request</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>);
<a name="l01931"></a>01931         <span class="keywordflow">if</span> (!msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>)
<a name="l01932"></a>01932                 <span class="keywordflow">goto</span> err_alloc_breq;
<a name="l01933"></a>01933 
<a name="l01934"></a>01934         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    allocating DMA memory for CSW\n&quot;</span>);
<a name="l01935"></a>01935         addr = <a class="code" href="group__dmapool__generic__group.html#ga3aa00b0494ff313396081bddfb87bbaf" title="Allocate an object from the generic DMA pools.">dma_alloc</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>));
<a name="l01936"></a>01936         <span class="keywordflow">if</span> (!addr.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>)
<a name="l01937"></a>01937                 <span class="keywordflow">goto</span> err_alloc_csw;
<a name="l01938"></a>01938         csw = addr.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l01939"></a>01939         csw-&gt;<a class="code" href="structusb__msc__csw.html#a3ab823b1436a4a3abdcff34d75fc91d4" title="Must contain &amp;#39;USBS&amp;#39;.">dCSWSignature</a> = <a class="code" href="group__byte__order__group.html#ga4f24e3d1dc0a8bf7ad7a60553d13daa7" title="Create a 32-bit little endian constant.">LE32</a>(<a class="code" href="group__msc__protocol__group.html#ga9150766ba34c8615b6b6f8493ec2e7fc" title="dCSWSignature value">USB_CSW_SIGNATURE</a>);
<a name="l01940"></a>01940         msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a> = addr;
<a name="l01941"></a>01941 
<a name="l01942"></a>01942         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    allocating DMA memory for CBW\n&quot;</span>);
<a name="l01943"></a>01943         addr = <a class="code" href="group__dmapool__generic__group.html#ga3aa00b0494ff313396081bddfb87bbaf" title="Allocate an object from the generic DMA pools.">dma_alloc</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l01944"></a>01944         <span class="keywordflow">if</span> (!addr.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>)
<a name="l01945"></a>01945                 <span class="keywordflow">goto</span> err_alloc_cbw;
<a name="l01946"></a>01946         msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a> = addr;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    allocating USB request for CBW and CSW\n&quot;</span>);
<a name="l01949"></a>01949         req = <a class="code" href="group__usb__request__group.html#gad54b52dea624d4d17cec46ada6ed51ea" title="Allocate and initialize a USB request structure.">usb_req_alloc</a>();
<a name="l01950"></a>01950         <span class="keywordflow">if</span> (!req)
<a name="l01951"></a>01951                 <span class="keywordflow">goto</span> err_alloc_cbw_req;
<a name="l01952"></a>01952         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_cbw_received;
<a name="l01953"></a>01953         req-&gt;<a class="code" href="structusb__request.html#ad96153dfc05da2ba35e7a815d43504d4" title="Arbitrary data pointer associated with this request, for use by the submitter.">context</a> = msc;
<a name="l01954"></a>01954         msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a> = req;
<a name="l01955"></a>01955 
<a name="l01956"></a>01956         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    allocating buffer to hold CBW and CSW\n&quot;</span>);
<a name="l01957"></a>01957         buf = <a class="code" href="group__buffer__group.html#gaab157b752eee37551d569241b272cfba" title="Allocate a buffer structure.">buffer_alloc</a>();
<a name="l01958"></a>01958         <span class="keywordflow">if</span> (!buf)
<a name="l01959"></a>01959                 <span class="keywordflow">goto</span> err_alloc_buf;
<a name="l01960"></a>01960         <a class="code" href="group__buffer__group.html#ga48a5f5cf02679d5f06e8a709b0e1d987" title="Initialize an already-DMA-mapped buffer for receiving data.">buffer_init_rx_mapped</a>(buf, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l01961"></a>01961         <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;    submitting CBW - done!\n&quot;</span>);
<a name="l01964"></a>01964         <a class="code" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8" title="Submit an OUT request on a non-control endpoint.">udc_ep_submit_out_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>, req);
<a name="l01965"></a>01965 
<a name="l01966"></a>01966         <span class="keywordflow">return</span> 0;
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 err_alloc_buf:
<a name="l01969"></a>01969         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(req);
<a name="l01970"></a>01970 err_alloc_cbw_req:
<a name="l01971"></a>01971         <a class="code" href="group__dmapool__generic__group.html#ga70ff9a0bae4405abdf0d4e7a05754850" title="Free an object to the generic DMA pools.">dma_free</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l01972"></a>01972 err_alloc_cbw:
<a name="l01973"></a>01973         <a class="code" href="group__dmapool__generic__group.html#ga70ff9a0bae4405abdf0d4e7a05754850" title="Free an object to the generic DMA pools.">dma_free</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>));
<a name="l01974"></a>01974 err_alloc_csw:
<a name="l01975"></a>01975         <a class="code" href="group__block__device__group.html#ga70412d7195c030d5d8be509d3cf19bea" title="Free a block request previously allocated using block_alloc_request().">block_free_request</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>, msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l01976"></a>01976 err_alloc_breq:
<a name="l01977"></a>01977         ep_id = msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>;
<a name="l01978"></a>01978         msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a> = 0;
<a name="l01979"></a>01979         <a class="code" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e" title="Destroy a previously created endpoint.">udc_ep_destroy</a>(udc, ep_id);
<a name="l01980"></a>01980 err_create_out_ep:
<a name="l01981"></a>01981         ep_id = msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>;
<a name="l01982"></a>01982         msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a> = 0;
<a name="l01983"></a>01983         <a class="code" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e" title="Destroy a previously created endpoint.">udc_ep_destroy</a>(udc, ep_id);
<a name="l01984"></a>01984 err_create_in_ep:
<a name="l01985"></a>01985         <span class="keywordflow">return</span> -1;
<a name="l01986"></a>01986 }
<a name="l01987"></a>01987 
<a name="l01997"></a>01997 <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#ga816fbbe98af5d7a3b7a414ca3715985f" title="Disable the MSC interface.">udi_msc_disable</a>(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface)
<a name="l01998"></a>01998 {
<a name="l01999"></a>01999         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = msc_interface_of(iface);
<a name="l02000"></a>02000         <a class="code" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28" title="Endpoint identifier.">usb_ep_id_t</a>             in, out;
<a name="l02001"></a>02001 
<a name="l02002"></a>02002         <a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e" title="Current transfer is done; run any registered busy callback functions and clear it...">msc_queue_empty</a>(msc);
<a name="l02003"></a>02003 
<a name="l02004"></a>02004         in = msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>;
<a name="l02005"></a>02005         msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a> = 0;
<a name="l02006"></a>02006         out = msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>;
<a name="l02007"></a>02007         msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a> = 0;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009         <span class="keywordflow">if</span> (in &gt; 0)
<a name="l02010"></a>02010                 <a class="code" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e" title="Destroy a previously created endpoint.">udc_ep_destroy</a>(udc, in);
<a name="l02011"></a>02011         <span class="keywordflow">if</span> (out &gt; 0)
<a name="l02012"></a>02012                 <a class="code" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e" title="Destroy a previously created endpoint.">udc_ep_destroy</a>(udc, out);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         <a class="code" href="group__dmapool__generic__group.html#ga70ff9a0bae4405abdf0d4e7a05754850" title="Free an object to the generic DMA pools.">dma_free</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l02015"></a>02015         <a class="code" href="group__dmapool__generic__group.html#ga70ff9a0bae4405abdf0d4e7a05754850" title="Free an object to the generic DMA pools.">dma_free</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a7e2bc8a9cdadf062fa5c2e217421abb1" title="The Command Status Wrapper.">csw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__csw.html" title="A Command Status Wrapper (CSW).">usb_msc_csw</a>));
<a name="l02016"></a>02016         <a class="code" href="group__buffer__group.html#ga892382a3cd2784fff8946f734d732de6" title="Free the buffer structure buf.">buffer_free</a>(<a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>));
<a name="l02017"></a>02017         <a class="code" href="group__usb__request__group.html#gac2bb3937a7eeea0554a6b62c8738e20c" title="Free a USB request structure.">usb_req_free</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>);
<a name="l02018"></a>02018         <a class="code" href="group__block__device__group.html#ga70412d7195c030d5d8be509d3cf19bea" title="Free a block request previously allocated using block_alloc_request().">block_free_request</a>(msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a>, msc-&gt;<a class="code" href="structmsc__interface.html#ab1781003dfc999f6cd0e8e10aa1ddbe2" title="Block request used for doing block data transfers via bdev.">block_req</a>);
<a name="l02019"></a>02019 }
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 <span class="keyword">static</span> <span class="keywordtype">int</span> msc_bulk_reset(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> *msc)
<a name="l02022"></a>02022 {
<a name="l02023"></a>02023         <span class="keyword">struct </span><a class="code" href="structusb__request.html" title="A USB request.">usb_request</a>      *req;
<a name="l02024"></a>02024         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l02025"></a>02025 
<a name="l02026"></a>02026         <a class="code" href="group__debug__console.html#ga7ea40a3701ec24dfbb88fb1a74c9d8f2" title="Display an informational message.">dbg_info</a>(<span class="stringliteral">&quot;MSC Bulk Reset\n&quot;</span>);
<a name="l02027"></a>02027 
<a name="l02028"></a>02028         <span class="comment">/*</span>
<a name="l02029"></a>02029 <span class="comment">         * Flush and un-wedge the endpoints. They will still be</span>
<a name="l02030"></a>02030 <span class="comment">         * halted, so the host must still do ClearFeature(HALT) on</span>
<a name="l02031"></a>02031 <span class="comment">         * both endpoints as per section 5.3.4 in the MSC Bulk-Only</span>
<a name="l02032"></a>02032 <span class="comment">         * spec.</span>
<a name="l02033"></a>02033 <span class="comment">         */</span>
<a name="l02034"></a>02034         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a> &gt; 0) {
<a name="l02035"></a>02035                 <a class="code" href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1" title="Terminate all pending requests on an endpoint.">udc_ep_flush</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>);
<a name="l02036"></a>02036                 <a class="code" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c" title="Clear the wedged state of an endpoint.">udc_ep_clear_wedge</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a26ab64a95cb1348b0776a19e4f85d8b2" title="Bulk-IN endpoint used for data transfer.">bulk_in_ep</a>);
<a name="l02037"></a>02037         }
<a name="l02038"></a>02038         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a> &gt; 0) {
<a name="l02039"></a>02039                 <a class="code" href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1" title="Terminate all pending requests on an endpoint.">udc_ep_flush</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>);
<a name="l02040"></a>02040                 <a class="code" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c" title="Clear the wedged state of an endpoint.">udc_ep_clear_wedge</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>);
<a name="l02041"></a>02041         }
<a name="l02042"></a>02042 
<a name="l02043"></a>02043         <a class="code" href="group__udi__msc__bulk__group.html#ga59e038545f82e8c3c45e5a8e81e8bb6e" title="Current transfer is done; run any registered busy callback functions and clear it...">msc_queue_empty</a>(msc);
<a name="l02044"></a>02044 
<a name="l02045"></a>02045         <span class="comment">/* Now, submit a new CBW and keep going */</span>
<a name="l02046"></a>02046         req = msc-&gt;<a class="code" href="structmsc__interface.html#a09658cc6ff7b1515b7263e6744df0b3c" title="USB request used for transfering the CBW and CSW.">cbw_csw_req</a>;
<a name="l02047"></a>02047         buf = <a class="code" href="group__usb__request__group.html#gaf03d5f48278f6384a9ac54999f42f7cd" title="Return the first buffer associated with req.">usb_req_get_first_buffer</a>(req);
<a name="l02048"></a>02048         <a class="code" href="group__usb__request__group.html#ga94fdae85da696787911c520913048a78" title="Initialize a USB request.">usb_req_init</a>(req);
<a name="l02049"></a>02049 
<a name="l02050"></a>02050         <a class="code" href="group__buffer__group.html#ga48a5f5cf02679d5f06e8a709b0e1d987" title="Initialize an already-DMA-mapped buffer for receiving data.">buffer_init_rx_mapped</a>(buf, msc-&gt;<a class="code" href="structmsc__interface.html#a35b0c36d6d18ca8a59686d8341074273" title="The Command Block Wrapper.">cbw</a>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusb__msc__cbw.html" title="A Command Block Wrapper (CBW).">usb_msc_cbw</a>));
<a name="l02051"></a>02051         <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l02052"></a>02052         req-&gt;<a class="code" href="structusb__request.html#a8d437c59170791ca1598e440a4d4a353" title="Function to be called when this request is completed.">req_done</a> = msc_cbw_received;
<a name="l02053"></a>02053 
<a name="l02054"></a>02054         <a class="code" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8" title="Submit an OUT request on a non-control endpoint.">udc_ep_submit_out_req</a>(udc, msc-&gt;<a class="code" href="structmsc__interface.html#a82eca106669a893f29213b0a6f1c452b" title="Bulk-OUT endpoint used for data transfer.">bulk_out_ep</a>, req);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         <span class="keywordflow">return</span> 0;
<a name="l02057"></a>02057 }
<a name="l02058"></a>02058 
<a name="l02072"></a>02072 <a class="code" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e" title="Status return value.">status_t</a> <a class="code" href="group__udi__msc__bulk__group.html#ga1646e211f83bcde9929137f08ad26cb2" title="Handle a setup request directed at the MSC interface.">udi_msc_setup</a>(<span class="keyword">struct</span> udc *udc, <span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface,
<a name="l02073"></a>02073                 <span class="keyword">struct</span> <a class="code" href="structusb__setup__req.html" title="A USB Device SETUP request.">usb_setup_req</a> *req)
<a name="l02074"></a>02074 {
<a name="l02075"></a>02075         <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a>        value = <a class="code" href="group__byte__order__group.html#ga687180d38fb1df3756a55129bc2bc843" title="Convert a 16-bit word from little endian to native byte order.">le16_to_cpu</a>(req-&gt;wValue);
<a name="l02076"></a>02076         <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a>        <a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a> = <a class="code" href="group__byte__order__group.html#ga687180d38fb1df3756a55129bc2bc843" title="Convert a 16-bit word from little endian to native byte order.">le16_to_cpu</a>(req-&gt;wLength);
<a name="l02077"></a>02077         <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a>         byte;
<a name="l02078"></a>02078 
<a name="l02079"></a>02079         <span class="keywordflow">if</span> (<a class="code" href="group__usb__protocol__group.html#ga75f3346a526996ab3458b675e956df0d" title="Return the type of the SETUP request req.">usb_setup_type</a>(req) != <a class="code" href="group__usb__protocol__group.html#gga36b2b70fae97945b76c666573a8ff4b3ab41eb84803ae7a7c4cdd7183dd8e61e1" title="Class-specific request.">USB_REQTYPE_CLASS</a>)
<a name="l02080"></a>02080                 <span class="keywordflow">return</span> -1;
<a name="l02081"></a>02081 
<a name="l02082"></a>02082         <span class="keywordflow">switch</span> (req-&gt;bRequest) {
<a name="l02083"></a>02083         <span class="keywordflow">case</span> <a class="code" href="group__msc__protocol__group.html#ggafe6dd9887c6fb1764c5117c4cf73ef1aaeb84682334c179de5baeca246ba906e5" title="Mass Storage Reset.">USB_MSC_REQ_BULK_RESET</a>:
<a name="l02084"></a>02084                 <span class="keywordflow">if</span> (len || value || <a class="code" href="group__usb__protocol__group.html#ga2884802a16f19b932f7b5da8b199ea4a" title="Return true if the setup request req indicates IN data transfer.">usb_setup_is_in</a>(req))
<a name="l02085"></a>02085                         <span class="keywordflow">return</span> -1;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087                 <span class="keywordflow">if</span> (msc_bulk_reset(udc, msc_interface_of(iface)))
<a name="l02088"></a>02088                         <span class="keywordflow">return</span> -1;
<a name="l02089"></a>02089 
<a name="l02090"></a>02090                 <a class="code" href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4" title="Send a status IN packet on the default control endpoint.">udc_ep0_send_status</a>(udc);
<a name="l02091"></a>02091                 <span class="keywordflow">break</span>;
<a name="l02092"></a>02092 
<a name="l02093"></a>02093         <span class="keywordflow">case</span> <a class="code" href="group__msc__protocol__group.html#ggafe6dd9887c6fb1764c5117c4cf73ef1aa9c681a8d81acce518f6cd8af1cb72d0c" title="Get Max LUN.">USB_MSC_REQ_GET_MAX_LUN</a>:
<a name="l02094"></a>02094                 <span class="keywordflow">if</span> (len != 1 || value || <a class="code" href="group__usb__protocol__group.html#ga67761209b192e168d2281dfd233c120a" title="Return true if the setup request req indicates OUT data transfer.">usb_setup_is_out</a>(req))
<a name="l02095"></a>02095                         <span class="keywordflow">return</span> -1;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097                 <span class="comment">/* TODO: Support multiple LUNs */</span>
<a name="l02098"></a>02098                 byte = 0;
<a name="l02099"></a>02099                 <a class="code" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb" title="Transmit IN data on the default control endpoint synchronously.">udc_ep0_write_sync</a>(udc, &amp;byte, <span class="keyword">sizeof</span>(byte));
<a name="l02100"></a>02100                 <a class="code" href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c" title="Signal that a status OUT packet is expected on the default control endpoint.">udc_ep0_expect_status</a>(udc);
<a name="l02101"></a>02101                 <span class="keywordflow">break</span>;
<a name="l02102"></a>02102 
<a name="l02103"></a>02103         <span class="keywordflow">default</span>:
<a name="l02104"></a>02104                 <span class="keywordflow">return</span> -1;
<a name="l02105"></a>02105         }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107         <span class="keywordflow">return</span> 0;
<a name="l02108"></a>02108 }
<a name="l02109"></a>02109 
<a name="l02130"></a>02130 <a class="code" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e" title="Status return value.">status_t</a> <a class="code" href="group__udi__msc__bulk__group.html#ga3263d063a22ef3ae95664f955d7077a4" title="Get the interface descriptor for the MSC interface.">udi_msc_get_iface_descriptor</a>(<span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface,
<a name="l02131"></a>02131                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req, <span class="keyword">enum</span> <a class="code" href="group__usb__protocol__group.html#ga59ba7bbb99177a622f3c073fc48b7bc5" title="USB device speed.">usb_device_speed</a> speed,
<a name="l02132"></a>02132                 <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a> len)
<a name="l02133"></a>02133 {
<a name="l02134"></a>02134         <span class="keyword">struct </span>msc_iface_desc   *desc;
<a name="l02135"></a>02135         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>           *buf;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137         <span class="keywordflow">if</span> (!len)
<a name="l02138"></a>02138                 <span class="comment">/* Just report the total length */</span>
<a name="l02139"></a>02139                 <span class="keywordflow">goto</span> out;
<a name="l02140"></a>02140 
<a name="l02141"></a>02141         buf = buffer_dma_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msc_iface_desc));
<a name="l02142"></a>02142         desc = buf-&gt;<a class="code" href="structbuffer.html#ab403c7e5ef17f099f36f10578e8ca1e7">addr</a>.<a class="code" href="uniondma__addr__t.html#a4926bd45b0b4ed6696524da7226e835e" title="Virtual address.">ptr</a>;
<a name="l02143"></a>02143 
<a name="l02144"></a>02144         <span class="comment">/* Copy the template as a starting point */</span>
<a name="l02145"></a>02145         <a class="code" href="group__string__group.html#gaba088e716bccbc96d42da97e96316df1" title="Copy memory area.">memcpy</a>(desc, &amp;msc_desc_template, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msc_iface_desc));
<a name="l02146"></a>02146 
<a name="l02147"></a>02147         <span class="comment">/* Then, fix up a few values known only at run-time */</span>
<a name="l02148"></a>02148         desc-&gt;iface.bInterfaceNumber = iface-&gt;<a class="code" href="structudm__interface.html#a288bd5eb2855c8bde14d65275788747a" title="The interface number identifying this interface.">iface_number</a>;
<a name="l02149"></a>02149 <span class="preprocessor">#ifdef CONFIG_UDC_HIGH_SPEED</span>
<a name="l02150"></a>02150 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (speed == <a class="code" href="group__usb__protocol__group.html#gga59ba7bbb99177a622f3c073fc48b7bc5a57eeede6d769b09c01ac9c9c62fef8c9" title="High speed (480 Mb/s).">USB_SPEED_HIGH</a>) {
<a name="l02151"></a>02151                 <span class="comment">/* Only allowed value for high-speed bulk endpoints */</span>
<a name="l02152"></a>02152                 desc-&gt;ep[0].wMaxPacketSize = <a class="code" href="group__byte__order__group.html#ga54d648861a1120a3f8d6255e9cf54125" title="Create a 16-bit little endian constant.">LE16</a>(512);
<a name="l02153"></a>02153                 desc-&gt;ep[1].wMaxPacketSize = <a class="code" href="group__byte__order__group.html#ga54d648861a1120a3f8d6255e9cf54125" title="Create a 16-bit little endian constant.">LE16</a>(512);
<a name="l02154"></a>02154         }
<a name="l02155"></a>02155 <span class="preprocessor">#endif</span>
<a name="l02156"></a>02156 <span class="preprocessor"></span>
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msc_iface_desc))
<a name="l02158"></a>02158                 <a class="code" href="group__buffer__group.html#ga7d7894a1f84fcf9a2d1f2f1a6f3ed133" title="Resize the buffer pointed to by buf. The caller must make sure the new size fit into...">buffer_resize</a>(buf, len);
<a name="l02159"></a>02159 
<a name="l02160"></a>02160         <a class="code" href="group__usb__request__group.html#ga26a25fb6b9fc952dd70b838d8586c0ae" title="Add a buffer to a USB request.">usb_req_add_buffer</a>(req, buf);
<a name="l02161"></a>02161 
<a name="l02162"></a>02162 out:
<a name="l02163"></a>02163         <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keyword">struct </span>msc_iface_desc);
<a name="l02164"></a>02164 }
<a name="l02165"></a>02165 
<a name="l02182"></a>02182 <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#ga68412851d42283e276895891a365a97f" title="Free the memory allocated by msc_get_iface_descriptor().">udi_msc_free_descriptor</a>(<span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface,
<a name="l02183"></a>02183                 <span class="keyword">struct</span> <a class="code" href="structusb__request.html" title="A USB request.">usb_request</a> *req)
<a name="l02184"></a>02184 {
<a name="l02185"></a>02185         <span class="keyword">struct </span><a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>   *buf;
<a name="l02186"></a>02186 
<a name="l02187"></a>02187         buf = <a class="code" href="slist_8h.html#a731714a0d75bc68ff1ecea1e921f9e17" title="Return the first item in list and remove it.">slist_pop_head</a>(&amp;req-&gt;<a class="code" href="structusb__request.html#ad8d283292cbc9e9706fd85f218accf2c" title="List of buffers associated with this request.">buf_list</a>, <span class="keyword">struct</span> <a class="code" href="structbuffer.html" title="A generic data buffer.">buffer</a>, <a class="code" href="structbuffer.html#acbbd1843f34b7bf1d832b9a2a7215305">node</a>);
<a name="l02188"></a>02188         <a class="code" href="group__assert__group.html#gacdcc5aaebf3f273c1762f24a6ece2e5e" title="Assert that condition is true at run time.">assert</a>(buf-&gt;<a class="code" href="structbuffer.html#a2966e19c7a1355df268a743450746f8e">len</a> &lt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msc_iface_desc));
<a name="l02189"></a>02189         buffer_dma_free(buf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msc_iface_desc));
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 
<a name="l02205"></a>02205 <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#gaee7b3d70246be935e832b1c82998a0a8" title="Reject data transfer requests.">udi_msc_set_busy</a>(<span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface, <a class="code" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505" title="16-bit unsigned integer">uint16_t</a> asc,
<a name="l02206"></a>02206                 <span class="keywordtype">void</span> (*queue_empty)(<span class="keywordtype">void</span> *data), <span class="keywordtype">void</span> *data)
<a name="l02207"></a>02207 {
<a name="l02208"></a>02208         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = msc_interface_of(iface);
<a name="l02209"></a>02209         <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a59a24f6c541d2c1b20d7c897ed7bdbca" title="Type used for holding the current interrupt state.">irqflags_t</a>              iflags;
<a name="l02210"></a>02210 
<a name="l02211"></a>02211         iflags = <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#ad0c5a270013dca8848f9902ec131c51f" title="Save the current interrupt state and disable interrupts.">cpu_irq_save</a>();
<a name="l02212"></a>02212         msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a> = <span class="keyword">true</span>;
<a name="l02213"></a>02213         msc-&gt;<a class="code" href="structmsc__interface.html#ae6c0510ec0978fdfcf429215e8d5a49c" title="Additional Sense Code (Qualifier) set by usb_msc_set_busy().">busy_asc</a> = asc;
<a name="l02214"></a>02214         <a class="code" href="group__debug__console.html#ga92394a5c4bbfe2864b7ea1cb488cd3dd" title="Display a verbose debugging message.">dbg_verbose</a>(<span class="stringliteral">&quot;msc_set_busy: ASC(Q) %04x in_progress: %d\n&quot;</span>,
<a name="l02215"></a>02215                         asc, msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a>);
<a name="l02216"></a>02216         <span class="keywordflow">if</span> (msc-&gt;<a class="code" href="structmsc__interface.html#a5546cfac576a34a49f93d832ce4f5d29" title="True if there&amp;#39;s currently a block data transfer in progress.">xfer_in_progress</a>) {
<a name="l02217"></a>02217                 msc-&gt;<a class="code" href="structmsc__interface.html#a9cf8c12a3207466033c03665a82c0e75" title="Function to be called when the MSC interface has been blocked.">busy_cb</a> = queue_empty;
<a name="l02218"></a>02218                 msc-&gt;<a class="code" href="structmsc__interface.html#acbcf8e493e2eadbf9f1b3f0085df9121" title="Arbitrary data to be passed to busy_cb().">busy_cb_data</a> = data;
<a name="l02219"></a>02219                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l02220"></a>02220         } <span class="keywordflow">else</span> {
<a name="l02221"></a>02221                 <a class="code" href="arch_2avr8_2include_2arch_2interrupt_8h.html#a7a4dcaf82a88398e7da6fe6099ebfc10" title="Restore saved interrupt state.">cpu_irq_restore</a>(iflags);
<a name="l02222"></a>02222                 queue_empty(data);
<a name="l02223"></a>02223         }
<a name="l02224"></a>02224 }
<a name="l02225"></a>02225 
<a name="l02232"></a>02232 <span class="keywordtype">void</span> <a class="code" href="group__udi__msc__bulk__group.html#ga36fdd4cc1be759ef4924adda041333a8" title="Allow data transfer requests.">udi_msc_set_ready</a>(<span class="keyword">struct</span> <a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *iface)
<a name="l02233"></a>02233 {
<a name="l02234"></a>02234         <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a>    *msc = msc_interface_of(iface);
<a name="l02235"></a>02235 
<a name="l02236"></a>02236         msc-&gt;<a class="code" href="structmsc__interface.html#a85adf1f0c3189b1350590bd47c5c2576" title="True if all block data transfer requests are to be blocked.">not_ready</a> = <span class="keyword">false</span>;
<a name="l02237"></a>02237 }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> <a class="code" href="structmsc__interface.html" title="A Mass Storage Class interface instance.">msc_interface</a> = {
<a name="l02240"></a>02240         .iface.iface_number             = APP_UDI_MSC_INTERFACE_ID,
<a name="l02241"></a>02241         .iface.enable                   = <a class="code" href="group__udi__msc__bulk__group.html#ga4553198d0be4a11de619faf776985e5b" title="Enable the MSC interface.">udi_msc_enable</a>,
<a name="l02242"></a>02242         .iface.disable                  = <a class="code" href="group__udi__msc__bulk__group.html#ga816fbbe98af5d7a3b7a414ca3715985f" title="Disable the MSC interface.">udi_msc_disable</a>,
<a name="l02243"></a>02243         .iface.setup                    = <a class="code" href="group__udi__msc__bulk__group.html#ga1646e211f83bcde9929137f08ad26cb2" title="Handle a setup request directed at the MSC interface.">udi_msc_setup</a>,
<a name="l02244"></a>02244         .iface.get_iface_descriptor     = <a class="code" href="group__udi__msc__bulk__group.html#ga3263d063a22ef3ae95664f955d7077a4" title="Get the interface descriptor for the MSC interface.">udi_msc_get_iface_descriptor</a>,
<a name="l02245"></a>02245         .iface.free_descriptor          = <a class="code" href="group__udi__msc__bulk__group.html#ga68412851d42283e276895891a365a97f" title="Free the memory allocated by msc_get_iface_descriptor().">udi_msc_free_descriptor</a>,
<a name="l02246"></a>02246 };
<a name="l02247"></a>02247 
<a name="l02248"></a>02248 <span class="keyword">struct </span><a class="code" href="structudm__interface.html" title="A USB device interface.">udm_interface</a> *udi_msc_create_iface(<span class="keyword">struct</span> <a class="code" href="structblock__device.html" title="A block device.">block_device</a> *bdev)
<a name="l02249"></a>02249 {
<a name="l02250"></a>02250         <span class="keyword">struct </span>msc_interface    *msc = &amp;msc_interface;
<a name="l02251"></a>02251 
<a name="l02252"></a>02252         msc-&gt;<a class="code" href="structmsc__interface.html#a12c03498fc1a6be096a9d321d99cb7d4" title="The block device used for storage.">bdev</a> = bdev;
<a name="l02253"></a>02253 
<a name="l02254"></a>02254         <a class="code" href="group__assert__group.html#ga0fae3864357c8f0ddad905cf5c838766" title="Assert that condition is true at build time.">build_assert</a>(CONFIG_DMAPOOL_SMALL_OBJ_SIZE % 4 == 0);
<a name="l02255"></a>02255         <a class="code" href="group__assert__group.html#ga0fae3864357c8f0ddad905cf5c838766" title="Assert that condition is true at build time.">build_assert</a>(MSC_DATA_BUFFER_SIZE % 512 == 0);
<a name="l02256"></a>02256 
<a name="l02257"></a>02257         msc-&gt;<a class="code" href="structmsc__interface.html#a0b0491ed96c71119204c2cf6d6aa9942" title="Buffer holding the current sense information.">sense_data</a> = <a class="code" href="group__dmapool__generic__group.html#ga3aa00b0494ff313396081bddfb87bbaf" title="Allocate an object from the generic DMA pools.">dma_alloc</a>(32);
<a name="l02258"></a>02258         msc_init_sense(msc, SCSI_SK_NO_SENSE,
<a name="l02259"></a>02259                         SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
<a name="l02260"></a>02260 
<a name="l02261"></a>02261         <span class="keywordflow">return</span> &amp;msc-&gt;<a class="code" href="structmsc__interface.html#a841e5bab694085809bb325be050e0cde" title="Interface object registered with the UDM layer.">iface</a>;
<a name="l02262"></a>02262 }
<a name="l02263"></a>02263 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:34 2010 for xplain-bc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
