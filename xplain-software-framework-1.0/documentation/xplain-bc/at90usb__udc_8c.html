<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xplain-bc: drivers/usb/at90usb/at90usb_udc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>drivers/usb/at90usb/at90usb_udc.c File Reference</h1>
<p>AT90USB driver: Device part.  
<a href="#_details">More...</a></p>
<code>#include &lt;<a class="el" href="assert_8h_source.html">assert.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="arch_2avr8_2include_2arch_2byteorder_8h_source.html">byteorder.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="arch_2avr8_2include_2arch_2bitops_8h_source.html">bitops.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="debug_8h_source.html">debug.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html">interrupt.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="cpu_2mega_2include_2cpu_2io_8h_source.html">io.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="status__codes_8h_source.html">status_codes.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="arch_2avr8_2include_2arch_2string_8h_source.html">string.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8h_source.html">util.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="workqueue_8h_source.html">workqueue.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="request_8h_source.html">usb/request.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="dev_8h_source.html">usb/dev.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="udc_8h_source.html">usb/udc.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="udc__lib_8h_source.html">usb/udc_lib.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="chip_2at90usb1287_2include_2chip_2regs_8h_source.html">chip/regs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="memory-map_8h_source.html">chip/memory-map.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="at90usb_8h_source.html">chip/at90usb.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="usb_8h_source.html">app/usb.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="at90usb__internal_8h_source.html">at90usb_internal.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="at90usb__regs_8h_source.html">at90usb_regs.h</a>&quot;</code><br/>

<p><a href="at90usb__udc_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="at90usb__udc_8c.html#a172d371507538475ed18b02a068bbee6">copy_from_fifo</a> (<a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *dest, const unsigned int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to read data from the USB fifo.  <a href="#a172d371507538475ed18b02a068bbee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="at90usb__udc_8c.html#a4cde81e3e50ecd95a4f453fddf29fd35">copy_to_fifo</a> (const <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *source, const unsigned int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to write data to the USB fifo.  <a href="#a4cde81e3e50ecd95a4f453fddf29fd35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga0e274c65a81866c3d2be02acef2dc19b">at90usb_udc_of</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC instance from the UDC instance.  <a href="group__udc__group.html#ga0e274c65a81866c3d2be02acef2dc19b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae3a97246cb9f6a8c153c959e42bfec8a">at90usb_udc_task_of</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC instance from the work queue task.  <a href="group__udc__group.html#gae3a97246cb9f6a8c153c959e42bfec8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga9c4eb1b1c9dbf576bdba697d0d0a503c">at90usb_ep_task_of</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function get the AT90USB UDC endpoint instance from the work queue task.  <a href="group__udc__group.html#ga9c4eb1b1c9dbf576bdba697d0d0a503c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga05c55cf772b2bd23ef69d1c7f96a170f">at90usb_udc_req_done</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req, enum <a class="el" href="status__codes_8h.html#a751c892e5a46b8e7d282085a5a5bf151">status_code</a> status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to complete USB requests.  <a href="group__udc__group.html#ga05c55cf772b2bd23ef69d1c7f96a170f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga14ae76e5703f4a028eb74a3e27e6386a">at90usb_udc_kill_last_in_bank</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill last bank for an IN endpoint.  <a href="group__udc__group.html#ga14ae76e5703f4a028eb74a3e27e6386a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaaf024b83041fef2cc4583266208f6f8d">at90usb_udc_kill_first_out_bank</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill first bank for an OUT endpoint.  <a href="group__udc__group.html#gaaf024b83041fef2cc4583266208f6f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gab5725db2aa292947c86103384b020b20">at90usb_udc_kill_all_banks</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill all banks for an endpoint.  <a href="group__udc__group.html#gab5725db2aa292947c86103384b020b20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga676404d5ebf88ace9198087b7f3a7d96">at90usb_udc_submit_out_queue</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit queued buffers on a non-control OUT endpoint.  <a href="group__udc__group.html#ga676404d5ebf88ace9198087b7f3a7d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga8a24f9ab27b20edf91a615a8dc7d6827">at90usb_udc_submit_in_queue</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit queued buffers on a non-control IN endpoint.  <a href="group__udc__group.html#ga8a24f9ab27b20edf91a615a8dc7d6827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga5e7d0a463fdd3ed9746c9407a415e94f">at90usb_udc_configure_ep</a> (<a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> id, unsigned int size, enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a> type, bool is_in, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> nr_banks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6328c79258bd7e3d0a72d567085bb376">at90usb_udc_ep_flush</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a non-control endpoint.  <a href="group__udc__group.html#ga6328c79258bd7e3d0a72d567085bb376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga108f50ed23919eb40c99ed65ebd74bf1">at90usb_ep_alloc</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a non-control endpoint.  <a href="group__udc__group.html#ga108f50ed23919eb40c99ed65ebd74bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gac09a8f7ed37fc643349a130c6bea4493">at90usb_ep_enable</a> (struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size, enum <a class="el" href="group__usb__protocol__group.html#ga444fab460abae3addb8dae7c91cc205a">usb_ep_xfer_type</a> type, unsigned int nr_banks)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a non-control endpoint.  <a href="group__udc__group.html#gac09a8f7ed37fc643349a130c6bea4493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3f15e69c9dc7e634c3b2590794001b23">at90usb_ep0_tx_complete</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to complete control endpoint USB requests.  <a href="group__udc__group.html#ga3f15e69c9dc7e634c3b2590794001b23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad7cba985928cb085720d9cbe04181d62">at90usb_ep0_tx_flush</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structat90usb__udc__ep.html">at90usb_udc_ep</a> *ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a control endpoint.  <a href="group__udc__group.html#gad7cba985928cb085720d9cbe04181d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga74a51950da640f02c4f2ea0165d10f77">at90usb_udc_ep0_worker</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AT90USB UDC endpoint 0 work task handler.  <a href="group__udc__group.html#ga74a51950da640f02c4f2ea0165d10f77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gab3ac20ad17c55adbf11ca7c9a9412e72">at90usb_udc_device_worker</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AT90USB device-mode device work task handler.  <a href="group__udc__group.html#gab3ac20ad17c55adbf11ca7c9a9412e72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga5b5f2f4dacfb05c9b2845f0e73d35179">at90usb_udc_maybe_attach</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to let the UDC maybe attach to the USB bus.  <a href="group__udc__group.html#ga5b5f2f4dacfb05c9b2845f0e73d35179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaeb111aec2d97920194a548f697ff346c">at90usb_udc_detach</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to let the UDC detach from the USB bus.  <a href="group__udc__group.html#gaeb111aec2d97920194a548f697ff346c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gabf8d919c60a8135a89d37e3036cfb459">at90usb_udc_vbus_on</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a high Vbus level has been detected.  <a href="group__udc__group.html#gabf8d919c60a8135a89d37e3036cfb459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga59d6920f3d1da0b8c3f5eeecac367589">at90usb_udc_vbus_off</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a low Vbus level has been detected.  <a href="group__udc__group.html#ga59d6920f3d1da0b8c3f5eeecac367589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3cff978366b61d760e6163154af4c8f6">at90usb_udc_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the device part of the AT90USB controller.  <a href="group__udc__group.html#ga3cff978366b61d760e6163154af4c8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga260d2f316b9a1bbc5e0f528a337f3015">at90usb_udc_shutdown</a> (struct <a class="el" href="structat90usb__udc.html">at90usb_udc</a> *udc90)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the device part of the AT90USB controller.  <a href="group__udc__group.html#ga260d2f316b9a1bbc5e0f528a337f3015"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Control Transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0849e296709b2991e77d00a9cf8c03da"></a> The following functions are used to send and receive packets over the default control endpoint, ep0. Most functions are asynchronous and will call a callback function after the transfer is done. The only exception is <a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb" title="Transmit IN data on the default control endpoint synchronously.">udc_ep0_write_sync()</a>, which will write the data to the FIFO immediately and busy-wait until it has been sent. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga9cdaef38977d71d9f07297c01e3f48ff">udc_ep0_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on the default control endpoint.  <a href="group__udc__group.html#ga9cdaef38977d71d9f07297c01e3f48ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gad02048aa3cd26a0d5ffa8e06e312fb72">udc_ep0_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on the default control endpoint.  <a href="group__udc__group.html#gad02048aa3cd26a0d5ffa8e06e312fb72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb">udc_ep0_write_sync</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, const void *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit IN data on the default control endpoint synchronously.  <a href="group__udc__group.html#ga2e051f7d27b72d0893fa0eeb7d8fefdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4">udc_ep0_send_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a status IN packet on the default control endpoint.  <a href="group__udc__group.html#ga6869b8335d3c81e1dc5d9980d7508ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c">udc_ep0_expect_status</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that a status OUT packet is expected on the default control endpoint.  <a href="group__udc__group.html#gaf10c1032b3770d4168bca3279d99c53c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpff407869fe7ef829535c1645d170c29d"></a> The following functions are used to do non-control transfers, i.e. bulk, interrupt and isochronous transfers. Note that no synchronous functions are available -- the caller must always provide a callback if needed. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8">udc_ep_submit_out_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an OUT request on a non-control endpoint.  <a href="group__udc__group.html#ga51324a8221d7c149291c143e3fead2d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88">udc_ep_submit_in_req</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep, struct <a class="el" href="structusb__request.html">usb_request</a> *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit an IN request on a non-control endpoint.  <a href="group__udc__group.html#gaa37da30bf7ebcdaed7af050c1e33dc88"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2079b64d60bb0a4d375fcfbbc32aa9e1"></a> The following functions allow drivers to create and destroy endpoints, as well as set, clear and query their "halted" and "wedged" states.</p>
<p>Wedging an endpoint is useful when encountering errors that need some sort of error recovery procedure to be performed by the host. A wedged endpoint behaves like one that is halted, except that the host is prevented from clearing the halted state through the standard ClearFeature(HALT) request. This behaviour is required by the USB Mass Storage Bulk-Only Transport specification. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721">udc_ep_is_halted</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the endpoint <em>ep</em> is halted.  <a href="group__udc__group.html#ga2ec9be7752ca333042d0ff899b9e5721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa">udc_ep_set_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the halted state of the endpoint <em>ep</em>.  <a href="group__udc__group.html#ga4510f29bac8db1085da69b5eddeca9fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912">udc_ep_clear_halt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the halted state of the endpoint <em>ep</em>.  <a href="group__udc__group.html#ga3f6290667c4af5e9533fb92ccc60f912"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2e4e9c43d67cbcc9d3c010d181186543">udc_ep_is_wedged</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a given endpoint is wedged.  <a href="group__udc__group.html#ga2e4e9c43d67cbcc9d3c010d181186543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68">udc_ep_set_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the wedged state of an endpoint.  <a href="group__udc__group.html#ga183656813007f2e47da6dadde9933d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c">udc_ep_clear_wedge</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the wedged state of an endpoint.  <a href="group__udc__group.html#gacac13b6cbfe63354c49afec7edd5708c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1">udc_ep_flush</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate all pending requests on an endpoint.  <a href="group__udc__group.html#ga7540707886e611197bb211eb1054c5e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198">udc_ep_create_bulk</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Bulk endpoint.  <a href="group__udc__group.html#gae2348c0ec8c1ecac44e4e2df37316198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2f417ffb9582a4d689847f4962125689">udc_ep_create_interrupt</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> addr, <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> max_packet_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Interrupt endpoint.  <a href="group__udc__group.html#ga2f417ffb9582a4d689847f4962125689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e">udc_ep_destroy</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, <a class="el" href="group__udc__group.html#gaece2b19e35a4a25398b7e8a9f81f9d28">usb_ep_id_t</a> ep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a previously created endpoint.  <a href="group__udc__group.html#ga6460566ec4134dff8b55a98c3055a00e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">UDC Library Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp530537dcf7f15a51059ec25d8a26422e"></a> The following functions make up the interface between the UDC driver and the optional UDC library. The UDC library contains common helper functions for UDC drivers. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a933a3d656c26da40d944fa70ea43a72e">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga945f4e427b8ec40a3b8ef6f119abf2bb">udc_enter_test_mode</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>, unsigned int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter Test Mode.  <a href="group__udc__group.html#ga945f4e427b8ec40a3b8ef6f119abf2bb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Device State</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp05eddeb833f186c765df39f24486c1c8"></a> The following functions are used to query and modify the state of the USB device as a whole. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82">udc_attach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach <em>udc</em> to the bus when possible.  <a href="group__udc__group.html#gaf04e5a797dcee2ea5f0d436d65bffb82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udc__group.html#ga2fb2c7968f76bdf322f434682aa3343f">udc_detach</a> (struct <a class="el" href="structudc.html">udc</a> *<a class="el" href="structudc.html">udc</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach <em>udc</em> from the bus.  <a href="group__udc__group.html#ga2fb2c7968f76bdf322f434682aa3343f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>AT90USB driver: Device part. </p>
<p>This file implements a USB Device Controller (UDC) driver utilizing the AT90USB controller hardware.</p>
<p>Copyright (C) 2009 Atmel Corporation. All rights reserved. </p>

<p>Definition in file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a172d371507538475ed18b02a068bbee6"></a><!-- doxytag: member="at90usb_udc.c::copy_from_fifo" ref="a172d371507538475ed18b02a068bbee6" args="(uint8_t *dest, const unsigned int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void copy_from_fifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to read data from the USB fifo. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination to copy to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to read from the FIFO. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00092">92</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l00366">at90usb_udc_submit_out_queue()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cde81e3e50ecd95a4f453fddf29fd35"></a><!-- doxytag: member="at90usb_udc.c::copy_to_fifo" ref="a4cde81e3e50ecd95a4f453fddf29fd35" args="(const uint8_t *source, const unsigned int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void copy_to_fifo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to write data to the USB fifo. </p>
<p><b>For internal use only.</b></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The destination to copy from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes to write to the FIFO. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="at90usb__udc_8c_source.html#l00107">107</a> of file <a class="el" href="at90usb__udc_8c_source.html">at90usb_udc.c</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l01211">at90usb_udc_ep0_worker()</a>, and <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:34 2010 for xplain-bc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
