<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xplain-bc: Work Queue Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Work Queue Processing<br/>
<small>
[<a class="el" href="group__mainloop__group.html">Main Loop Processing</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Work Queue Processing:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__workqueue__group.png" border="0" alt="" usemap="#group____workqueue____group_map"/>
<map name="group____workqueue____group_map" id="group____workqueue____group">
<area shape="rect" href="group__mainloop__group.html" title="Main Loop Processing" alt="" coords="7,5,156,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworkqueue__task.html">workqueue_task</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task to be run from a work queue.  <a href="structworkqueue__task.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworkqueue.html">workqueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work queue.  <a href="structworkqueue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnested__workqueue.html">nested_workqueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nested Work Queue.  <a href="structnested__workqueue.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a> )(struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work queue worker function.  <a href="#ga6f87d44f234dedac9e96b0efa8ab4351"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gaba0573bf3d1a0201616ec03944ecfd41">workqueue_add_task</a> (struct <a class="el" href="structworkqueue.html">workqueue</a> *queue, struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add task to work queue.  <a href="#gaba0573bf3d1a0201616ec03944ecfd41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga4d686406ad32b591f19796692b81d6d7">workqueue_init</a> (struct <a class="el" href="structworkqueue.html">workqueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a work queue.  <a href="#ga4d686406ad32b591f19796692b81d6d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga3e86382d7bdc644fbc706e7d1ad1ce2d">workqueue_task_set_work_func</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task, <a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a> worker_func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the worker function of a task.  <a href="#ga3e86382d7bdc644fbc706e7d1ad1ce2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gac6ff4c2fe890595f39cd7d67ce8a26ed">workqueue_task_init</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task, <a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a> worker_func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a work queue task.  <a href="#gac6ff4c2fe890595f39cd7d67ce8a26ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gaadebd7202931e02931304e6678afd73b">workqueue_is_empty</a> (struct <a class="el" href="structworkqueue.html">workqueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a work queue is empty.  <a href="#gaadebd7202931e02931304e6678afd73b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga3fbd0d1260f9bc8754dae8c65a3d7478">workqueue_task_is_queued</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a work queue task has been queued.  <a href="#ga3fbd0d1260f9bc8754dae8c65a3d7478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gad65a79f0a8fa40992444b49fb0d6884d">workqueue_pop_task</a> (struct <a class="el" href="structworkqueue.html">workqueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove task from front of work queue.  <a href="#gad65a79f0a8fa40992444b49fb0d6884d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga4a2c49cbde69e983c25ebd3228a4937c">workqueue_run_task</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a work queue task.  <a href="#ga4a2c49cbde69e983c25ebd3228a4937c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structworkqueue.html">workqueue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga6c0de22a1ae8b7797e67df97f23f4707">main_workqueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main work queue.  <a href="#ga6c0de22a1ae8b7797e67df97f23f4707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structworkqueue.html">workqueue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#ga6c0de22a1ae8b7797e67df97f23f4707">main_workqueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main work queue.  <a href="#ga6c0de22a1ae8b7797e67df97f23f4707"></a><br/></td></tr>
<tr><td colspan="2"><h2>Nested Workqueues</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp05f4051f8d81b3f914f6dd0355aac8ea"></a> Nested workqueues are workqueues specific to certain shared resources, for example a bus driver which can only handle one request at a time. Such drivers may create a workqueue for keeping track of tasks wanting to use the shared resource, and move them one by one into the main workqueue. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gadd38acc207e3bfb0e8c17a59a7b875ba">nested_workqueue_add_task</a> (struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *nwq, struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add task to nested work queue.  <a href="#gadd38acc207e3bfb0e8c17a59a7b875ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gaace01054e8c6e9b4af76c58913c7a552">nested_workqueue_next_task</a> (struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *nwq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch to the next task in a nested work queue.  <a href="#gaace01054e8c6e9b4af76c58913c7a552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__group.html#gaea0fee77da48a27314a4fb67af23bdb5">nested_workqueue_init</a> (struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *wq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a nested workqueue.  <a href="#gaea0fee77da48a27314a4fb67af23bdb5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is a workqueue designed to simplify and formalize sequential execution of tasks. It provides a low overhead structure that can replace or extend the use of threads in simple applications. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga6f87d44f234dedac9e96b0efa8ab4351"></a><!-- doxytag: member="workqueue.h::workqueue_func_t" ref="ga6f87d44f234dedac9e96b0efa8ab4351" args=")(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a>)(struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Work queue worker function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The work queue task which is currently being executed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00063">63</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadd38acc207e3bfb0e8c17a59a7b875ba"></a><!-- doxytag: member="workqueue.c::nested_workqueue_add_task" ref="gadd38acc207e3bfb0e8c17a59a7b875ba" args="(struct nested_workqueue *nwq, struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nested_workqueue_add_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>nwq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add task to nested work queue. </p>
<p>This adds <em>task</em> to the nested work queue <em>nwq</em>. If there is no task currently active, i.e. nwq-&gt;current is NULL, the new task is immediately made active by moving it to the main workqueue and assigning it to nwq-&gt;current.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nwq</em>&nbsp;</td><td>A nested workqueue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Task to be added to the nested work queue</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The task was successfully queued </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The task has already been queued, so nothing was done </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="include_2spi_8h_source.html#l00223">spi_request_bus()</a>.</p>

</div>
</div>
<a class="anchor" id="gaea0fee77da48a27314a4fb67af23bdb5"></a><!-- doxytag: member="workqueue.h::nested_workqueue_init" ref="gaea0fee77da48a27314a4fb67af23bdb5" args="(struct nested_workqueue *wq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void nested_workqueue_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>wq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a nested workqueue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wq</em>&nbsp;</td><td>Nested workqueue to inititalize </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00255">255</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="workqueue_8h_source.html#l00247">nested_workqueue::current</a>, <a class="el" href="workqueue_8h_source.html#l00109">workqueue_init()</a>, and <a class="el" href="workqueue_8h_source.html#l00245">nested_workqueue::wq</a>.</p>

</div>
</div>
<a class="anchor" id="gaace01054e8c6e9b4af76c58913c7a552"></a><!-- doxytag: member="workqueue.c::nested_workqueue_next_task" ref="gaace01054e8c6e9b4af76c58913c7a552" args="(struct nested_workqueue *nwq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nested_workqueue_next_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnested__workqueue.html">nested_workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>nwq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Switch to the next task in a nested work queue. </p>
<p>This removes the task at the head of the nested work queue <em>nwq</em>, if any, and makes it current by adding it to the main workqueue and assigning it to nwq-&gt;current. If <em>nwq</em> is empty, nwq-&gt;current is set to NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nwq</em>&nbsp;</td><td>A nested workqueue </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="include_2spi_8h_source.html#l00236">spi_release_bus()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba0573bf3d1a0201616ec03944ecfd41"></a><!-- doxytag: member="workqueue.c::workqueue_add_task" ref="gaba0573bf3d1a0201616ec03944ecfd41" args="(struct workqueue *queue, struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool workqueue_add_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue.html">workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add task to work queue. </p>
<p>This function adds a task to a work queue. The task structure must be initialized by the caller, and only a pointer to it is stored in the queue. The caller must make sure the task struct is kept intact while in the queue and if necessary freed after running the task. The task is removed from the queue before the worker function is called, so it is safe to free or re-queue the task from the worker function.</p>
<p>If <em>task</em> has already been added to some work queue, or <em>task</em> is NULL, this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Work queue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Task to be added to <em>queue</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The task was successfully queued </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The task has already been queued, or is NULL, so nothing was done </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="main_8c_source.html#l00130">app_dataflash_ready()</a>, <a class="el" href="main_8c_source.html#l00073">app_usb_mode_worker()</a>, <a class="el" href="at90usb__core_8c_source.html#l00280">at90usb_ep_interrupt()</a>, <a class="el" href="at90usb__core_8c_source.html#l00230">at90usb_generic_interrupt()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00586">dataflash_detect()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00514">dataflash_submit_buf_list()</a>, <a class="el" href="spi__mega__xmega_8c_source.html#l00102">spi_poll()</a>, <a class="el" href="spi__polled_8h_source.html#l00153">spi_polled_sched_next_buffer()</a>, and <a class="el" href="spi__polled_8h_source.html#l00139">spi_polled_sched_poll()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d686406ad32b591f19796692b81d6d7"></a><!-- doxytag: member="workqueue.h::workqueue_init" ref="ga4d686406ad32b591f19796692b81d6d7" args="(struct workqueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void workqueue_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue.html">workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a work queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The work queue to be initialized </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00109">109</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="slist_8h_source.html#l00075">slist_init()</a>, and <a class="el" href="workqueue_8h_source.html#l00085">workqueue::task_list</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00148">main()</a>, and <a class="el" href="workqueue_8h_source.html#l00255">nested_workqueue_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaadebd7202931e02931304e6678afd73b"></a><!-- doxytag: member="workqueue.h::workqueue_is_empty" ref="gaadebd7202931e02931304e6678afd73b" args="(struct workqueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool workqueue_is_empty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue.html">workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a work queue is empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Work queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true <em>queue</em> is empty (i.e. has no tasks ready to run) </dd>
<dd>
false <em>queue</em> has at least one task ready to run </dd></dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00161">161</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="slist_8h_source.html#l00087">slist_is_empty()</a>, and <a class="el" href="workqueue_8h_source.html#l00085">workqueue::task_list</a>.</p>

<p>Referenced by <a class="el" href="workqueue_8h_source.html#l00198">workqueue_pop_task()</a>.</p>

</div>
</div>
<a class="anchor" id="gad65a79f0a8fa40992444b49fb0d6884d"></a><!-- doxytag: member="workqueue.h::workqueue_pop_task" ref="gad65a79f0a8fa40992444b49fb0d6884d" args="(struct workqueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structworkqueue__task.html">workqueue_task</a>* workqueue_pop_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue.html">workqueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove task from front of work queue. </p>
<p>This function removes one task from the front of a work queue and returns a pointer to that item. The memory allocated to the item struct will not be freed. If the queue is empty, a NULL pointer will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Work queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the task that was removed, or NULL if <em>queue</em> is empty.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Interrupts are disabled </dd></dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00198">198</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00091">cpu_irq_is_enabled</a>, <a class="el" href="slist_8h_source.html#l00053">slist_node::next</a>, <a class="el" href="workqueue_8h_source.html#l00074">workqueue_task::node</a>, <a class="el" href="slist_8h_source.html#l00300">slist_pop_head</a>, <a class="el" href="workqueue_8h_source.html#l00085">workqueue::task_list</a>, and <a class="el" href="workqueue_8h_source.html#l00161">workqueue_is_empty()</a>.</p>

<p>Referenced by <a class="el" href="mainloop_8h_source.html#l00063">mainloop_run()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a2c49cbde69e983c25ebd3228a4937c"></a><!-- doxytag: member="workqueue.h::workqueue_run_task" ref="ga4a2c49cbde69e983c25ebd3228a4937c" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void workqueue_run_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a work queue task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The work queue task to be run </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00222">222</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="workqueue_8h_source.html#l00073">workqueue_task::worker</a>.</p>

<p>Referenced by <a class="el" href="mainloop_8h_source.html#l00063">mainloop_run()</a>.</p>

</div>
</div>
<a class="anchor" id="gac6ff4c2fe890595f39cd7d67ce8a26ed"></a><!-- doxytag: member="workqueue.h::workqueue_task_init" ref="gac6ff4c2fe890595f39cd7d67ce8a26ed" args="(struct workqueue_task *task, workqueue_func_t worker_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void workqueue_task_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>worker_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a work queue task. </p>
<p>This function initialize a work queue task. It should be used before adding the task to any workqueue.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>task</em> is not queued on any work queue (not verified)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Work queue task to be initialized </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker_func</em>&nbsp;</td><td>Function implementing the task </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00144">144</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="slist_8h_source.html#l00053">slist_node::next</a>, <a class="el" href="workqueue_8h_source.html#l00074">workqueue_task::node</a>, and <a class="el" href="workqueue_8h_source.html#l00127">workqueue_task_set_work_func()</a>.</p>

<p>Referenced by <a class="el" href="at90usb__udc_8c_source.html#l00974">at90usb_ep_alloc()</a>, <a class="el" href="at90usb__udc_8c_source.html#l01634">at90usb_udc_init()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00531">dataflash_prepare_req()</a>, <a class="el" href="main_8c_source.html#l00148">main()</a>, and <a class="el" href="spi__polled_8h_source.html#l00184">spi_polled_buf_list_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fbd0d1260f9bc8754dae8c65a3d7478"></a><!-- doxytag: member="workqueue.h::workqueue_task_is_queued" ref="ga3fbd0d1260f9bc8754dae8c65a3d7478" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool workqueue_task_is_queued </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a work queue task has been queued. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td><em>task</em> has already been added to a workqueue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td><em>task</em> has not been added to any workqueue </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00175">175</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="slist_8h_source.html#l00053">slist_node::next</a>, and <a class="el" href="workqueue_8h_source.html#l00074">workqueue_task::node</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e86382d7bdc644fbc706e7d1ad1ce2d"></a><!-- doxytag: member="workqueue.h::workqueue_task_set_work_func" ref="ga3e86382d7bdc644fbc706e7d1ad1ce2d" args="(struct workqueue_task *task, workqueue_func_t worker_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void workqueue_task_set_work_func </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__group.html#ga6f87d44f234dedac9e96b0efa8ab4351">workqueue_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>worker_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the worker function of a task. </p>
<p>It is safe to call this function on tasks that have already been queued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Task to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker_func</em>&nbsp;</td><td>New worker function for the task </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="workqueue_8h_source.html#l00127">127</a> of file <a class="el" href="workqueue_8h_source.html">workqueue.h</a>.</p>

<p>References <a class="el" href="workqueue_8h_source.html#l00073">workqueue_task::worker</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00130">app_dataflash_ready()</a>, <a class="el" href="main_8c_source.html#l00148">main()</a>, and <a class="el" href="workqueue_8h_source.html#l00144">workqueue_task_init()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga6c0de22a1ae8b7797e67df97f23f4707"></a><!-- doxytag: member="workqueue.h::main_workqueue" ref="ga6c0de22a1ae8b7797e67df97f23f4707" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structworkqueue.html">workqueue</a> <a class="el" href="group__workqueue__group.html#ga6c0de22a1ae8b7797e67df97f23f4707">main_workqueue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main work queue. </p>
<p>This is the main work queue of the application. The main loop will pull tasks from this and execute them one by one. It can be considered a queue of tasks waiting to use the CPU resource; other workqueues will typically contend for some other resource, e.g. a SPI bus or flash device. </p>

<p>Definition at line <a class="el" href="workqueue_8c_source.html#l00047">47</a> of file <a class="el" href="workqueue_8c_source.html">workqueue.c</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00130">app_dataflash_ready()</a>, <a class="el" href="main_8c_source.html#l00073">app_usb_mode_worker()</a>, <a class="el" href="at90usb__core_8c_source.html#l00280">at90usb_ep_interrupt()</a>, <a class="el" href="at90usb__core_8c_source.html#l00230">at90usb_generic_interrupt()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00586">dataflash_detect()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00514">dataflash_submit_buf_list()</a>, <a class="el" href="main_8c_source.html#l00148">main()</a>, <a class="el" href="spi__mega__xmega_8c_source.html#l00102">spi_poll()</a>, <a class="el" href="spi__polled_8h_source.html#l00153">spi_polled_sched_next_buffer()</a>, and <a class="el" href="spi__polled_8h_source.html#l00139">spi_polled_sched_poll()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c0de22a1ae8b7797e67df97f23f4707"></a><!-- doxytag: member="workqueue.c::main_workqueue" ref="ga6c0de22a1ae8b7797e67df97f23f4707" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structworkqueue.html">workqueue</a> <a class="el" href="group__workqueue__group.html#ga6c0de22a1ae8b7797e67df97f23f4707">main_workqueue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main work queue. </p>
<p>This is the main work queue of the application. The main loop will pull tasks from this and execute them one by one. It can be considered a queue of tasks waiting to use the CPU resource; other workqueues will typically contend for some other resource, e.g. a SPI bus or flash device. </p>

<p>Definition at line <a class="el" href="workqueue_8c_source.html#l00047">47</a> of file <a class="el" href="workqueue_8c_source.html">workqueue.c</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00130">app_dataflash_ready()</a>, <a class="el" href="main_8c_source.html#l00073">app_usb_mode_worker()</a>, <a class="el" href="at90usb__core_8c_source.html#l00280">at90usb_ep_interrupt()</a>, <a class="el" href="at90usb__core_8c_source.html#l00230">at90usb_generic_interrupt()</a>, <a class="el" href="at90usb__udc_8c_source.html#l00496">at90usb_udc_submit_in_queue()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00586">dataflash_detect()</a>, <a class="el" href="drivers_2block_2dataflash_8c_source.html#l00514">dataflash_submit_buf_list()</a>, <a class="el" href="main_8c_source.html#l00148">main()</a>, <a class="el" href="spi__mega__xmega_8c_source.html#l00102">spi_poll()</a>, <a class="el" href="spi__polled_8h_source.html#l00153">spi_polled_sched_next_buffer()</a>, and <a class="el" href="spi__polled_8h_source.html#l00139">spi_polled_sched_poll()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:35 2010 for xplain-bc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
