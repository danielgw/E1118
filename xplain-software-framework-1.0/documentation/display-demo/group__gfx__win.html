<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>display-demo: Window System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Window System<br/>
<small>
[<a class="el" href="group__gfx.html">Graphical display system</a>]</small>
</h1>
<p>Window system for organizing window elements in a graphical user interface (GUI).  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Window System:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__gfx__win.png" border="0" alt="" usemap="#group____gfx____win_map"/>
<map name="group____gfx____win_map" id="group____gfx____win">
<area shape="rect" href="group__gfx.html" title="Graphical display system" alt="" coords="5,5,173,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__window.html">win_window</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Window control data.  <a href="structwin__window.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__event__queue.html">win_event_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event queue control struct.  <a href="structwin__event__queue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__point.html">win_point</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Geometric type describing a point or vector on screen, relative or absolute.  <a href="structwin__point.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__area.html">win_area</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Geometric type describing an area on screen.  <a href="structwin__area.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__clip__region.html">win_clip_region</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Geometric type describing a clipping region, used when drawing windows.  <a href="structwin__clip__region.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__pointer__event.html">win_pointer_event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event data for all pointer events, e.g. touch screen or mouse.  <a href="structwin__pointer__event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__keyboard__event.html">win_keyboard_event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event data for all keyboard events, e.g. full keyboards or smaller matrices.  <a href="structwin__keyboard__event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__command__event.html">win_command_event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event data for command events, e.g. a button widget action command.  <a href="structwin__command__event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__event.html">win_event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event data for all events.  <a href="structwin__event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwin__attributes.html">win_attributes</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Window attribute data.  <a href="structwin__attributes.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gac9ee551a42534b9ce1ca67318f48f257">WIN_ATTR_POSITION</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window position.  <a href="#gac9ee551a42534b9ce1ca67318f48f257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga0bbe2e4323615d774dcdc35626af27ec">WIN_ATTR_SIZE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window size.  <a href="#ga0bbe2e4323615d774dcdc35626af27ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga10cdd071efc236de8fc91cbde76965fe">WIN_ATTR_BACKGROUND</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window background type and color/pixmap.  <a href="#ga10cdd071efc236de8fc91cbde76965fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga5417f6d99f122c1277037946daac86a4">WIN_ATTR_EVENTHANDLER</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window event handler.  <a href="#ga5417f6d99f122c1277037946daac86a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga6a690e873a4d59dad0c61ef68f5956e4">WIN_ATTR_BEHAVIOR</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window behavior flags.  <a href="#ga6a690e873a4d59dad0c61ef68f5956e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga8237212754582e94c851bc2515292a2f">WIN_ATTR_CUSTOM</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 5)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute mask for updating window custom data.  <a href="#ga8237212754582e94c851bc2515292a2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga789650d3d663cbd93045f52b3dd9316e">WIN_BEHAVIOR_RAISE_ON_PRESS</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Behavior mask for raising a window if itself or children are pressed.  <a href="#ga789650d3d663cbd93045f52b3dd9316e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga13aa1d186807bb5a1541c319e41aa6e5">WIN_BEHAVIOR_REDRAW_PARENT</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Behavior mask for requiring redraw of parent, e.g. transparent windows.  <a href="#ga13aa1d186807bb5a1541c319e41aa6e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga88c4e328c696315772a72fa222d8bd8f">WIN_ROOT_COLOR</a>&nbsp;&nbsp;&nbsp;GFX_COLOR(0, 0, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Background color of root window, ie. the desktop.  <a href="#ga88c4e328c696315772a72fa222d8bd8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaeffa10e188fe1506221ff704bd4b0ab2">WIN_SCREEN_COLOR</a>&nbsp;&nbsp;&nbsp;GFX_COLOR(0, 0, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Screen background color used when root window is hidden.  <a href="#gaeffa10e188fe1506221ff704bd4b0ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gab2887910e60de963425a56840539c95b">WIN_EVENT_QUEUE_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of event queue.  <a href="#gab2887910e60de963425a56840539c95b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga064f0be7e1f5f1ea5a3efcb22aee25f6">WIN_TOUCH_BUTTON</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Button mask for touch screens.  <a href="#ga064f0be7e1f5f1ea5a3efcb22aee25f6"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga85b7cb6245a830e25e6259e0c4f117a7">win_event_handler_t</a> )(struct <a class="el" href="structwin__window.html">win_window</a> *win, enum <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a> type, const void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function pointer type for window event handlers.  <a href="#ga85b7cb6245a830e25e6259e0c4f117a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga4152f8a36c2ff43b0c02a55737046e2f">win_behavior_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type holding window behavior flags.  <a href="#ga4152f8a36c2ff43b0c02a55737046e2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Datatype holding attribute masks, used when updating attributes.  <a href="#ga7e845240f0251c01d26864f1f7a386d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaafe7a4920c14776f5181e0fc2ad3152b">win_button_mask_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Datatype holding button state mask for pointer input devices.  <a href="#gaafe7a4920c14776f5181e0fc2ad3152b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gadfb4faf1271a151ec8d138dd89764d8c">win_keycode_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Datatype holding the key "scan" code for keyboard input devices.  <a href="#gadfb4faf1271a151ec8d138dd89764d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga53f0ed533fce454af67e765764d7eb5f">win_command_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom data, can be used as a data pointer or data depending on the application.  <a href="#ga53f0ed533fce454af67e765764d7eb5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga65f896e9484ec83f4e8ccce3fbb3e12e">clock_jiffy_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type holding timestamp for events.  <a href="#ga65f896e9484ec83f4e8ccce3fbb3e12e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga977ff672b3aea585f00cb10950e5aaf2">win_pointer_event_type</a> { <a class="el" href="group__gfx__win.html#gga977ff672b3aea585f00cb10950e5aaf2accdf9dcd8cdb612477834cf3fbc47cf8">WIN_POINTER_PRESS</a>, 
<a class="el" href="group__gfx__win.html#gga977ff672b3aea585f00cb10950e5aaf2acf38ef7bba0b554929a29b4dabc76815">WIN_POINTER_MOVE</a>, 
<a class="el" href="group__gfx__win.html#gga977ff672b3aea585f00cb10950e5aaf2a5d9a8016905f31b1c7726370b2f7f0de">WIN_POINTER_RELEASE</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Valid pointer event types. </p>
 <a href="group__gfx__win.html#ga977ff672b3aea585f00cb10950e5aaf2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gab9e5ae3c96cf3c4b1f34fb9b051259c5">win_keyboard_event_type</a> { <a class="el" href="group__gfx__win.html#ggab9e5ae3c96cf3c4b1f34fb9b051259c5ae893da136e1b74d0a0d41eda96fd05d3">WIN_KEYBOARD_PRESS</a>, 
<a class="el" href="group__gfx__win.html#ggab9e5ae3c96cf3c4b1f34fb9b051259c5ad38e763489ad2c69b19edd47b3b1dc73">WIN_KEYBOARD_RELEASE</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Valid keyboard event types. </p>
 <a href="group__gfx__win.html#gab9e5ae3c96cf3c4b1f34fb9b051259c5">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a1e0c0b12cd9f4c453412c5a2437520ac">WIN_EVENT_POINTER</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a4a97aa5cc0d4ef792d0f3d799e815096">WIN_EVENT_KEYBOARD</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a43efd2381d0ac306f0029ca95a9b96a6">WIN_EVENT_COMMAND</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a569a1cfccea6fadd31d827f58dc1de1c">WIN_EVENT_RAISE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a5d30807947553a331f7345a6763a57e5">WIN_EVENT_UNRAISE</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6aec5f9ce15839e52675cc75f41582eed5">WIN_EVENT_GETFOCUS</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a02540e867cac083defba00e56b6d265b">WIN_EVENT_LOSEFOCUS</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6ac6e863c463516b27f2d89eed008cacb6">WIN_EVENT_DRAW</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a7391099f538ed30d3c1679b937841d0c">WIN_EVENT_ATTRIBUTES</a>, 
<a class="el" href="group__gfx__win.html#ggafd48398368ba40935ca545757cb796a6a4a13cc3406aa6b2ebb9e40a1fc111a64">WIN_EVENT_DESTROY</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Valid event types sent to a window event handler. </p>
 <a href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga47664a72394a0199512c70b942e980d9">win_is_visible</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this window and all parents and grand parents are visible.  <a href="#ga47664a72394a0199512c70b942e980d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga73a2c467ceee8fb7da2ad51a674a28bc">win_draw</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__area.html">win_area</a> *dirty_area)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw the parts of the window covered by dirty_area, and all covering windows.  <a href="#ga73a2c467ceee8fb7da2ad51a674a28bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaa27223be4984f501c314f6b85a094b77">win_draw_parent</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *child, const struct <a class="el" href="structwin__area.html">win_area</a> *dirty_area)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw parent window, with all child windows, but limited to dirty area.  <a href="#gaa27223be4984f501c314f6b85a094b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gac858ce7704dd194ebbf2ef92ee5626ff">win_draw_contents</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *clip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw window background and contents, including children, limited to clip.  <a href="#gac858ce7704dd194ebbf2ef92ee5626ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga9dcb40b8542995f1eebabc3dc83b8bc6">win_draw_child</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *child, const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *parentClip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a child window, automatically translating clipping region from parent.  <a href="#ga9dcb40b8542995f1eebabc3dc83b8bc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gadfd3b7fef138ee50492a2e4f556883cc">win_translate_area_to_parent</a> (struct <a class="el" href="structwin__area.html">win_area</a> *area, const struct <a class="el" href="structwin__window.html">win_window</a> *parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate an area to coordinates relative to parent's origin.  <a href="#gadfd3b7fef138ee50492a2e4f556883cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga3a58265f26136f31caf70cd5f6ddee7f">win_destroy_children</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy child windows, freeing allocated memory.  <a href="#ga3a58265f26136f31caf70cd5f6ddee7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga687ddbb57e295a76261aca0dd46d70f5">win_unlink</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove window from parent's linked list.  <a href="#ga687ddbb57e295a76261aca0dd46d70f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gae2b18d132f1171b98c75be4b4193e799">win_add_top_child</a> (struct <a class="el" href="structwin__window.html">win_window</a> *parent, struct <a class="el" href="structwin__window.html">win_window</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add child window at the start of parent's linked list.  <a href="#gae2b18d132f1171b98c75be4b4193e799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaa025dac2e12ab2f9e8e8410344624094">win_process_pointer_event</a> (struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to process pointer event, called from <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>.  <a href="#gaa025dac2e12ab2f9e8e8410344624094"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga508f164411a4c8e2121f35fdc12bdd27">win_handle_pointer_event</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *event, const struct <a class="el" href="structwin__point.html">win_point</a> *pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ask window to process pointer event, or pass it on to correct child.  <a href="#ga508f164411a4c8e2121f35fdc12bdd27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga3f86dfa2a6f5923160e7b5ce4cc3f1f7">win_handle_event</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win, enum <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a> type, const void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call window event handler if any, return value from handler, or false.  <a href="#ga3f86dfa2a6f5923160e7b5ce4cc3f1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga04d63ae18ca9b9a5ada7322bfb66f329">win_queue_event</a> (const struct <a class="el" href="structwin__event.html">win_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an event to the internal queue.  <a href="#ga04d63ae18ca9b9a5ada7322bfb66f329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaba05e17c71f919280aae9e923259e8ad">win_event_worker</a> (struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Worker function to be added to main work queue, calls <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>.  <a href="#gaba05e17c71f919280aae9e923259e8ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga801f8c37a851e8d821ee89a3f2b36d52">win_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize window system, set up root window, hook into touch driver.  <a href="#ga801f8c37a851e8d821ee89a3f2b36d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gabb0c95ee3810418e2dff2264aac277fa">win_get_root</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pointer to root window, i.e. desktop window.  <a href="#gabb0c95ee3810418e2dff2264aac277fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga6021b50012c76c1e75542c9e19683ad2">win_get_parent</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pointer to parent window, or NULL for root window.  <a href="#ga6021b50012c76c1e75542c9e19683ad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga9ce0129c670eb2cea714f4528696a2f2">win_reset_root_geometry</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset root window geometry to fullscreen, in case screen orientation change.  <a href="#ga9ce0129c670eb2cea714f4528696a2f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gadafc28cb8d29a00bb673b3801e942c27">win_set_attributes</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__attributes.html">win_attributes</a> *new_attributes, <a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a> attribute_mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update window attributes, selected by the attribute mask.  <a href="#gadafc28cb8d29a00bb673b3801e942c27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga814a8aadf21b9d34d9c0cc5d2ff33dc2">win_set_area</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__area.html">win_area</a> *new_area, <a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a> attribute_mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update window position and/or size.  <a href="#ga814a8aadf21b9d34d9c0cc5d2ff33dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwin__attributes.html">win_attributes</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga29da48aa55cd8c6e9a851cada651079f">win_get_attributes</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the window attribute struct.  <a href="#ga29da48aa55cd8c6e9a851cada651079f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga3b36b88b8811da7248eb23bc9af1c504">win_get_area</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the window area struct.  <a href="#ga3b36b88b8811da7248eb23bc9af1c504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga78b99e57a2493c4861f2d73863d12cf3">win_get_custom_data</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get window custom data.  <a href="#ga78b99e57a2493c4861f2d73863d12cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga2fef2c618144f46b67fb95ae138131b5">win_create</a> (struct <a class="el" href="structwin__window.html">win_window</a> *parent, const struct <a class="el" href="structwin__attributes.html">win_attributes</a> *attributes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a window and return its pointer. Use <a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f" title="Destroy a window and its contents including children, freeing up memory.">win_destroy()</a> to free memory.  <a href="#ga2fef2c618144f46b67fb95ae138131b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f">win_destroy</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a window and its contents including children, freeing up memory.  <a href="#ga518fd778a7f6c3b7ae2e296e074e743f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gacb08afdf2a35b2895a1d7183ad8f20b0">win_reparent</a> (struct <a class="el" href="structwin__window.html">win_window</a> *child, struct <a class="el" href="structwin__window.html">win_window</a> *new_parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a window's parent.  <a href="#gacb08afdf2a35b2895a1d7183ad8f20b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gacf174cc778747a982b36cbe05e0d247d">win_show</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show window. Will draw it on screen if parent is visible as well.  <a href="#gacf174cc778747a982b36cbe05e0d247d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga7f5e9dd7246c26ade8a7a3a764b3dc74">win_redraw</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Redraw window and its contents, if visible.  <a href="#ga7f5e9dd7246c26ade8a7a3a764b3dc74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gaa767a748d70cd710740007b9994cf31c">win_hide</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hide a window, removing it from screen if is was visible.  <a href="#gaa767a748d70cd710740007b9994cf31c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga1696834cda8fe5fa52149adfa955256e">win_raise</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise window to top of all its siblings.  <a href="#ga1696834cda8fe5fa52149adfa955256e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gab5a4daa4806bd38bb6eeaa10c3a6c555">win_lower</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lower window to bottom of all its siblings.  <a href="#gab5a4daa4806bd38bb6eeaa10c3a6c555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga9f7c8e83b66d206fada54fcc56d1ef2f">win_queue_pointer_event</a> (const struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a pointer event to the internal event queue.  <a href="#ga9f7c8e83b66d206fada54fcc56d1ef2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga12c3bbae74e99bf58c030df9c565ab5c">win_queue_keyboard_event</a> (const struct <a class="el" href="structwin__keyboard__event.html">win_keyboard_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a keyboard event to the internal event queue.  <a href="#ga12c3bbae74e99bf58c030df9c565ab5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga345973b9a55038011d9fe5d024539173">win_queue_command_event</a> (const struct <a class="el" href="structwin__command__event.html">win_command_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a command event to the internal event queue.  <a href="#ga345973b9a55038011d9fe5d024539173"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gae10e8ef17f836aba2e30f141d4bb7ede">win_process_keyboard_event</a> (struct <a class="el" href="structwin__keyboard__event.html">win_keyboard_event</a> *kevent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a keyboard event.  <a href="#gae10e8ef17f836aba2e30f141d4bb7ede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gad905a3533fbd6298b5ef9f3d531c3b8e">win_process_command_event</a> (struct <a class="el" href="structwin__command__event.html">win_command_event</a> *cevent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a command event.  <a href="#gad905a3533fbd6298b5ef9f3d531c3b8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b">win_process_events</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process all pending events from the internal queue.  <a href="#ga05b317761b210501b4cad64d960fef5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gab63d9d5139c46261d5eafe8243744db6">win_set_keyboard_focus</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set keyboard focus window or NULL, i.e. receiver of keyboard events.  <a href="#gab63d9d5139c46261d5eafe8243744db6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gafeab76a239174ba19edacbbf52a5861b">win_grab_pointer</a> (struct <a class="el" href="structwin__window.html">win_window</a> *win)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set pointer focus window or NULL, i.e. override pointer event receiver.  <a href="#gafeab76a239174ba19edacbbf52a5861b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga0628cbc54f8b6e08b96ddf0f1cf5567e">win_is_inside_clip</a> (const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *clip, const struct <a class="el" href="structwin__point.html">win_point</a> *point)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if point is inside clipping region.  <a href="#ga0628cbc54f8b6e08b96ddf0f1cf5567e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga8e6a39cbacfd0b57e187054296971996">win_is_inside_area</a> (const struct <a class="el" href="structwin__area.html">win_area</a> *area, const struct <a class="el" href="structwin__point.html">win_point</a> *point)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if point is inside area.  <a href="#ga8e6a39cbacfd0b57e187054296971996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga073125e6ab6785548fbe7e290cdd8df2">win_is_inside_window</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__point.html">win_point</a> *point)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if global point is inside window.  <a href="#ga073125e6ab6785548fbe7e290cdd8df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga39c753b0d85ca2858e3289fe30589162">win_compute_union</a> (struct <a class="el" href="structwin__area.html">win_area</a> *area, const struct <a class="el" href="structwin__area.html">win_area</a> *merge)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute smallest box containing both areas, update first parameter.  <a href="#ga39c753b0d85ca2858e3289fe30589162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga9c88ebba5df10ffacec6ed5a8555dbc9">win_compute_intersection</a> (struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *clip, const struct <a class="el" href="structwin__area.html">win_area</a> *area)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersection of clipping region and area, update clip.  <a href="#ga9c88ebba5df10ffacec6ed5a8555dbc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga8455b8b262afe0aa3008d5753bda9c1e">win_compute_clipping</a> (const struct <a class="el" href="structwin__window.html">win_window</a> *win, const struct <a class="el" href="structwin__area.html">win_area</a> *dirty_area, struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *clip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute clipping region in absolute coordinates from window and dirty area.  <a href="#ga8455b8b262afe0aa3008d5753bda9c1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gae2fb3daf5677ff55b4930a664cade66e">win_translate_win_to_root</a> (struct <a class="el" href="structwin__window.html">win_window</a> const *start_win, struct <a class="el" href="structwin__point.html">win_point</a> *return_pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute window position on root window.  <a href="#gae2fb3daf5677ff55b4930a664cade66e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structwin__window.html">win_window</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga5733efc0d1a2cf900afae4df206c8ff6">win_root</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Root window, i.e. desktop window.  <a href="#ga5733efc0d1a2cf900afae4df206c8ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structwin__event__queue.html">win_event_queue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga305b487d8ba8fbf9c0967d545f01e4cf">win_event_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Window event queue.  <a href="#ga305b487d8ba8fbf9c0967d545f01e4cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gad3640229e6174c1d1982cbb48f10d858">win_num_dropped_events</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Diagnostic value counting number of dropped events due to event queue full.  <a href="#gad3640229e6174c1d1982cbb48f10d858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga6319cd7ffea8f4ef70574fca5bc23688">win_pointer_grabber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current pointer grabbing window, or NULL. Grabber gets all pointer events.  <a href="#ga6319cd7ffea8f4ef70574fca5bc23688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#ga20c504b38fd082a791d268a9238b4341">win_keyboard_focus</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current keyboard focus, or NULL. Keyboard focus gets all keyboard events.  <a href="#ga20c504b38fd082a791d268a9238b4341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structwin__point.html">win_point</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gada196de944c02212a36885addc9ae3b1">win_last_pointer_pos</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores last pointer event position, in absolute coordinates.  <a href="#gada196de944c02212a36885addc9ae3b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structgfx__bitmap.html">gfx_bitmap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gfx__win.html#gac2a46a8a62f83580823d5eeed0f5547b">win_root_background</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frame background bitmap.  <a href="#gac2a46a8a62f83580823d5eeed0f5547b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Window system for organizing window elements in a graphical user interface (GUI). </p>
<p>The window system is a module for organizing two dimensional windows. Windows are organized in a tree strcture where each window can have one parent but several children. The window system also allows events to be queued and handled by the event handler of the affected windows.</p>
<p>A window is defined with the following properties:</p>
<ul>
<li>A position and area/size</li>
<li>Relation to parent and children</li>
<li>Visibility</li>
<li>Background</li>
<li>Behavior flags</li>
<li>Event handler</li>
</ul>
<p>The window system can be used separately or together with the <a class="el" href="group__gfx__wtk.html">Widget toolkit</a>.</p>
<h2><a class="anchor" id="relation_sec">
Positioning and relations</a></h2>
<p>The windows are organized in a tree structure. A window can be used for graphical user interface (GUI) elements drawn on a screen or display. These elements are often called widgets. The window system can be used to organize any built-in or custom widget. Some examples of widgets are frame, static text, button, checkbox or more advanced widgets like an analog clock.</p>
<p>Each window can have children, and the child windows must be contained within the area of the parent window. This means the child window can be as large as, but not be larger than the parent window. A root window filling the entire screen is created when the window system is initialized with <a class="el" href="group__gfx__win.html#ga801f8c37a851e8d821ee89a3f2b36d52">win_init</a>. If the screen orientation changes the root window can be re-initialized with <a class="el" href="group__gfx__win.html#ga9ce0129c670eb2cea714f4528696a2f2">win_reset_root_geometry</a>. A pointer to the root window is returned from <a class="el" href="group__gfx__win.html#gabb0c95ee3810418e2dff2264aac277fa">win_get_root</a>.</p>
<p>The following figure shows the relations between windows that are used to represent some example widgets. In the figure we show the top_child and next_sibling pointers. The parent and prev_sibling pointers which point in the opposite direction are omitted to simplify the figure.</p>
<p>The figure also illustrates how the position and size affects how the windows could be represented on a display.</p>
<div align="center">
<img src="gfx_win_overview.png" alt="gfx_win_overview.png"/>
</div>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gfx__win.html#ga814a8aadf21b9d34d9c0cc5d2ff33dc2" title="Update window position and/or size.">win_set_area</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#ga2fef2c618144f46b67fb95ae138131b5" title="Create a window and return its pointer. Use win_destroy() to free memory.">win_create</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#gacb08afdf2a35b2895a1d7183ad8f20b0" title="Change a window&#39;s parent.">win_reparent</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#ga6021b50012c76c1e75542c9e19683ad2" title="Get pointer to parent window, or NULL for root window.">win_get_parent</a></dd></dl>
<h2><a class="anchor" id="visibility_sec">
Visibility</a></h2>
<p>A window can only be shown if it has been mapped to the screen with the <a class="el" href="group__gfx__win.html#gacf174cc778747a982b36cbe05e0d247d">win_show</a> function and that the parent windows are also mapped to the screen.</p>
<p>When a window is drawn, the following happens:</p>
<ul>
<li>If WIN_BEHAVIOR_REDRAW_PARENT attribute is set the parent will be drawn.</li>
<li>Background for window will be drawn</li>
<li>Event handler for window will be called to draw the window/widget.</li>
<li>Children will be drawn starting with the bottom child and ending with the top child.</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gfx__win.html#ga7f5e9dd7246c26ade8a7a3a764b3dc74" title="Redraw window and its contents, if visible.">win_redraw</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#gacf174cc778747a982b36cbe05e0d247d" title="Show window. Will draw it on screen if parent is visible as well.">win_show</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#gaa767a748d70cd710740007b9994cf31c" title="Hide a window, removing it from screen if is was visible.">win_hide</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#ga1696834cda8fe5fa52149adfa955256e" title="Raise window to top of all its siblings.">win_raise</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#gab5a4daa4806bd38bb6eeaa10c3a6c555" title="Lower window to bottom of all its siblings.">win_lower</a></dd></dl>
<h2><a class="anchor" id="event_handling_sec">
Event handling</a></h2>
<p>Propagation of events are an important part of the window system. Events are added to the event queue with one of queue functions (<a class="el" href="group__gfx__win.html#ga9f7c8e83b66d206fada54fcc56d1ef2f">win_queue_pointer_event</a>, <a class="el" href="group__gfx__win.html#ga12c3bbae74e99bf58c030df9c565ab5c">win_queue_keyboard_event</a>, <a class="el" href="group__gfx__win.html#ga345973b9a55038011d9fe5d024539173">win_queue_command_event</a>). When an event is queued, the <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b">win_process_events</a> function is automatically added to the main <a class="el" href="group__workqueue__group.html#ga6c0de22a1ae8b7797e67df97f23f4707">main workqueue</a>. This ensures that the event is handled after the current workqueue item is completed.</p>
<p>The events are handled differently depending on the event. Valid event types are defined by <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gfx__win.html#ga2fef2c618144f46b67fb95ae138131b5" title="Create a window and return its pointer. Use win_destroy() to free memory.">win_create</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#ga29da48aa55cd8c6e9a851cada651079f" title="Get a pointer to the window attribute struct.">win_get_attributes</a> </dd>
<dd>
<a class="el" href="group__gfx__win.html#gadafc28cb8d29a00bb673b3801e942c27" title="Update window attributes, selected by the attribute mask.">win_set_attributes</a></dd></dl>
<ul>
<li>Keyboard events are sent to the window which has focus. See <a class="el" href="group__gfx__win.html#gab63d9d5139c46261d5eafe8243744db6">win_set_keyboard_focus</a>. This means that the event handler for that window will be called. If the event handler does not accept the event (ie the event handler returns false), the event will be sent to the parent window. It will continue propagating to all parents until accepted. If no window accepts the event or no window has focus, the event will be discarded. <div align="center">
<img src="gfx_win_event_handling_keyboard_event.png" alt="gfx_win_event_handling_keyboard_event.png"/>
</div>
</li>
</ul>
<ul>
<li>Command events are sent to the window which is set as recipient of the event <a class="el" href="structwin__command__event.html">struct win_command_event</a>. It will propagate up to parents in the same way as the keyboard events. <div align="center">
<img src="gfx_win_event_handling_command_event.png" alt="gfx_win_event_handling_command_event.png"/>
</div>
</li>
</ul>
<ul>
<li>Pointer events are handled a bit differently. If a window has requested to get all pointer events with the <a class="el" href="group__gfx__win.html#gafeab76a239174ba19edacbbf52a5861b">win_grab_pointer</a> function, the event handler for that window is called. The return value of this event handler is ignored. If no window has grabbed the pointer, the pointer event will start from the <a class="el" href="group__gfx__win.html#ga5733efc0d1a2cf900afae4df206c8ff6">root window</a>. It will then search the children to find the window that is under the pointer. <a class="el" href="group__gfx__win.html#ga8e6a39cbacfd0b57e187054296971996">win_is_inside_area</a> If no window is found or the window under the pointer does not accept the event, it will search the recursively through the children. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__gfx__win.html#gaa025dac2e12ab2f9e8e8410344624094" title="Helper function to process pointer event, called from win_process_events().">win_process_pointer_event</a>. <div align="center">
<img src="gfx_win_event_handling_pointer_event.png" alt="gfx_win_event_handling_pointer_event.png"/>
</div>
</dd></dl>
</li>
<li>Window draw events are sent to the window to allow it to draw itself after the window system has drawn the background for the window. See <a class="el" href="group__gfx__win.html#visibility_sec">window visibility</a> </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga10cdd071efc236de8fc91cbde76965fe"></a><!-- doxytag: member="win.h::WIN_ATTR_BACKGROUND" ref="ga10cdd071efc236de8fc91cbde76965fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_BACKGROUND&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window background type and color/pixmap. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00175">175</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a690e873a4d59dad0c61ef68f5956e4"></a><!-- doxytag: member="win.h::WIN_ATTR_BEHAVIOR" ref="ga6a690e873a4d59dad0c61ef68f5956e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_BEHAVIOR&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window behavior flags. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00179">179</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8237212754582e94c851bc2515292a2f"></a><!-- doxytag: member="win.h::WIN_ATTR_CUSTOM" ref="ga8237212754582e94c851bc2515292a2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_CUSTOM&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window custom data. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00181">181</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5417f6d99f122c1277037946daac86a4"></a><!-- doxytag: member="win.h::WIN_ATTR_EVENTHANDLER" ref="ga5417f6d99f122c1277037946daac86a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_EVENTHANDLER&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window event handler. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00177">177</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac9ee551a42534b9ce1ca67318f48f257"></a><!-- doxytag: member="win.h::WIN_ATTR_POSITION" ref="gac9ee551a42534b9ce1ca67318f48f257" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_POSITION&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window position. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00171">171</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

<p>Referenced by <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, and <a class="el" href="wtk__frame_8c_source.html#l00407">wtk_resize_frame()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0bbe2e4323615d774dcdc35626af27ec"></a><!-- doxytag: member="win.h::WIN_ATTR_SIZE" ref="ga0bbe2e4323615d774dcdc35626af27ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ATTR_SIZE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attribute mask for updating window size. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00173">173</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

<p>Referenced by <a class="el" href="wtk__frame_8c_source.html#l00407">wtk_resize_frame()</a>.</p>

</div>
</div>
<a class="anchor" id="ga789650d3d663cbd93045f52b3dd9316e"></a><!-- doxytag: member="win.h::WIN_BEHAVIOR_RAISE_ON_PRESS" ref="ga789650d3d663cbd93045f52b3dd9316e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_BEHAVIOR_RAISE_ON_PRESS&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Behavior mask for raising a window if itself or children are pressed. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00184">184</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01629">win_handle_pointer_event()</a>, and <a class="el" href="wtk__frame_8c_source.html#l01018">wtk_frame_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga13aa1d186807bb5a1541c319e41aa6e5"></a><!-- doxytag: member="win.h::WIN_BEHAVIOR_REDRAW_PARENT" ref="ga13aa1d186807bb5a1541c319e41aa6e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_BEHAVIOR_REDRAW_PARENT&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Behavior mask for requiring redraw of parent, e.g. transparent windows. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00186">186</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>, <a class="el" href="wtk__basic__frame_8c_source.html#l00236">wtk_basic_frame_create()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00333">wtk_check_box_create()</a>, <a class="el" href="wtk__frame_8c_source.html#l01018">wtk_frame_create()</a>, <a class="el" href="wtk__label_8c_source.html#l00235">wtk_label_create()</a>, and <a class="el" href="wtk__radio__button_8c_source.html#l00372">wtk_radio_button_create()</a>.</p>

</div>
</div>
<a class="anchor" id="gab2887910e60de963425a56840539c95b"></a><!-- doxytag: member="win.h::WIN_EVENT_QUEUE_SIZE" ref="gab2887910e60de963425a56840539c95b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_EVENT_QUEUE_SIZE&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of event queue. </p>
<p>The event queue holds both input and command events.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The size of the event queue must be a power of two. </dd></dl>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00077">77</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga88c4e328c696315772a72fa222d8bd8f"></a><!-- doxytag: member="win.h::WIN_ROOT_COLOR" ref="ga88c4e328c696315772a72fa222d8bd8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_ROOT_COLOR&nbsp;&nbsp;&nbsp;GFX_COLOR(0, 0, 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Background color of root window, ie. the desktop. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00065">65</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeffa10e188fe1506221ff704bd4b0ab2"></a><!-- doxytag: member="win.h::WIN_SCREEN_COLOR" ref="gaeffa10e188fe1506221ff704bd4b0ab2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_SCREEN_COLOR&nbsp;&nbsp;&nbsp;GFX_COLOR(0, 0, 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Screen background color used when root window is hidden. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00068">68</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga064f0be7e1f5f1ea5a3efcb22aee25f6"></a><!-- doxytag: member="win.h::WIN_TOUCH_BUTTON" ref="ga064f0be7e1f5f1ea5a3efcb22aee25f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WIN_TOUCH_BUTTON&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Button mask for touch screens. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00080">80</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga65f896e9484ec83f4e8ccce3fbb3e12e"></a><!-- doxytag: member="win.h::clock_jiffy_t" ref="ga65f896e9484ec83f4e8ccce3fbb3e12e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> <a class="el" href="group__gfx__win.html#ga65f896e9484ec83f4e8ccce3fbb3e12e">clock_jiffy_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data type holding timestamp for events. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00062">62</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e845240f0251c01d26864f1f7a386d7"></a><!-- doxytag: member="win.h::win_attribute_mask_t" ref="ga7e845240f0251c01d26864f1f7a386d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> <a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Datatype holding attribute masks, used when updating attributes. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00325">325</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4152f8a36c2ff43b0c02a55737046e2f"></a><!-- doxytag: member="win.h::win_behavior_t" ref="ga4152f8a36c2ff43b0c02a55737046e2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> <a class="el" href="group__gfx__win.html#ga4152f8a36c2ff43b0c02a55737046e2f">win_behavior_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data type holding window behavior flags. </p>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00306">306</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaafe7a4920c14776f5181e0fc2ad3152b"></a><!-- doxytag: member="win.h::win_button_mask_t" ref="gaafe7a4920c14776f5181e0fc2ad3152b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> <a class="el" href="group__gfx__win.html#gaafe7a4920c14776f5181e0fc2ad3152b">win_button_mask_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Datatype holding button state mask for pointer input devices. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00050">50</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga53f0ed533fce454af67e765764d7eb5f"></a><!-- doxytag: member="win.h::win_command_t" ref="ga53f0ed533fce454af67e765764d7eb5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__gfx__win.html#ga53f0ed533fce454af67e765764d7eb5f">win_command_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Custom data, can be used as a data pointer or data depending on the application. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00059">59</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga85b7cb6245a830e25e6259e0c4f117a7"></a><!-- doxytag: member="win.h::win_event_handler_t" ref="ga85b7cb6245a830e25e6259e0c4f117a7" args=")(struct win_window *win, enum win_event_type type, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="group__gfx__win.html#ga85b7cb6245a830e25e6259e0c4f117a7">win_event_handler_t</a>)(struct <a class="el" href="structwin__window.html">win_window</a> *win, enum <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a> type, const void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function pointer type for window event handlers. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Document the parameters and return value. </dd></dl>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00300">300</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadfb4faf1271a151ec8d138dd89764d8c"></a><!-- doxytag: member="win.h::win_keycode_t" ref="gadfb4faf1271a151ec8d138dd89764d8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> <a class="el" href="group__gfx__win.html#gadfb4faf1271a151ec8d138dd89764d8c">win_keycode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Datatype holding the key "scan" code for keyboard input devices. </p>

<p>Definition at line <a class="el" href="include_2gfx_2default_2win_8h_source.html#l00053">53</a> of file <a class="el" href="include_2gfx_2default_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gafd48398368ba40935ca545757cb796a6"></a><!-- doxytag: member="win.h::win_event_type" ref="gafd48398368ba40935ca545757cb796a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Valid event types sent to a window event handler. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a1e0c0b12cd9f4c453412c5a2437520ac"></a><!-- doxytag: member="WIN_EVENT_POINTER" ref="ggafd48398368ba40935ca545757cb796a6a1e0c0b12cd9f4c453412c5a2437520ac" args="" -->WIN_EVENT_POINTER</em>&nbsp;</td><td>
<p>Pointer event, more details in the event itself. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a4a97aa5cc0d4ef792d0f3d799e815096"></a><!-- doxytag: member="WIN_EVENT_KEYBOARD" ref="ggafd48398368ba40935ca545757cb796a6a4a97aa5cc0d4ef792d0f3d799e815096" args="" -->WIN_EVENT_KEYBOARD</em>&nbsp;</td><td>
<p>Keyboard event, more details in the event itself. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a43efd2381d0ac306f0029ca95a9b96a6"></a><!-- doxytag: member="WIN_EVENT_COMMAND" ref="ggafd48398368ba40935ca545757cb796a6a43efd2381d0ac306f0029ca95a9b96a6" args="" -->WIN_EVENT_COMMAND</em>&nbsp;</td><td>
<p>Command event, more details in the event itself. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a569a1cfccea6fadd31d827f58dc1de1c"></a><!-- doxytag: member="WIN_EVENT_RAISE" ref="ggafd48398368ba40935ca545757cb796a6a569a1cfccea6fadd31d827f58dc1de1c" args="" -->WIN_EVENT_RAISE</em>&nbsp;</td><td>
<p>Window was just raised to top inside its parent. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a5d30807947553a331f7345a6763a57e5"></a><!-- doxytag: member="WIN_EVENT_UNRAISE" ref="ggafd48398368ba40935ca545757cb796a6a5d30807947553a331f7345a6763a57e5" args="" -->WIN_EVENT_UNRAISE</em>&nbsp;</td><td>
<p>Another window just raised to top. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6aec5f9ce15839e52675cc75f41582eed5"></a><!-- doxytag: member="WIN_EVENT_GETFOCUS" ref="ggafd48398368ba40935ca545757cb796a6aec5f9ce15839e52675cc75f41582eed5" args="" -->WIN_EVENT_GETFOCUS</em>&nbsp;</td><td>
<p>Just got keyboard focus. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a02540e867cac083defba00e56b6d265b"></a><!-- doxytag: member="WIN_EVENT_LOSEFOCUS" ref="ggafd48398368ba40935ca545757cb796a6a02540e867cac083defba00e56b6d265b" args="" -->WIN_EVENT_LOSEFOCUS</em>&nbsp;</td><td>
<p>Just lost keyboard focus. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6ac6e863c463516b27f2d89eed008cacb6"></a><!-- doxytag: member="WIN_EVENT_DRAW" ref="ggafd48398368ba40935ca545757cb796a6ac6e863c463516b27f2d89eed008cacb6" args="" -->WIN_EVENT_DRAW</em>&nbsp;</td><td>
<p>Request to draw contents, after background. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a7391099f538ed30d3c1679b937841d0c"></a><!-- doxytag: member="WIN_EVENT_ATTRIBUTES" ref="ggafd48398368ba40935ca545757cb796a6a7391099f538ed30d3c1679b937841d0c" args="" -->WIN_EVENT_ATTRIBUTES</em>&nbsp;</td><td>
<p>Attributes updated, attribute mask included. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafd48398368ba40935ca545757cb796a6a4a13cc3406aa6b2ebb9e40a1fc111a64"></a><!-- doxytag: member="WIN_EVENT_DESTROY" ref="ggafd48398368ba40935ca545757cb796a6a4a13cc3406aa6b2ebb9e40a1fc111a64" args="" -->WIN_EVENT_DESTROY</em>&nbsp;</td><td>
<p>Request to free all allocated memory. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00258">258</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab9e5ae3c96cf3c4b1f34fb9b051259c5"></a><!-- doxytag: member="win.h::win_keyboard_event_type" ref="gab9e5ae3c96cf3c4b1f34fb9b051259c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__gfx__win.html#gab9e5ae3c96cf3c4b1f34fb9b051259c5">win_keyboard_event_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Valid keyboard event types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab9e5ae3c96cf3c4b1f34fb9b051259c5ae893da136e1b74d0a0d41eda96fd05d3"></a><!-- doxytag: member="WIN_KEYBOARD_PRESS" ref="ggab9e5ae3c96cf3c4b1f34fb9b051259c5ae893da136e1b74d0a0d41eda96fd05d3" args="" -->WIN_KEYBOARD_PRESS</em>&nbsp;</td><td>
<p>A key has been pressed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab9e5ae3c96cf3c4b1f34fb9b051259c5ad38e763489ad2c69b19edd47b3b1dc73"></a><!-- doxytag: member="WIN_KEYBOARD_RELEASE" ref="ggab9e5ae3c96cf3c4b1f34fb9b051259c5ad38e763489ad2c69b19edd47b3b1dc73" args="" -->WIN_KEYBOARD_RELEASE</em>&nbsp;</td><td>
<p>A key has been released. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00239">239</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga977ff672b3aea585f00cb10950e5aaf2"></a><!-- doxytag: member="win.h::win_pointer_event_type" ref="ga977ff672b3aea585f00cb10950e5aaf2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__gfx__win.html#ga977ff672b3aea585f00cb10950e5aaf2">win_pointer_event_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Valid pointer event types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga977ff672b3aea585f00cb10950e5aaf2accdf9dcd8cdb612477834cf3fbc47cf8"></a><!-- doxytag: member="WIN_POINTER_PRESS" ref="gga977ff672b3aea585f00cb10950e5aaf2accdf9dcd8cdb612477834cf3fbc47cf8" args="" -->WIN_POINTER_PRESS</em>&nbsp;</td><td>
<p>One or more buttons have been pressed somewhere. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga977ff672b3aea585f00cb10950e5aaf2acf38ef7bba0b554929a29b4dabc76815"></a><!-- doxytag: member="WIN_POINTER_MOVE" ref="gga977ff672b3aea585f00cb10950e5aaf2acf38ef7bba0b554929a29b4dabc76815" args="" -->WIN_POINTER_MOVE</em>&nbsp;</td><td>
<p>Pointer has moved, with or without buttons. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga977ff672b3aea585f00cb10950e5aaf2a5d9a8016905f31b1c7726370b2f7f0de"></a><!-- doxytag: member="WIN_POINTER_RELEASE" ref="gga977ff672b3aea585f00cb10950e5aaf2a5d9a8016905f31b1c7726370b2f7f0de" args="" -->WIN_POINTER_RELEASE</em>&nbsp;</td><td>
<p>One or more buttons have been released somewhere. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="include_2gfx_2win_8h_source.html#l00215">215</a> of file <a class="el" href="include_2gfx_2win_8h_source.html">win.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae2b18d132f1171b98c75be4b4193e799"></a><!-- doxytag: member="win.c::win_add_top_child" ref="gae2b18d132f1171b98c75be4b4193e799" args="(struct win_window *parent, struct win_window *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_add_top_child </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add child window at the start of parent's linked list. </p>
<p>This function adds a child window as the top window of a parent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent window for this child. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Child window to add to parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01545">1545</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00073">win_window::next_sibling</a>, <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="win_8c_source.html#l00071">win_window::prev_sibling</a>, and <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>.</p>

</div>
</div>
<a class="anchor" id="ga8455b8b262afe0aa3008d5753bda9c1e"></a><!-- doxytag: member="win.c::win_compute_clipping" ref="ga8455b8b262afe0aa3008d5753bda9c1e" args="(const struct win_window *win, const struct win_area *dirty_area, struct win_clip_region *clip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool win_compute_clipping </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>dirty_area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *&nbsp;</td>
          <td class="paramname"> <em>clip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute clipping region in absolute coordinates from window and dirty area. </p>
<p>This function computes a clipping region given a window and an area given in that window's coordinate system. The area is translated to screen coordinates by translating from parent to parent until the root window is reached. Also, the area is clipped to fit, inside the window, and its parents. Use this function to compute a clipping region for updating parts of a window. If the resulting region is an empty set, the function returns false.</p>
<p>The dirty_area parameter is given in the same coordinate system as the window's area struct. This means that if you provide a pointer to the window's area as the dirty_area parameter, you get a clipping region covering the entire window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>The window to start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dirty_area</em>&nbsp;</td><td>Area to be clipped, same coordinate system as window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Resulting clipping region, global coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The resulting region is valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The resulting region is an empty set. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c88ebba5df10ffacec6ed5a8555dbc9"></a><!-- doxytag: member="win.c::win_compute_intersection" ref="ga9c88ebba5df10ffacec6ed5a8555dbc9" args="(struct win_clip_region *clip, const struct win_area *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool win_compute_intersection </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *&nbsp;</td>
          <td class="paramname"> <em>clip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersection of clipping region and area, update clip. </p>
<p>This function computes the intersection of a clipping region and an area. The clipping region is updated with the result, so that the new region only contains the area common to both the original region and the area. If the clipping region and the area did not share any areas, i.e. the result is empty set, then the function returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Original clipping region, and also where the result is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>Area to compute intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The resulting area is valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The resulting area is an empty set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga39c753b0d85ca2858e3289fe30589162"></a><!-- doxytag: member="win.c::win_compute_union" ref="ga39c753b0d85ca2858e3289fe30589162" args="(struct win_area *area, const struct win_area *merge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_compute_union </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>merge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute smallest box containing both areas, update first parameter. </p>
<p>This function computes the smallest area the will fit both areas. The new area is copied into the first parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>First area, and also where the result is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>merge</em>&nbsp;</td><td>Second area, which is "merged" with the first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2fef2c618144f46b67fb95ae138131b5"></a><!-- doxytag: member="win.c::win_create" ref="ga2fef2c618144f46b67fb95ae138131b5" args="(struct win_window *parent, const struct win_attributes *attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a> * win_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__attributes.html">win_attributes</a> *&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a window and return its pointer. Use <a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f" title="Destroy a window and its contents including children, freeing up memory.">win_destroy()</a> to free memory. </p>
<p>This function attempts to allocate memory for a new window from the dynamic memory pool. If successful, it initializes the window and attaches it to the parent, raising it to the top of all siblings, and returns the window pointer. If it fails, the function returns NULL.</p>
<p>Use <a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f" title="Destroy a window and its contents including children, freeing up memory.">win_destroy()</a> to properly free the allocated memory. Refer to the <a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f" title="Destroy a window and its contents including children, freeing up memory.">win_destroy()</a> function for more details on the destroy procedure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Pointer to parent window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>Pointer to initial attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to allocated window struct, or NULL. </dd></dl>

<p>Referenced by <a class="el" href="app__memgame_8c_source.html#l00800">app_memgame_launch()</a>, <a class="el" href="app__slideshow_8c_source.html#l00384">slide_launch_helper()</a>, <a class="el" href="wtk__basic__frame_8c_source.html#l00236">wtk_basic_frame_create()</a>, <a class="el" href="wtk__button_8c_source.html#l00307">wtk_button_create()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00333">wtk_check_box_create()</a>, <a class="el" href="wtk__frame_8c_source.html#l01018">wtk_frame_create()</a>, <a class="el" href="wtk__label_8c_source.html#l00235">wtk_label_create()</a>, <a class="el" href="wtk__progress__bar_8c_source.html#l00308">wtk_progress_bar_create()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00372">wtk_radio_button_create()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00466">wtk_slider_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga518fd778a7f6c3b7ae2e296e074e743f"></a><!-- doxytag: member="win.c::win_destroy" ref="ga518fd778a7f6c3b7ae2e296e074e743f" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a window and its contents including children, freeing up memory. </p>
<p>This function hides a window, detaches it from its parent. It then frees all memory allocated by all its children, grand children etc, and itself. Before freeing the memory, a DESTROY event is sent to each window's event handler. Use this event to free memory and resources allocated by e.g. widget toolkits. Since each window is detached from its parent before sending the DESTROY event, the event handling should never attempt to refer to parent windows.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="app__fonts_8c_source.html#l00548">app_fonts_load()</a>, <a class="el" href="app__fonts_8c_source.html#l00487">app_fonts_load_worker()</a>, <a class="el" href="app__memgame_8c_source.html#l00800">app_memgame_launch()</a>, <a class="el" href="app__tank_8c_source.html#l00618">app_tank_launch()</a>, <a class="el" href="app__memgame_8c_source.html#l00412">memgame_draw_piece()</a>, <a class="el" href="app__memgame_8c_source.html#l00665">memgame_handle_command_event()</a>, <a class="el" href="app__slideshow_8c_source.html#l00384">slide_launch_helper()</a>, <a class="el" href="app__slideshow_8c_source.html#l00294">slide_window_handler()</a>, <a class="el" href="app__tank_8c_source.html#l00506">tank_loader()</a>, <a class="el" href="wtk__basic__frame_8c_source.html#l00115">wtk_basic_frame_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l01018">wtk_frame_create()</a>, and <a class="el" href="wtk__frame_8c_source.html#l00764">wtk_frame_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a58265f26136f31caf70cd5f6ddee7f"></a><!-- doxytag: member="win.c::win_destroy_children" ref="ga3a58265f26136f31caf70cd5f6ddee7f" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_destroy_children </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy child windows, freeing allocated memory. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#ga518fd778a7f6c3b7ae2e296e074e743f" title="Destroy a window and its contents including children, freeing up memory.">win_destroy()</a> function. For every child window, it asks it to destroy its children, then it send a DESTROY event to the child, and finally frees the allocated memory. The window's DESTROY event handler should free any other memory or resources allocated by e.g. widgets.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is recursive, so ensure that your application has plenty of stack space before calling this function.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window whose children should be destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01491">1491</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="membag_8c_source.html#l00327">membag_free()</a>, <a class="el" href="win_8c_source.html#l00073">win_window::next_sibling</a>, <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00278">WIN_EVENT_DESTROY</a>, and <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga73a2c467ceee8fb7da2ad51a674a28bc"></a><!-- doxytag: member="win.c::win_draw" ref="ga73a2c467ceee8fb7da2ad51a674a28bc" args="(const struct win_window *win, const struct win_area *dirty_area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_draw </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>dirty_area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw the parts of the window covered by dirty_area, and all covering windows. </p>
<p>This function takes care of the actual drawing of all or parts of a window. If the window is not the top window, i.e. obscured by other windows, these other windows are also redrawn in the proper order. Only the parts of the windows that need to will be redrawn.</p>
<p>The dirty_area parameter dictates which areas of the window to draw or redraw. The area is given in the same coordinate system as the window itself, which means that providing the window's own area struct will result in drawing the entire window. If only smaller parts of the window needs to be drawn, make a copy of the window's area struct and update to your liking before passing to this function.</p>
<p>For windows that are partly transparent, e.g. drop shadows or round corners, the parent is asked to redraw all its child windows, in order to provide a fresh background for the window to draw upon. This applies to windows with the behavior flag REDRAW_PARENT set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to draw or redraw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dirty_area</em>&nbsp;</td><td>Area dictating which parts to draw. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01223">1223</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="include_2gfx_2win_8h_source.html#l00311">win_attributes::area</a>, <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00319">win_attributes::behavior</a>, <a class="el" href="win_8c_source.html#l00078">win_window::is_mapped</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00207">win_clip_region::origin</a>, <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00200">win_area::pos</a>, <a class="el" href="win_8c_source.html#l00071">win_window::prev_sibling</a>, <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00186">WIN_BEHAVIOR_REDRAW_PARENT</a>, <a class="el" href="group__gfx__win.html#ga8455b8b262afe0aa3008d5753bda9c1e">win_compute_clipping()</a>, <a class="el" href="win_8c_source.html#l01353">win_draw_child()</a>, <a class="el" href="win_8c_source.html#l01312">win_draw_contents()</a>, <a class="el" href="win_8c_source.html#l01284">win_draw_parent()</a>, and <a class="el" href="win_8c_source.html#l00173">win_root</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01284">win_draw_parent()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9dcb40b8542995f1eebabc3dc83b8bc6"></a><!-- doxytag: member="win.c::win_draw_child" ref="ga9dcb40b8542995f1eebabc3dc83b8bc6" args="(const struct win_window *child, const struct win_clip_region *parentClip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_draw_child </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *&nbsp;</td>
          <td class="paramname"> <em>parent_clip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a child window, automatically translating clipping region from parent. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#ga73a2c467ceee8fb7da2ad51a674a28bc" title="Draw the parts of the window covered by dirty_area, and all covering windows.">win_draw()</a> and <a class="el" href="group__gfx__win.html#gac858ce7704dd194ebbf2ef92ee5626ff" title="Draw window background and contents, including children, limited to clip.">win_draw_contents()</a> functions. It takes care of updating the clipping region, intersecting it with the child window area. Then it draws the child window's contents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Child window to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_clip</em>&nbsp;</td><td>Clipping region, in global coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01353">1353</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="include_2gfx_2win_8h_source.html#l00311">win_attributes::area</a>, <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00209">win_clip_region::NW</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00207">win_clip_region::origin</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00200">win_area::pos</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00211">win_clip_region::SE</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00201">win_area::size</a>, and <a class="el" href="win_8c_source.html#l01312">win_draw_contents()</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>, and <a class="el" href="win_8c_source.html#l01312">win_draw_contents()</a>.</p>

</div>
</div>
<a class="anchor" id="gac858ce7704dd194ebbf2ef92ee5626ff"></a><!-- doxytag: member="win.c::win_draw_contents" ref="gac858ce7704dd194ebbf2ef92ee5626ff" args="(const struct win_window *win, const struct win_clip_region *clip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_draw_contents </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *&nbsp;</td>
          <td class="paramname"> <em>clip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw window background and contents, including children, limited to clip. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#ga73a2c467ceee8fb7da2ad51a674a28bc" title="Draw the parts of the window covered by dirty_area, and all covering windows.">win_draw()</a> function. It draws the actual contents of a window, given a clipping region. First, it draws the window background itself, depending on the type. Then it sends a DRAW event to the window, so that e.g. widgets or other handlers can draw the rest of the window contents. Finally, it asks all mapped children, if any, to draw themselves.</p>
<p>Note that when the DRAW event is sent to the window, the TFT clipping region is already set, so all TFT graphics functions called from the event handler will be subject to proper clipping automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>The window to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Clipping region, in global coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Either de-constify <em>win</em> or constify the parameter to <a class="el" href="group__gfx__win.html#ga3f86dfa2a6f5923160e7b5ce4cc3f1f7" title="Call window event handler if any, return value from handler, or false.">win_handle_event()</a>. The code below looks dangerous. </dd></dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01312">1312</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00314">win_attributes::background</a>, <a class="el" href="gfx__bitmap_8c_source.html#l00104">gfx_draw_bitmap_tiled()</a>, <a class="el" href="gfx__hx8347a_8c_source.html#l00212">gfx_set_clipping()</a>, <a class="el" href="win_8c_source.html#l00078">win_window::is_mapped</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00209">win_clip_region::NW</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00207">win_clip_region::origin</a>, <a class="el" href="win_8c_source.html#l00071">win_window::prev_sibling</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00211">win_clip_region::SE</a>, <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>, <a class="el" href="win_8c_source.html#l01353">win_draw_child()</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00274">WIN_EVENT_DRAW</a>, and <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>, and <a class="el" href="win_8c_source.html#l01353">win_draw_child()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa27223be4984f501c314f6b85a094b77"></a><!-- doxytag: member="win.c::win_draw_parent" ref="gaa27223be4984f501c314f6b85a094b77" args="(const struct win_window *child, const struct win_area *dirty_area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_draw_parent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>dirty_area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw parent window, with all child windows, but limited to dirty area. </p>
<p>This function is a shortcut to ask a window's parent to draw all its children. However, the area to draw is given in the same coordinate system as the child window, i.e. point 0,0 is top left corner of the parent window. This function is used e.g. when rearranging child windows or to draw partly transparent windows.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Child window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dirty_area</em>&nbsp;</td><td>The area, given in same coordinate system as the child. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01284">1284</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="win_8c_source.html#l01223">win_draw()</a>, and <a class="el" href="win_8c_source.html#l01445">win_translate_area_to_parent()</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba05e17c71f919280aae9e923259e8ad"></a><!-- doxytag: member="win.c::win_event_worker" ref="gaba05e17c71f919280aae9e923259e8ad" args="(struct workqueue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_event_worker </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structworkqueue__task.html">workqueue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Worker function to be added to main work queue, calls <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>. </p>
<p>This function will be used as the work item callback when new events are added to the queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>Pointer to the task being run, not used in function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01810">1810</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b">win_process_events()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b36b88b8811da7248eb23bc9af1c504"></a><!-- doxytag: member="win.c::win_get_area" ref="ga3b36b88b8811da7248eb23bc9af1c504" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__area.html">win_area</a> * win_get_area </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the window area struct. </p>
<p>This function returns a pointer to the internal area struct of a window. It cannot be modified, but could be copied from.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to area struct. </dd></dl>

<p>Referenced by <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l00764">wtk_frame_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, <a class="el" href="wtk__frame_8c_source.html#l00361">wtk_handle_resize_release()</a>, <a class="el" href="wtk__label_8c_source.html#l00131">wtk_label_handler()</a>, <a class="el" href="wtk__progress__bar_8c_source.html#l00195">wtk_progress_bar_handler()</a>, <a class="el" href="wtk__progress__bar_8c_source.html#l00106">wtk_progress_bar_set_value()</a>, <a class="el" href="wtk__frame_8c_source.html#l00407">wtk_resize_frame()</a>, <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00155">wtk_slider_set_value()</a>.</p>

</div>
</div>
<a class="anchor" id="ga29da48aa55cd8c6e9a851cada651079f"></a><!-- doxytag: member="win.c::win_get_attributes" ref="ga29da48aa55cd8c6e9a851cada651079f" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__attributes.html">win_attributes</a> * win_get_attributes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the window attribute struct. </p>
<p>This function returns a pointer to the internal attribute struct of a window. It cannot be modified, but could be copied from.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to attribute struct. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78b99e57a2493c4861f2d73863d12cf3"></a><!-- doxytag: member="win.c::win_get_custom_data" ref="ga78b99e57a2493c4861f2d73863d12cf3" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * win_get_custom_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get window custom data. </p>
<p>This function returns the custom data from the window's attributes. The custom data can be used for e.g. linking to associated widgets.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Copy of the custom data. </dd></dl>

<p>Referenced by <a class="el" href="wtk__basic__frame_8c_source.html#l00115">wtk_basic_frame_handler()</a>, <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00146">wtk_check_box_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l00764">wtk_frame_handler()</a>, <a class="el" href="wtk__label_8c_source.html#l00131">wtk_label_handler()</a>, <a class="el" href="wtk__progress__bar_8c_source.html#l00195">wtk_progress_bar_handler()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00162">wtk_radio_button_handler()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6021b50012c76c1e75542c9e19683ad2"></a><!-- doxytag: member="win.c::win_get_parent" ref="ga6021b50012c76c1e75542c9e19683ad2" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a> * win_get_parent </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get pointer to parent window, or NULL for root window. </p>
<p>Return pointer to parent window, or NULL for root window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Child window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to parent window. </dd></dl>

<p>Referenced by <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, and <a class="el" href="wtk__frame_8c_source.html#l00361">wtk_handle_resize_release()</a>.</p>

</div>
</div>
<a class="anchor" id="gabb0c95ee3810418e2dff2264aac277fa"></a><!-- doxytag: member="win.c::win_get_root" ref="gabb0c95ee3810418e2dff2264aac277fa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a> * win_get_root </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get pointer to root window, i.e. desktop window. </p>
<p>Return a pointer to the root window. Use this to change the attributes of the root window, or use the root window as a parent for new windows.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to root window. </dd></dl>

<p>Referenced by <a class="el" href="app__memgame_8c_source.html#l00800">app_memgame_launch()</a>, <a class="el" href="app__tank_8c_source.html#l00618">app_tank_launch()</a>, <a class="el" href="app__desktop_8c_source.html#l00519">load_desktop()</a>, and <a class="el" href="app__slideshow_8c_source.html#l00384">slide_launch_helper()</a>.</p>

</div>
</div>
<a class="anchor" id="gafeab76a239174ba19edacbbf52a5861b"></a><!-- doxytag: member="win.c::win_grab_pointer" ref="gafeab76a239174ba19edacbbf52a5861b" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_grab_pointer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set pointer focus window or NULL, i.e. override pointer event receiver. </p>
<p>This function sets a pointer grabber window. The window that has grabbed the pointer will receive all further pointer events until another window grabs to pointer, or the pointer is ungrabbed by setting the grabbing window to NULL. Use this function to grab the pointer to widgets that in certain states needs to get all pointer events, e.g. dragging.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to grabbing window, or NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00146">wtk_check_box_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l00201">wtk_handle_frame_press()</a>, <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, <a class="el" href="wtk__frame_8c_source.html#l00302">wtk_handle_resize_press()</a>, <a class="el" href="wtk__frame_8c_source.html#l00361">wtk_handle_resize_release()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00162">wtk_radio_button_handler()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f86dfa2a6f5923160e7b5ce4cc3f1f7"></a><!-- doxytag: member="win.c::win_handle_event" ref="ga3f86dfa2a6f5923160e7b5ce4cc3f1f7" args="(struct win_window *win, enum win_event_type type, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool win_handle_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__gfx__win.html#gafd48398368ba40935ca545757cb796a6">win_event_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call window event handler if any, return value from handler, or false. </p>
<p>This function is a small helper function that checks if a window has an event handler at all, and in that case, sends it an event for handling. If an event handler is present, and accepts the event, this function returns true. If the event handler rejects it, or there's no event handler present, this function returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to handle event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Event type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Custom data, dependent on event type.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>Event handler present and accepts event </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>No event handler present or event handler doesn't accept event. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01707">1707</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, and <a class="el" href="include_2gfx_2win_8h_source.html#l00317">win_attributes::event_handler</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01491">win_destroy_children()</a>, <a class="el" href="win_8c_source.html#l01312">win_draw_contents()</a>, <a class="el" href="win_8c_source.html#l01629">win_handle_pointer_event()</a>, <a class="el" href="win_8c_source.html#l00792">win_process_command_event()</a>, <a class="el" href="win_8c_source.html#l00764">win_process_keyboard_event()</a>, and <a class="el" href="win_8c_source.html#l01577">win_process_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga508f164411a4c8e2121f35fdc12bdd27"></a><!-- doxytag: member="win.c::win_handle_pointer_event" ref="ga508f164411a4c8e2121f35fdc12bdd27" args="(struct win_window *win, const struct win_pointer_event *event, const struct win_point *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool win_handle_pointer_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__point.html">win_point</a> *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ask window to process pointer event, or pass it on to correct child. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#gaa025dac2e12ab2f9e8e8410344624094" title="Helper function to process pointer event, called from win_process_events().">win_process_pointer_event()</a> function. The pointer event is already processed, so this function searches through its child windows to find the one beneath the pointer. If no suitable child windows are found, the window handles the pointer event itself. If either a child or this window accepts the event, this function returns true.</p>
<p>Any window encountered with the RAISE_ON_BUTTON behavior flag set will be raised to the top inside it's parent, if the event was a POINTER_PRESS.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is recursive, so ensure that your application has plenty of stack space before calling this function.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to handle the event itself, or pass on to children. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Pointer event to handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Absolute position, translated to window's own coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if child or window itself accepted the event. </dd></dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01629">1629</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="include_2gfx_2win_8h_source.html#l00311">win_attributes::area</a>, <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00319">win_attributes::behavior</a>, <a class="el" href="win_8c_source.html#l00078">win_window::is_mapped</a>, <a class="el" href="win_8c_source.html#l00073">win_window::next_sibling</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00200">win_area::pos</a>, <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00235">win_pointer_event::type</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00184">WIN_BEHAVIOR_RAISE_ON_PRESS</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00260">WIN_EVENT_POINTER</a>, <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>, <a class="el" href="group__gfx__win.html#ga8e6a39cbacfd0b57e187054296971996">win_is_inside_area()</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00217">WIN_POINTER_PRESS</a>, and <a class="el" href="group__gfx__win.html#ga1696834cda8fe5fa52149adfa955256e">win_raise()</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01577">win_process_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa767a748d70cd710740007b9994cf31c"></a><!-- doxytag: member="win.c::win_hide" ref="gaa767a748d70cd710740007b9994cf31c" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_hide </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hide a window, removing it from screen if is was visible. </p>
<p>This function unmaps a window from its parent. If it was visible, it will be removed from the screen. If the root window is hidden, the screen background will be erased to the color WIN_SCREEN_COLOR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga801f8c37a851e8d821ee89a3f2b36d52"></a><!-- doxytag: member="win.c::win_init" ref="ga801f8c37a851e8d821ee89a3f2b36d52" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize window system, set up root window, hook into touch driver. </p>
<p>This function initializes the windowing system. Call this function before any other window system operations, as this initializes the root window, internal queues and other internals. </p>

</div>
</div>
<a class="anchor" id="ga8e6a39cbacfd0b57e187054296971996"></a><!-- doxytag: member="win.c::win_is_inside_area" ref="ga8e6a39cbacfd0b57e187054296971996" args="(const struct win_area *area, const struct win_point *point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool win_is_inside_area </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__point.html">win_point</a> *&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if point is inside area. </p>
<p>This function checks if a point is inside a given area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>Pointer to area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Pointer to point to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if point is inside area. </dd></dl>

<p>Referenced by <a class="el" href="win_8c_source.html#l01629">win_handle_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0628cbc54f8b6e08b96ddf0f1cf5567e"></a><!-- doxytag: member="win.c::win_is_inside_clip" ref="ga0628cbc54f8b6e08b96ddf0f1cf5567e" args="(const struct win_clip_region *clip, const struct win_point *point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool win_is_inside_clip </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__clip__region.html">win_clip_region</a> *&nbsp;</td>
          <td class="paramname"> <em>clip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__point.html">win_point</a> *&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if point is inside clipping region. </p>
<p>This function checks if a point is inside the clipping region. The origin field of the clipping region is not relevant, only the corners of the clipping region itself.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Pointer to clipping region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Pointer to point to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if point is inside clipping region. </dd></dl>

</div>
</div>
<a class="anchor" id="ga073125e6ab6785548fbe7e290cdd8df2"></a><!-- doxytag: member="win.c::win_is_inside_window" ref="ga073125e6ab6785548fbe7e290cdd8df2" args="(const struct win_window *win, const struct win_point *point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool win_is_inside_window </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__point.html">win_point</a> *&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if global point is inside window. </p>
<p>This function checks if point given in global coordinates is inside a given window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Point in global coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>if <em>point</em> is inside <em>win</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>if <em>point</em> is not inside <em>win</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00146">wtk_check_box_handler()</a>, <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, <a class="el" href="wtk__frame_8c_source.html#l00361">wtk_handle_resize_release()</a>, and <a class="el" href="wtk__radio__button_8c_source.html#l00162">wtk_radio_button_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga47664a72394a0199512c70b942e980d9"></a><!-- doxytag: member="win.c::win_is_visible" ref="ga47664a72394a0199512c70b942e980d9" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool win_is_visible </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this window and all parents and grand parents are visible. </p>
<p>This function checks if the window should be visible on screen, or at least drawn on screen but maybe obscured by other windows. If a window's parent is visible, all mapped children are also visible. If any parent on the path up to, and including, the root window is unmapped, the window is not visible. Once again, note that even if a window is "visible", i.e. this function returns true, it might be obscured by other windows on top.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td><em>win</em> is visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td><em>win</em> is not visible. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01182">1182</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00078">win_window::is_mapped</a>, and <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>.</p>

</div>
</div>
<a class="anchor" id="gab5a4daa4806bd38bb6eeaa10c3a6c555"></a><!-- doxytag: member="win.c::win_lower" ref="gab5a4daa4806bd38bb6eeaa10c3a6c555" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_lower </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lower window to bottom of all its siblings. </p>
<p>This function lowers a window to the bottom of the Z-stack of child windows. Proper redraw calls are issued to update graphics. Before rearranging windows, this window is sent an UNRAISE event, and the window the gets to be on top after rearranging is sent a RAISE event. Use these events to update any focus and highlight related graphics.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad905a3533fbd6298b5ef9f3d531c3b8e"></a><!-- doxytag: member="win.c::win_process_command_event" ref="gad905a3533fbd6298b5ef9f3d531c3b8e" args="(struct win_command_event *cevent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_process_command_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__command__event.html">win_command_event</a> *&nbsp;</td>
          <td class="paramname"> <em>cevent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a command event. </p>
<p>This function is only called by <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cevent</em>&nbsp;</td><td>The command event being processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l00792">792</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="assert_8h_source.html#l00089">assert</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00254">win_command_event::data</a>, <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00253">win_command_event::recipient</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00264">WIN_EVENT_COMMAND</a>, and <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05b317761b210501b4cad64d960fef5b"></a><!-- doxytag: member="win.c::win_process_events" ref="ga05b317761b210501b4cad64d960fef5b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_process_events </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process all pending events from the internal queue. </p>
<p>This function processes all pending events from the internal queue. In order for the window system to work properly, this function should be called as often as possible, to process new events. In this implementation, whenever a new event is added to the queue, the system automatically adds a work item to the main application work queue. This work item refers to <a class="el" href="group__gfx__win.html#gaba05e17c71f919280aae9e923259e8ad" title="Worker function to be added to main work queue, calls win_process_events().">win_event_worker()</a> which in turn will call this function to process all pending events.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is recursive, so ensure that your application has plenty of stack space before calling this function. </dd></dl>

<p>Referenced by <a class="el" href="win_8c_source.html#l01810">win_event_worker()</a>.</p>

</div>
</div>
<a class="anchor" id="gae10e8ef17f836aba2e30f141d4bb7ede"></a><!-- doxytag: member="win.c::win_process_keyboard_event" ref="gae10e8ef17f836aba2e30f141d4bb7ede" args="(struct win_keyboard_event *kevent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_process_keyboard_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__keyboard__event.html">win_keyboard_event</a> *&nbsp;</td>
          <td class="paramname"> <em>kevent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a keyboard event. </p>
<p>This function is only called by <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kevent</em>&nbsp;</td><td>The keyboard event being processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l00764">764</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00262">WIN_EVENT_KEYBOARD</a>, and <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa025dac2e12ab2f9e8e8410344624094"></a><!-- doxytag: member="win.c::win_process_pointer_event" ref="gaa025dac2e12ab2f9e8e8410344624094" args="(struct win_pointer_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_process_pointer_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to process pointer event, called from <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a>. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#ga05b317761b210501b4cad64d960fef5b" title="Process all pending events from the internal queue.">win_process_events()</a> function. It processes a pointer event by sending it to either the current pointer grabbing window or into the window tree to find the window that is directly beneath the pointer. The function also converts any relative coordinates to absolute screen coordinates.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Pointer event data to process. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01577">1577</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="include_2gfx_2win_8h_source.html#l00229">win_pointer_event::is_relative</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00260">WIN_EVENT_POINTER</a>, <a class="el" href="win_8c_source.html#l01707">win_handle_event()</a>, <a class="el" href="win_8c_source.html#l01629">win_handle_pointer_event()</a>, <a class="el" href="win_8c_source.html#l00187">win_last_pointer_pos</a>, and <a class="el" href="win_8c_source.html#l00173">win_root</a>.</p>

</div>
</div>
<a class="anchor" id="ga345973b9a55038011d9fe5d024539173"></a><!-- doxytag: member="win.c::win_queue_command_event" ref="ga345973b9a55038011d9fe5d024539173" args="(const struct win_command_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_queue_command_event </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__command__event.html">win_command_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a command event to the internal event queue. </p>
<p>This function creates a struct <a class="el" href="structwin__event.html" title="Event data for all events.">win_event</a> from the command event and adds it to the internal event queue. The event data is copied, so there is no need to keep the event variable alive after calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Pointer to command event data. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00146">wtk_check_box_handler()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00162">wtk_radio_button_handler()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga04d63ae18ca9b9a5ada7322bfb66f329"></a><!-- doxytag: member="win.c::win_queue_event" ref="ga04d63ae18ca9b9a5ada7322bfb66f329" args="(const struct win_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_queue_event </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__event.html">win_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an event to the internal queue. </p>
<p>This function adds a window event to the internal queue, taking care of the internals of updating the circular queue. This function is reentrant and protected from interrupts, so it can be called at any time from anywhere without concern for concurrency. The event data is copied into the queue, so there is no need to keep the event variable alive after calling this function. This function also takes care of adding a work item to the main work queue of the application once new events arrive. If there are already events in the queue, no extra work items will be added.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Set a timestamp for each event. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Event to add to the queue. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01780">1780</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00069">cpu_irq_restore()</a>, <a class="el" href="arch_2avr8_2include_2arch_2interrupt_8h_source.html#l00055">cpu_irq_save()</a>, <a class="el" href="workqueue_8c_source.html#l00047">main_workqueue</a>, <a class="el" href="win_8c_source.html#l00179">win_num_dropped_events</a>, and <a class="el" href="group__workqueue__group.html#gaba0573bf3d1a0201616ec03944ecfd41">workqueue_add_task()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12c3bbae74e99bf58c030df9c565ab5c"></a><!-- doxytag: member="win.c::win_queue_keyboard_event" ref="ga12c3bbae74e99bf58c030df9c565ab5c" args="(const struct win_keyboard_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_queue_keyboard_event </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__keyboard__event.html">win_keyboard_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a keyboard event to the internal event queue. </p>
<p>This function creates a struct <a class="el" href="structwin__event.html" title="Event data for all events.">win_event</a> from the keyboard event and adds it to the internal event queue. The event data is copied, so there is no need to keep the event variable alive after calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Pointer to keyboard event data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f7c8e83b66d206fada54fcc56d1ef2f"></a><!-- doxytag: member="win.c::win_queue_pointer_event" ref="ga9f7c8e83b66d206fada54fcc56d1ef2f" args="(const struct win_pointer_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_queue_pointer_event </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__pointer__event.html">win_pointer_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a pointer event to the internal event queue. </p>
<p>This function creates a struct <a class="el" href="structwin__event.html" title="Event data for all events.">win_event</a> from the pointer event and adds it to the internal event queue. The event data is copied, so there is no need to keep the event variable alive after calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Pointer to pointer event data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1696834cda8fe5fa52149adfa955256e"></a><!-- doxytag: member="win.c::win_raise" ref="ga1696834cda8fe5fa52149adfa955256e" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_raise </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raise window to top of all its siblings. </p>
<p>This function raises a window to the top of the Z-stack of child windows. Proper redraw calls are issued to update graphics. Before rearranging windows, the current top window is sent an UNRAISE event, and after putting this window on top, this gets a RAISE event. Use these events to update any focus and highlight related graphics.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="win_8c_source.html#l01629">win_handle_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f5e9dd7246c26ade8a7a3a764b3dc74"></a><!-- doxytag: member="win.c::win_redraw" ref="ga7f5e9dd7246c26ade8a7a3a764b3dc74" args="(const struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_redraw </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Redraw window and its contents, if visible. </p>
<p>This function redraws a window, if it is mapped and visible. Use this function to refresh graphics if e.g. a widget's state is changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="app__files_8c_source.html#l00391">app_files_frame_command_handler()</a>, <a class="el" href="app__fonts_8c_source.html#l00436">app_fonts_frame_command_handler()</a>, <a class="el" href="app__fonts_8c_source.html#l00487">app_fonts_load_worker()</a>, <a class="el" href="app__widget_8c_source.html#l00185">app_widget_update_colors()</a>, <a class="el" href="app__desktop_8c_source.html#l00519">load_desktop()</a>, <a class="el" href="app__memgame_8c_source.html#l00504">memgame_start_new_game()</a>, <a class="el" href="wtk__button_8c_source.html#l00103">wtk_button_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00146">wtk_check_box_handler()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00118">wtk_check_box_set()</a>, <a class="el" href="wtk__check__box_8c_source.html#l00102">wtk_check_box_toggle()</a>, <a class="el" href="wtk__label_8c_source.html#l00081">wtk_label_change()</a>, <a class="el" href="wtk__progress__bar_8c_source.html#l00106">wtk_progress_bar_set_value()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00372">wtk_radio_button_create()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00162">wtk_radio_button_handler()</a>, <a class="el" href="wtk__radio__button_8c_source.html#l00119">wtk_radio_button_select()</a>, <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00155">wtk_slider_set_value()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb08afdf2a35b2895a1d7183ad8f20b0"></a><!-- doxytag: member="win.c::win_reparent" ref="gacb08afdf2a35b2895a1d7183ad8f20b0" args="(struct win_window *child, struct win_window *new_parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_reparent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>new_parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a window's parent. </p>
<p>This function detaches a window from its parent and attaches it to a new parent, as the top child window. This essentially moves a window from one parent to another. If the window is not mapped, it will still be unmapped at the new parent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Pointer to child window to reparent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_parent</em>&nbsp;</td><td>Pointer to new parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ce0129c670eb2cea714f4528696a2f2"></a><!-- doxytag: member="win.c::win_reset_root_geometry" ref="ga9ce0129c670eb2cea714f4528696a2f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_reset_root_geometry </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset root window geometry to fullscreen, in case screen orientation change. </p>
<p>This function resets the root window size to fill the entire screen. Use this function to reconfigure the root window after a change in screen orientation. </p>

</div>
</div>
<a class="anchor" id="ga814a8aadf21b9d34d9c0cc5d2ff33dc2"></a><!-- doxytag: member="win.c::win_set_area" ref="ga814a8aadf21b9d34d9c0cc5d2ff33dc2" args="(struct win_window *win, const struct win_area *new_area, win_attribute_mask_t attribute_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_set_area </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>new_area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a>&nbsp;</td>
          <td class="paramname"> <em>attribute_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update window position and/or size. </p>
<p>This function updates the window position and/or size. The flags of the attribute mask decides what to update. Note that you cannot change the position or size of the root window, since the root window is always fullscreen.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window that will be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_area</em>&nbsp;</td><td>Pointer to new area attributes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute_mask</em>&nbsp;</td><td>Attribute flags selecting which attributes to update. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="wtk__frame_8c_source.html#l00260">wtk_handle_frame_release()</a>, and <a class="el" href="wtk__frame_8c_source.html#l00407">wtk_resize_frame()</a>.</p>

</div>
</div>
<a class="anchor" id="gadafc28cb8d29a00bb673b3801e942c27"></a><!-- doxytag: member="win.c::win_set_attributes" ref="gadafc28cb8d29a00bb673b3801e942c27" args="(struct win_window *win, const struct win_attributes *new_attributes, win_attribute_mask_t attribute_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_set_attributes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__attributes.html">win_attributes</a> *&nbsp;</td>
          <td class="paramname"> <em>new_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gfx__win.html#ga7e845240f0251c01d26864f1f7a386d7">win_attribute_mask_t</a>&nbsp;</td>
          <td class="paramname"> <em>attribute_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update window attributes, selected by the attribute mask. </p>
<p>This function updates one or more of a window's attributes. Only the the attributes corresponding to the flags of the attribute mask are updated. The others are left untouched.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window that will be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_attributes</em>&nbsp;</td><td>Pointer to new attribute values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute_mask</em>&nbsp;</td><td>Attribute flags selecting which attributes to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab63d9d5139c46261d5eafe8243744db6"></a><!-- doxytag: member="win.c::win_set_keyboard_focus" ref="gab63d9d5139c46261d5eafe8243744db6" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_set_keyboard_focus </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set keyboard focus window or NULL, i.e. receiver of keyboard events. </p>
<p>This function changes the keyboard focus window. The current keyboard focus window is sent a LOSEFOCUS event, and the new focus window is sent a GETFOCUS event. The keyboard focus window will receive all keyboard events. Set the focus window to NULL to remove the focus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to the new keyboard focus window, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf174cc778747a982b36cbe05e0d247d"></a><!-- doxytag: member="win.c::win_show" ref="gacf174cc778747a982b36cbe05e0d247d" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_show </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Show window. Will draw it on screen if parent is visible as well. </p>
<p>This function maps a window to its parent. Mapping means that the window will be visible and drawn if the parent is visible, unless obscured by other windows of course.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Pointer to window. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="app__files_8c_source.html#l00440">app_files_load_worker()</a>, <a class="el" href="app__fonts_8c_source.html#l00487">app_fonts_load_worker()</a>, <a class="el" href="app__memgame_8c_source.html#l00800">app_memgame_launch()</a>, <a class="el" href="app__tank_8c_source.html#l00618">app_tank_launch()</a>, <a class="el" href="app__slideshow_8c_source.html#l00384">slide_launch_helper()</a>, <a class="el" href="app__tank_8c_source.html#l00506">tank_loader()</a>, and <a class="el" href="wtk__frame_8c_source.html#l01018">wtk_frame_create()</a>.</p>

</div>
</div>
<a class="anchor" id="gadfd3b7fef138ee50492a2e4f556883cc"></a><!-- doxytag: member="win.c::win_translate_area_to_parent" ref="gadfd3b7fef138ee50492a2e4f556883cc" args="(struct win_area *area, const struct win_window *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool win_translate_area_to_parent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__area.html">win_area</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translate an area to coordinates relative to parent's origin. </p>
<p>This function is a helper function for the <a class="el" href="group__gfx__win.html#gaa27223be4984f501c314f6b85a094b77" title="Draw parent window, with all child windows, but limited to dirty area.">win_draw_parent()</a> function. It translates an area given in the same coordinate system as the child window, to the same system as the parent window. The area is clipped inside the parent extents if required. If the resulting area is en empty set, the function returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>The area to translate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent window.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>The resulting area is valid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>The resulting area is an empty set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01445">1445</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="include_2gfx_2win_8h_source.html#l00311">win_attributes::area</a>, <a class="el" href="win_8c_source.html#l00066">win_window::attributes</a>, <a class="el" href="include_2gfx_2win_8h_source.html#l00200">win_area::pos</a>, and <a class="el" href="include_2gfx_2win_8h_source.html#l00201">win_area::size</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01284">win_draw_parent()</a>.</p>

</div>
</div>
<a class="anchor" id="gae2fb3daf5677ff55b4930a664cade66e"></a><!-- doxytag: member="win.c::win_translate_win_to_root" ref="gae2fb3daf5677ff55b4930a664cade66e" args="(struct win_window const *start_win, struct win_point *return_pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void win_translate_win_to_root </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> const *&nbsp;</td>
          <td class="paramname"> <em>start_win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwin__point.html">win_point</a> *&nbsp;</td>
          <td class="paramname"> <em>return_pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute window position on root window. </p>
<p>This function calculates the position of a window on the root window. It traverses all parent windows and adds their position to get the position of the given window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_win</em>&nbsp;</td><td>The window of which to find absolute position. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>return_pos</em>&nbsp;</td><td>The absolute position of the window </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="wtk__slider_8c_source.html#l00466">wtk_slider_create()</a>, and <a class="el" href="wtk__slider_8c_source.html#l00213">wtk_slider_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga687ddbb57e295a76261aca0dd46d70f5"></a><!-- doxytag: member="win.c::win_unlink" ref="ga687ddbb57e295a76261aca0dd46d70f5" args="(struct win_window *win)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void win_unlink </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwin__window.html">win_window</a> *&nbsp;</td>
          <td class="paramname"> <em>win</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove window from parent's linked list. </p>
<p>This function pulls out a window from the parent window's linked list of of child windows. This function is used when rearranging child windows.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>Window to be unlinked from parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="win_8c_source.html#l01517">1517</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>References <a class="el" href="win_8c_source.html#l00073">win_window::next_sibling</a>, <a class="el" href="win_8c_source.html#l00069">win_window::parent</a>, <a class="el" href="win_8c_source.html#l00071">win_window::prev_sibling</a>, and <a class="el" href="win_8c_source.html#l00075">win_window::top_child</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga305b487d8ba8fbf9c0967d545f01e4cf"></a><!-- doxytag: member="win.c::win_event_queue" ref="ga305b487d8ba8fbf9c0967d545f01e4cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__event__queue.html">win_event_queue</a> <a class="el" href="structwin__event__queue.html">win_event_queue</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Window event queue. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00176">176</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga20c504b38fd082a791d268a9238b4341"></a><!-- doxytag: member="win.c::win_keyboard_focus" ref="ga20c504b38fd082a791d268a9238b4341" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a>* <a class="el" href="group__gfx__win.html#ga20c504b38fd082a791d268a9238b4341">win_keyboard_focus</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current keyboard focus, or NULL. Keyboard focus gets all keyboard events. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00184">184</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

</div>
</div>
<a class="anchor" id="gada196de944c02212a36885addc9ae3b1"></a><!-- doxytag: member="win.c::win_last_pointer_pos" ref="gada196de944c02212a36885addc9ae3b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__point.html">win_point</a> <a class="el" href="group__gfx__win.html#gada196de944c02212a36885addc9ae3b1">win_last_pointer_pos</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores last pointer event position, in absolute coordinates. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00187">187</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01577">win_process_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3640229e6174c1d1982cbb48f10d858"></a><!-- doxytag: member="win.c::win_num_dropped_events" ref="gad3640229e6174c1d1982cbb48f10d858" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="group__gfx__win.html#gad3640229e6174c1d1982cbb48f10d858">win_num_dropped_events</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Diagnostic value counting number of dropped events due to event queue full. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00179">179</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01780">win_queue_event()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6319cd7ffea8f4ef70574fca5bc23688"></a><!-- doxytag: member="win.c::win_pointer_grabber" ref="ga6319cd7ffea8f4ef70574fca5bc23688" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a>* <a class="el" href="group__gfx__win.html#ga6319cd7ffea8f4ef70574fca5bc23688">win_pointer_grabber</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current pointer grabbing window, or NULL. Grabber gets all pointer events. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00182">182</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5733efc0d1a2cf900afae4df206c8ff6"></a><!-- doxytag: member="win.c::win_root" ref="ga5733efc0d1a2cf900afae4df206c8ff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwin__window.html">win_window</a> <a class="el" href="group__gfx__win.html#ga5733efc0d1a2cf900afae4df206c8ff6">win_root</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Root window, i.e. desktop window. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00173">173</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

<p>Referenced by <a class="el" href="win_8c_source.html#l01223">win_draw()</a>, and <a class="el" href="win_8c_source.html#l01577">win_process_pointer_event()</a>.</p>

</div>
</div>
<a class="anchor" id="gac2a46a8a62f83580823d5eeed0f5547b"></a><!-- doxytag: member="win.c::win_root_background" ref="gac2a46a8a62f83580823d5eeed0f5547b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structgfx__bitmap.html">gfx_bitmap</a> <a class="el" href="group__gfx__win.html#gac2a46a8a62f83580823d5eeed0f5547b">win_root_background</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
                .type = <a class="code" href="group__gfx__gfx.html#ggaaa3d242c7c08ccafbb00bbcfabe27e3fa5347f7bf0548ae0c3cc8210f49b937a6" title="Solid color bitmap.">BITMAP_SOLID</a>,
                .data.color = <a class="code" href="group__gfx__gfx.html#ga211e684859b29d9a8a5943d1498d533c" title="Generate a display-native color value from constant RGB components.">GFX_COLOR</a>(0, 0, 0),
}
</pre></div>
<p>Frame background bitmap. </p>

<p>Definition at line <a class="el" href="win_8c_source.html#l00190">190</a> of file <a class="el" href="win_8c_source.html">win.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:09:59 2010 for display-demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
