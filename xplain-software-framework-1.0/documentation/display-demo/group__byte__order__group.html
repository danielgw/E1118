<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>display-demo: Byte Order Conversion</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Byte Order Conversion<br/>
<small>
[<a class="el" href="group__utility__group.html">Utility Library</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Byte Order Conversion:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__byte__order__group.png" border="0" alt="" usemap="#group____byte____order____group_map"/>
<map name="group____byte____order____group_map" id="group____byte____order____group">
<area shape="rect" href="group__utility__group.html" title="Utility Library" alt="" coords="7,5,103,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Conversion to/from Little Endian values</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp6d8736e13b49bc1b4c883ac656ff6a7b"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga687180d38fb1df3756a55129bc2bc843">le16_to_cpu</a> (<a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 16-bit word from little endian to native byte order.  <a href="#ga687180d38fb1df3756a55129bc2bc843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11">le32_to_cpu</a> (<a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 32-bit word from little endian to native byte order.  <a href="#ga458156f2db7e8071a13a9cb244219e11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#gaa0dabdefd84fa1180f9a332e8e34a73f">cpu_to_le16</a> (<a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 16-bit word from native to little endian byte order.  <a href="#gaa0dabdefd84fa1180f9a332e8e34a73f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#gab44bd5db41a2ff675115a29145513ac5">cpu_to_le32</a> (<a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 32-bit word from native to little endian byte order.  <a href="#gab44bd5db41a2ff675115a29145513ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga54d648861a1120a3f8d6255e9cf54125">LE16</a>(x)&nbsp;&nbsp;&nbsp;((<a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a> __force)(x))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a 16-bit little endian constant.  <a href="#ga54d648861a1120a3f8d6255e9cf54125"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga4f24e3d1dc0a8bf7ad7a60553d13daa7">LE32</a>(x)&nbsp;&nbsp;&nbsp;((<a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a> __force)(x))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a 32-bit little endian constant.  <a href="#ga4f24e3d1dc0a8bf7ad7a60553d13daa7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Conversion to/from Big Endian values</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbf0135041b3c3d081058f316de8ce5bc"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga56010b090459f1f50707347784a0e019">be16_to_cpu</a> (<a class="el" href="types_8h.html#a262cc3b58c3117ea9e8d2ff31477348c">be16_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 16-bit word from big endian to native byte order.  <a href="#ga56010b090459f1f50707347784a0e019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga22012a41b863a1906624ab144964c83d">be32_to_cpu</a> (<a class="el" href="types_8h.html#a0fda6059326a492c573e67d3fa9190e9">be32_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 32-bit word from big endian to native byte order.  <a href="#ga22012a41b863a1906624ab144964c83d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a262cc3b58c3117ea9e8d2ff31477348c">be16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#gac55b6698e3141a541a7a9dde4744537b">cpu_to_be16</a> (<a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 16-bit word from native to big endian byte order.  <a href="#gac55b6698e3141a541a7a9dde4744537b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a0fda6059326a492c573e67d3fa9190e9">be32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga002704089e626f3cdeef1389eace52b8">cpu_to_be32</a> (<a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a 32-bit word from native to big endian byte order.  <a href="#ga002704089e626f3cdeef1389eace52b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga34c0ccbaef341c224a18eb4dcaf44407">BE16</a>(x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a 16-bit big endian constant.  <a href="#ga34c0ccbaef341c224a18eb4dcaf44407"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#gae88eb35e4ef96c0c0f59871c8fce75b8">BE32</a>(x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a 32-bit big endian constant.  <a href="#gae88eb35e4ef96c0c0f59871c8fce75b8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Byte Swapping</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp8761427ce4fd1d82661a0b107d56a2f6"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga5a92bb57c6684a4bd94c9cd73165d9d6">swab32</a>(x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the order of bytes in a 32-bit word.  <a href="#ga5a92bb57c6684a4bd94c9cd73165d9d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__byte__order__group.html#ga1f5477fbe927a1d634e6712f1e3860fb">swab16</a>(x)&nbsp;&nbsp;&nbsp;((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &gt;&gt; 8) &amp; 0xff))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the order of bytes in a 16-bit word.  <a href="#ga1f5477fbe927a1d634e6712f1e3860fb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>When communicating with the world outside the CPU on which the code is running, it is important that multi-byte values are interpreted the same way by all parties. Unfortunately, the CPUs of the world do interpret things differently unless special care is taken by the programmer; the vast majority of CPUs can be divided into two groups, depending on how multi-byte values are interpreted:</p>
<ul>
<li>Big Endian: The most significant byte comes first</li>
<li>Little Endian: The least significant byte comes first</li>
</ul>
<p>Every time two processors need to communicate, or need to access the same on-disk filesystem, or share any data in any way, the byte ordering (or <em>endianness</em>) must be clearly defined, and all processors must accept this regardless of their native byte ordering.</p>
<p>This module provides a set of helper functions which can be used to read and write data using a pre-defined byte order, regardless of the native byte ordering of the CPU. Byte swapping is performed as necessary, but if the pre-defined byte order matches the native byte order, no extra overhead is added.</p>
<dl class="user"><dt><b>Example</b></dt><dd>In the following example, a packet is received over some kind of network from some other, unknown CPU. The network protocol dictates that the sequence number is transfered as little endian (i.e. least significant byte first). The function get_seq_number() below will return the correct sequence number regardless of the CPU's native byte order. <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>packet {
        <a class="code" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17" title="Unsigned 32-bit quantity, little endian byte order.">le32_t</a> seq_number;
        <a class="code" href="types_8h.html#a467964c91885f34b69185f7356842d70" title="Unsigned 16-bit quantity, little endian byte order.">le16_t</a> size;
        <a class="code" href="group__stdint__group.html#gae1affc9ca37cfb624959c866a73f83c2" title="8-bit unsigned integer">uint8_t</a> data[];
};

<a class="code" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa" title="32-bit unsigned integer">uint32_t</a> get_seq_number(<span class="keyword">const</span> <span class="keyword">struct</span> packet *pkt)
{
        <span class="keywordflow">return</span> <a class="code" href="group__byte__order__group.html#ga458156f2db7e8071a13a9cb244219e11" title="Convert a 32-bit word from little endian to native byte order.">le32_to_cpu</a>(pkt-&gt;seq_number);
} 
</pre></div></dd></dl>
<p>Note that the helper functions in this module is the only legal way to convert between endian-aware types and native types. For example, to convert from a le16_t variable to a uint16_t variable, the function <a class="el" href="group__byte__order__group.html#ga687180d38fb1df3756a55129bc2bc843" title="Convert a 16-bit word from little endian to native byte order.">le16_to_cpu()</a> must be used. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga34c0ccbaef341c224a18eb4dcaf44407"></a><!-- doxytag: member="byteorder.h::BE16" ref="ga34c0ccbaef341c224a18eb4dcaf44407" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BE16</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="types_8h.html#a262cc3b58c3117ea9e8d2ff31477348c" title="Unsigned 16-bit quantity, big endian byte order.">be16_t</a> <a class="code" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c" title="Force a type cast.">__force</a>)((((x) &amp; 0xff) &lt;&lt; 8)           \
                                        | (((x) &gt;&gt; 8) &amp; 0xff)))
</pre></div>
<p>Create a 16-bit big endian constant. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00224">224</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae88eb35e4ef96c0c0f59871c8fce75b8"></a><!-- doxytag: member="byteorder.h::BE32" ref="gae88eb35e4ef96c0c0f59871c8fce75b8" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BE32</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="types_8h.html#a0fda6059326a492c573e67d3fa9190e9" title="Unsigned 32-bit quantity, big endian byte order.">be32_t</a> <a class="code" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c" title="Force a type cast.">__force</a>)((((x) &amp; 0xff) &lt;&lt; 24)          \
                                        | (((x) &amp; 0xff00) &lt;&lt; 8)         \
                                        | (((x) &gt;&gt; 8) &amp; 0xff00)         \
                                        | (((x) &gt;&gt; 24) &amp; 0xff)))
</pre></div>
<p>Create a 32-bit big endian constant. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00226">226</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga54d648861a1120a3f8d6255e9cf54125"></a><!-- doxytag: member="byteorder.h::LE16" ref="ga54d648861a1120a3f8d6255e9cf54125" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE16</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a> __force)(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a 16-bit little endian constant. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00222">222</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f24e3d1dc0a8bf7ad7a60553d13daa7"></a><!-- doxytag: member="byteorder.h::LE32" ref="ga4f24e3d1dc0a8bf7ad7a60553d13daa7" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE32</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a> __force)(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a 32-bit little endian constant. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00223">223</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f5477fbe927a1d634e6712f1e3860fb"></a><!-- doxytag: member="byteorder.h::swab16" ref="ga1f5477fbe927a1d634e6712f1e3860fb" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define swab16</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &gt;&gt; 8) &amp; 0xff))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the order of bytes in a 16-bit word. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00172">172</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>Referenced by <a class="el" href="include_2byteorder_8h_source.html#l00248">be16_to_cpu()</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00256">cpu_to_be16()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a92bb57c6684a4bd94c9cd73165d9d6"></a><!-- doxytag: member="byteorder.h::swab32" ref="ga5a92bb57c6684a4bd94c9cd73165d9d6" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define swab32</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((((x) &amp; 0xff) &lt;&lt; 24) | (((x) &amp; 0xff00) &lt;&lt; 8)   \
         | (((x) &gt;&gt; 8) &amp; 0xff00) | (((x) &gt;&gt; 24) &amp; 0xff))
</pre></div>
<p>Swap the order of bytes in a 32-bit word. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00167">167</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>Referenced by <a class="el" href="include_2byteorder_8h_source.html#l00252">be32_to_cpu()</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00260">cpu_to_be32()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga56010b090459f1f50707347784a0e019"></a><!-- doxytag: member="byteorder.h::be16_to_cpu" ref="ga56010b090459f1f50707347784a0e019" args="(be16_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> be16_to_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a262cc3b58c3117ea9e8d2ff31477348c">be16_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 16-bit word from big endian to native byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00248">248</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00172">swab16</a>.</p>

</div>
</div>
<a class="anchor" id="ga22012a41b863a1906624ab144964c83d"></a><!-- doxytag: member="byteorder.h::be32_to_cpu" ref="ga22012a41b863a1906624ab144964c83d" args="(be32_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a> be32_to_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a0fda6059326a492c573e67d3fa9190e9">be32_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 32-bit word from big endian to native byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00252">252</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00167">swab32</a>.</p>

</div>
</div>
<a class="anchor" id="gac55b6698e3141a541a7a9dde4744537b"></a><!-- doxytag: member="byteorder.h::cpu_to_be16" ref="gac55b6698e3141a541a7a9dde4744537b" args="(uint16_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a262cc3b58c3117ea9e8d2ff31477348c">be16_t</a> cpu_to_be16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 16-bit word from native to big endian byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00256">256</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00172">swab16</a>.</p>

</div>
</div>
<a class="anchor" id="ga002704089e626f3cdeef1389eace52b8"></a><!-- doxytag: member="byteorder.h::cpu_to_be32" ref="ga002704089e626f3cdeef1389eace52b8" args="(uint32_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a0fda6059326a492c573e67d3fa9190e9">be32_t</a> cpu_to_be32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 32-bit word from native to big endian byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00260">260</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>, and <a class="el" href="include_2byteorder_8h_source.html#l00167">swab32</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0dabdefd84fa1180f9a332e8e34a73f"></a><!-- doxytag: member="byteorder.h::cpu_to_le16" ref="gaa0dabdefd84fa1180f9a332e8e34a73f" args="(uint16_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a> cpu_to_le16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 16-bit word from native to little endian byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00239">239</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>.</p>

</div>
</div>
<a class="anchor" id="gab44bd5db41a2ff675115a29145513ac5"></a><!-- doxytag: member="byteorder.h::cpu_to_le32" ref="gab44bd5db41a2ff675115a29145513ac5" args="(uint32_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a> cpu_to_le32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 32-bit word from native to little endian byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00243">243</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>.</p>

</div>
</div>
<a class="anchor" id="ga687180d38fb1df3756a55129bc2bc843"></a><!-- doxytag: member="byteorder.h::le16_to_cpu" ref="ga687180d38fb1df3756a55129bc2bc843" args="(le16_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdint__group.html#ga5a8b2dc9e45a9ee81a94ef304fb62505">uint16_t</a> le16_to_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a467964c91885f34b69185f7356842d70">le16_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 16-bit word from little endian to native byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00231">231</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>.</p>

</div>
</div>
<a class="anchor" id="ga458156f2db7e8071a13a9cb244219e11"></a><!-- doxytag: member="byteorder.h::le32_to_cpu" ref="ga458156f2db7e8071a13a9cb244219e11" args="(le32_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdint__group.html#ga09a1e304d66d35dd47daffee9731edaa">uint32_t</a> le32_to_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7634ed52397bc4a6cba4b0be318e7d17">le32_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a 32-bit word from little endian to native byte order. </p>

<p>Definition at line <a class="el" href="include_2byteorder_8h_source.html#l00235">235</a> of file <a class="el" href="include_2byteorder_8h_source.html">byteorder.h</a>.</p>

<p>References <a class="el" href="group__compiler__group.html#gab95a84e6535084347da05cdf197e045c">__force</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Apr 29 14:10:00 2010 for display-demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
